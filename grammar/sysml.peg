# SysML v2 PEG Grammar for packcc
#
# Parses SysML v2 and builds a semantic graph for JSON output
#
# SPDX-License-Identifier: MIT

%prefix "sysml2"

%header {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Forward declaration for AST builder */
struct SysmlBuildContext;

typedef struct {
    const char *filename;
    const char *input;
    size_t input_len;
    size_t input_pos;
    int error_count;
    int line;
    int col;

    /* Furthest failure tracking for better error messages */
    size_t furthest_pos;
    int furthest_line;
    int furthest_col;
    const char *failed_rules[16];  /* Rules that failed at furthest pos */
    int failed_rule_count;
    const char *context_rule;       /* Enclosing rule for context */

    /* AST building context (optional, NULL if not building AST) */
    struct SysmlBuildContext *build_ctx;
} SysmlParserContext;

#define PCC_GETCHAR(auxil) sysml2_getchar(auxil)
#define PCC_ERROR(auxil) sysml2_error(auxil)

static inline int sysml2_getchar(SysmlParserContext *ctx) {
    if (ctx->input_pos >= ctx->input_len) return EOF;
    int c = (unsigned char)ctx->input[ctx->input_pos++];
    if (c == '\n') {
        ctx->line++;
        ctx->col = 1;
    } else {
        ctx->col++;
    }
    return c;
}

/* Check if a rule name is "noise" that we don't want to report */
static inline int sysml2_is_noise_rule(const char *rule) {
    return strcmp(rule, "_") == 0 || strcmp(rule, "WS") == 0 ||
           strcmp(rule, "LineComment") == 0 || strcmp(rule, "BlockComment") == 0 ||
           strcmp(rule, "IdentCont") == 0 || strcmp(rule, "StringChar") == 0 ||
           strcmp(rule, "EscapeSequence") == 0 || strcmp(rule, "UnrestrictedNameChar") == 0;
}

/* Debug hook to track furthest failure position */
static inline void sysml2_debug_hook(SysmlParserContext *ctx, int event,
                                     const char *rule, size_t pos) {
    if (event != 2) return;  /* Only track NOMATCH (event == 2) */
    if (sysml2_is_noise_rule(rule)) return;

    if (pos > ctx->furthest_pos) {
        /* New furthest position - reset tracking */
        ctx->furthest_pos = pos;
        ctx->furthest_line = ctx->line;
        ctx->furthest_col = ctx->col;
        ctx->failed_rule_count = 0;
        ctx->context_rule = NULL;
    }

    if (pos == ctx->furthest_pos && ctx->failed_rule_count < 16) {
        /* Record this failure at furthest position */
        for (int i = 0; i < ctx->failed_rule_count; i++) {
            if (strcmp(ctx->failed_rules[i], rule) == 0) return;
        }
        ctx->failed_rules[ctx->failed_rule_count++] = rule;
    }
}

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
    sysml2_debug_hook((auxil), (event), (rule), (pos))

#define ANSI_BOLD    "\x1b[1m"
#define ANSI_RED     "\x1b[31m"
#define ANSI_GREEN   "\x1b[32m"
#define ANSI_CYAN    "\x1b[36m"
#define ANSI_RESET   "\x1b[0m"

/* Rule-to-message mapping for better error diagnostics */
typedef struct {
    const char *rule;
    const char *expectation;
    const char *help;
} SysmlExpectation;

static const SysmlExpectation expectations[] = {
    /* Terminals */
    {"SEMICOLON", "';'", NULL},
    {"LBRACE", "'{'", NULL},
    {"RBRACE", "'}'", NULL},
    {"LPAREN", "'('", NULL},
    {"RPAREN", "')'", NULL},
    {"LBRACKET", "'['", NULL},
    {"RBRACKET", "']'", NULL},
    {"COLON", "':'", NULL},
    {"EQ", "'='", NULL},
    {"COMMA", "','", NULL},
    {"DOT", "'.'", NULL},
    {"DOTDOT", "'..'", NULL},
    {"ARROW", "'->'", NULL},
    {"COLONGT", "':>'", NULL},
    {"COLONGTGT", "':>>'", NULL},

    /* Names and identifiers */
    {"NAME", "identifier", NULL},
    {"BasicName", "identifier", NULL},
    {"QualifiedName", "qualified name", NULL},
    {"Identification", "name", NULL},

    /* Expressions */
    {"OwnedExpression", "expression", NULL},
    {"PrimaryExpression", "expression", NULL},
    {"LiteralExpression", "literal value", NULL},
    {"MultiplicityBounds", "multiplicity value",
     "use [1], [0..1], [*], or [1..*]"},

    /* Declarations */
    {"UsageDeclaration", "declaration", NULL},
    {"TypedBy", "type", "use ':' followed by a type name"},
    {"FeatureValue", "value", "use '=' followed by an expression"},

    /* Keywords - common ones users might mis-type or forget */
    {"KW_PACKAGE", "'package'", NULL},
    {"KW_PART", "'part'", NULL},
    {"KW_DEF", "'def'", NULL},
    {"KW_IMPORT", "'import'", NULL},
    {"KW_ACTION", "'action'", NULL},
    {"KW_ITEM", "'item'", NULL},
    {"KW_ATTRIBUTE", "'attribute'", NULL},
    {"KW_PORT", "'port'", NULL},
    {"KW_CONNECTION", "'connection'", NULL},
    {"KW_FLOW", "'flow'", NULL},
    {"KW_STATE", "'state'", NULL},
    {"KW_CONSTRAINT", "'constraint'", NULL},
    {"KW_REQUIREMENT", "'requirement'", NULL},
    {"KW_CALC", "'calc'", NULL},
    {"KW_CASE", "'case'", NULL},
    {"KW_IF", "'if'", NULL},
    {"KW_THEN", "'then'", NULL},
    {"KW_ELSE", "'else'", NULL},
    {"KW_TO", "'to'", NULL},
    {"KW_FROM", "'from'", NULL},
    {"KW_FOR", "'for'", NULL},

    /* Body elements */
    {"PackageBodyElement", "package member", NULL},
    {"DefinitionBodyItem", "definition member", NULL},
    {"UsageBodyItem", "usage member", NULL},
    {"ActionBodyItem", "action body member", NULL},

    /* Definitions and usages */
    {"DefinitionElement", "definition", NULL},
    {"UsageElement", "usage", NULL},

    {NULL, NULL, NULL}
};

static const SysmlExpectation *sysml2_lookup_expectation(const char *rule) {
    for (int i = 0; expectations[i].rule; i++) {
        if (strcmp(expectations[i].rule, rule) == 0) {
            return &expectations[i];
        }
    }
    return NULL;
}

/* Compute line and column from position */
static void sysml2_pos_to_line_col(SysmlParserContext *ctx, size_t pos,
                                   int *out_line, int *out_col) {
    int line = 1;
    int col = 1;
    for (size_t i = 0; i < pos && i < ctx->input_len; i++) {
        if (ctx->input[i] == '\n') {
            line++;
            col = 1;
        } else {
            col++;
        }
    }
    *out_line = line;
    *out_col = col;
}

static inline void sysml2_error(SysmlParserContext *ctx) {
    ctx->error_count++;

    /* Use furthest position for error location if available */
    int err_line, err_col;
    if (ctx->furthest_pos > 0 && ctx->failed_rule_count > 0) {
        sysml2_pos_to_line_col(ctx, ctx->furthest_pos, &err_line, &err_col);
    } else {
        err_line = ctx->line;
        err_col = ctx->col;
    }

    /* Build expectation message from failed rules */
    char expected[256] = "";
    const char *help = NULL;
    int count = 0;

    for (int i = 0; i < ctx->failed_rule_count && count < 3; i++) {
        const SysmlExpectation *exp = sysml2_lookup_expectation(ctx->failed_rules[i]);
        if (!exp) continue;

        if (count > 0) {
            if (count == 1 && ctx->failed_rule_count <= 2) {
                strcat(expected, " or ");
            } else {
                strcat(expected, ", ");
            }
        }
        strcat(expected, exp->expectation);
        if (!help && exp->help) help = exp->help;
        count++;
    }

    /* Find the source line for display */
    const char *line_start = ctx->input;
    int cur_line = 1;
    while (cur_line < err_line && *line_start) {
        if (*line_start == '\n') cur_line++;
        line_start++;
    }
    const char *line_end = line_start;
    while (*line_end && *line_end != '\n') line_end++;

    /* Print error header with specific expectation if available */
    fprintf(stderr, ANSI_BOLD "%s:%d:%d: " ANSI_RED "error: " ANSI_RESET ANSI_BOLD,
            ctx->filename, err_line, err_col);

    if (count > 0) {
        fprintf(stderr, "expected %s" ANSI_RESET "\n", expected);
    } else {
        fprintf(stderr, "syntax error" ANSI_RESET "\n");
    }

    /* Print source line context */
    fprintf(stderr, " %5d | %.*s\n", err_line, (int)(line_end - line_start), line_start);
    fprintf(stderr, "       | " ANSI_GREEN);
    for (int i = 1; i < err_col; i++) {
        char c = (i <= (int)(line_end - line_start)) ? line_start[i-1] : ' ';
        fprintf(stderr, "%c", (c == '\t') ? '\t' : ' ');
    }
    fprintf(stderr, "^" ANSI_RESET "\n");

    /* Print help text if available */
    if (help) {
        fprintf(stderr, "       = " ANSI_CYAN "help: " ANSI_RESET "%s\n", help);
    }
}
}

%source {
#include "sysml2/ast_builder.h"

/* Forward declarations for trivia capture functions (use size_t offsets) */
void sysml2_capture_line_comment(SysmlParserContext *ctx, size_t start_offset, size_t end_offset);
void sysml2_capture_block_comment(SysmlParserContext *ctx, size_t start_offset, size_t end_offset);
void sysml2_capture_blank_lines(SysmlParserContext *ctx, size_t start_offset, size_t end_offset);

/* Helper: check if character is a type/specialization marker */
static int sysml2_is_marker(char c, char next) {
    if (c == '[' || c == '=' || c == '{' || c == ';') return 1;
    if (c == ':' && next != ':') return 1;  /* : but not :: */
    return 0;
}

/* Helper: extract just the name portion from captured text (stops at type markers) */
static const char *sysml2_extract_name(SysmlParserContext *ctx, const char *text, size_t len) {
    if (!ctx->build_ctx || !text || len == 0) return NULL;
    /* Skip leading whitespace */
    while (len > 0 && (*text == ' ' || *text == '\t' || *text == '\n' || *text == '\r')) { text++; len--; }
    if (len == 0) return NULL;

    /* Find end of name (stop at type markers) */
    size_t name_end = 0;
    int in_quote = 0;
    for (size_t i = 0; i < len; i++) {
        if (text[i] == '\'') in_quote = !in_quote;
        if (!in_quote && sysml2_is_marker(text[i], (i + 1 < len) ? text[i + 1] : 0)) {
            break;
        }
        name_end = i + 1;
    }
    if (name_end == 0) return NULL;

    /* Trim trailing whitespace from name */
    while (name_end > 0 && (text[name_end-1] == ' ' || text[name_end-1] == '\t' ||
           text[name_end-1] == '\n' || text[name_end-1] == '\r')) name_end--;
    if (name_end == 0) return NULL;

    /* Handle quoted name: 'name' */
    if (text[0] == '\'' && name_end > 2 && text[name_end-1] == '\'') {
        return sysml2_intern_n(ctx->build_ctx->intern, text + 1, name_end - 2);
    }
    /* Handle short name: <name> name */
    if (text[0] == '<') {
        size_t i = 1;
        while (i < name_end && text[i] != '>') i++;
        if (i < name_end) {
            i++;
            while (i < name_end && (text[i] == ' ' || text[i] == '\t')) i++;
            if (i < name_end) {
                /* There's a name after the short name */
                size_t nlen = name_end - i;
                while (nlen > 0 && (text[i + nlen - 1] == ' ' || text[i + nlen - 1] == '\t')) nlen--;
                if (text[i] == '\'' && nlen > 2 && text[i + nlen - 1] == '\'') {
                    return sysml2_intern_n(ctx->build_ctx->intern, text + i + 1, nlen - 2);
                }
                return sysml2_intern_n(ctx->build_ctx->intern, text + i, nlen);
            }
            /* Just short name, extract content */
            const char *start = text + 1;
            size_t nlen = i - 2;  /* Skip < and > */
            while (nlen > 0 && (*start == ' ' || *start == '\t')) { start++; nlen--; }
            while (nlen > 0 && (start[nlen-1] == ' ' || start[nlen-1] == '\t')) nlen--;
            if (start[0] == '\'' && nlen > 2 && start[nlen-1] == '\'') {
                return sysml2_intern_n(ctx->build_ctx->intern, start + 1, nlen - 2);
            }
            return nlen > 0 ? sysml2_intern_n(ctx->build_ctx->intern, start, nlen) : NULL;
        }
    }
    return sysml2_intern_n(ctx->build_ctx->intern, text, name_end);
}

/* Operator kind for type relationships */
typedef enum {
    SYSML_OP_NONE = 0,
    SYSML_OP_TYPED_BY,      /* : */
    SYSML_OP_SPECIALIZES,   /* :> */
    SYSML_OP_REDEFINES,     /* :>> */
    SYSML_OP_REFERENCES,    /* ::> */
} SysmlOperatorKind;

/* Result of extracting a type reference with its operator */
typedef struct {
    SysmlOperatorKind op;
    const char *ref;
} SysmlTypeRefResult;

/* Helper: extract next type reference from captured text at position i, returning operator and reference */
static SysmlTypeRefResult sysml2_extract_next_type_ref(SysmlParserContext *ctx, const char *text, size_t len, size_t *pos) {
    SysmlTypeRefResult result = { SYSML_OP_NONE, NULL };
    if (!ctx->build_ctx || !text || len == 0) return result;

    size_t i = *pos;
    int in_quote = 0;

    while (i < len) {
        if (text[i] == '\'') in_quote = !in_quote;
        if (!in_quote && text[i] == ':') {
            SysmlOperatorKind op = SYSML_OP_NONE;
            size_t op_end = i;

            /* Determine operator type */
            if (i + 2 < len && text[i + 1] == ':' && text[i + 2] == '>') {
                /* ::> - references */
                op = SYSML_OP_REFERENCES;
                op_end = i + 3;
            } else if (i + 1 < len && text[i + 1] == '>') {
                if (i + 2 < len && text[i + 2] == '>') {
                    /* :>> - redefines */
                    op = SYSML_OP_REDEFINES;
                    op_end = i + 3;
                } else {
                    /* :> - specializes */
                    op = SYSML_OP_SPECIALIZES;
                    op_end = i + 2;
                }
            } else if (i + 1 < len && text[i + 1] == ':') {
                /* :: - qualified name separator, skip both */
                i += 2;
                continue;
            } else {
                /* : - typed by */
                op = SYSML_OP_TYPED_BY;
                op_end = i + 1;
            }

            /* Skip whitespace and optional ~ after operator */
            i = op_end;
            while (i < len && (text[i] == ' ' || text[i] == '\t' || text[i] == '~')) i++;
            if (i >= len) {
                *pos = i;
                return result;
            }

            /* Find end of type name (stop at comma, [, =, {, ;, another operator) */
            size_t ref_start = i;
            size_t ref_end = i;
            while (i < len) {
                if (text[i] == ',' || text[i] == '[' || text[i] == '=' ||
                    text[i] == '{' || text[i] == ';') {
                    break;
                }
                if (text[i] == ':') {
                    if (i + 2 < len && text[i + 1] == ':' && text[i + 2] == '>') {
                        break;  /* ::> */
                    }
                    if (i + 1 < len && text[i + 1] == '>') {
                        break;  /* :> or :>> */
                    }
                    if (i + 1 < len && text[i + 1] == ':') {
                        /* :: in qualified name, keep going */
                        i += 2;
                        ref_end = i;
                        continue;
                    }
                    break;  /* Another : */
                }
                ref_end = i + 1;
                i++;
            }

            /* Trim trailing whitespace */
            while (ref_end > ref_start && (text[ref_end-1] == ' ' || text[ref_end-1] == '\t' ||
                   text[ref_end-1] == '\n' || text[ref_end-1] == '\r')) ref_end--;

            if (ref_end > ref_start) {
                result.op = op;
                result.ref = sysml2_intern_n(ctx->build_ctx->intern, text + ref_start, ref_end - ref_start);
            }
            *pos = i;
            return result;
        }
        i++;
    }
    *pos = i;
    return result;
}

/* Helper: extract all type references from captured text */
static void sysml2_extract_all_type_refs(SysmlParserContext *ctx, SysmlNode *node, const char *text, size_t len) {
    if (!ctx->build_ctx || !node || !text || len == 0) return;

    size_t pos = 0;
    while (pos < len) {
        SysmlTypeRefResult result = sysml2_extract_next_type_ref(ctx, text, len, &pos);
        if (result.op == SYSML_OP_NONE || !result.ref) break;

        switch (result.op) {
            case SYSML_OP_TYPED_BY:
                sysml2_build_add_typed_by(ctx->build_ctx, node, result.ref);
                break;
            case SYSML_OP_SPECIALIZES:
                sysml2_build_add_specializes(ctx->build_ctx, node, result.ref);
                break;
            case SYSML_OP_REDEFINES:
                sysml2_build_add_redefines(ctx->build_ctx, node, result.ref);
                break;
            case SYSML_OP_REFERENCES:
                sysml2_build_add_references(ctx->build_ctx, node, result.ref);
                break;
            default:
                break;
        }
    }
}

/* Build node, add to model, push scope */
static void sysml2_build_push(SysmlParserContext *ctx, SysmlNodeKind kind, const char *text, size_t len) {
    if (!ctx->build_ctx) return;
    const char *name = sysml2_extract_name(ctx, text, len);
    SysmlNode *node = sysml2_build_node(ctx->build_ctx, kind, name);
    if (node) {
        /* Extract all type references with correct operator types */
        sysml2_extract_all_type_refs(ctx, node, text, len);
        sysml2_build_add_element(ctx->build_ctx, node);
        sysml2_build_push_scope(ctx->build_ctx, node->id);
    }
}

/* Pop scope */
static void sysml2_pop(SysmlParserContext *ctx) {
    if (ctx->build_ctx) sysml2_build_pop_scope(ctx->build_ctx);
}

/* Build import and add to model */
static void sysml2_build_import(SysmlParserContext *ctx, const char *text, size_t len) {
    if (!ctx->build_ctx || !text || len == 0) return;

    /* Skip leading whitespace */
    while (len > 0 && (*text == ' ' || *text == '\t' || *text == '\n' || *text == '\r')) { text++; len--; }
    if (len == 0) return;

    /* Trim trailing whitespace */
    while (len > 0 && (text[len-1] == ' ' || text[len-1] == '\t' || text[len-1] == '\n' || text[len-1] == '\r')) len--;
    if (len == 0) return;

    /* Determine import kind based on suffix patterns */
    SysmlNodeKind kind = SYSML_KIND_IMPORT;
    size_t target_len = len;

    /* Check for ::** (recursive) first */
    if (len >= 4 && text[len-4] == ':' && text[len-3] == ':' && text[len-2] == '*' && text[len-1] == '*') {
        kind = SYSML_KIND_IMPORT_RECURSIVE;
        target_len = len - 4;
    }
    /* Check for ::* (namespace) */
    else if (len >= 3 && text[len-3] == ':' && text[len-2] == ':' && text[len-1] == '*') {
        kind = SYSML_KIND_IMPORT_ALL;
        target_len = len - 3;
    }

    /* Trim trailing whitespace from target */
    while (target_len > 0 && (text[target_len-1] == ' ' || text[target_len-1] == '\t')) target_len--;
    if (target_len == 0) return;

    /* Intern the target */
    const char *target = sysml2_intern_n(ctx->build_ctx->intern, text, target_len);
    if (target) {
        sysml2_build_add_import(ctx->build_ctx, kind, target);
    }
}
}

%auxil "SysmlParserContext *"
%value "void *"

# Entry point - parse entire file
File <- _ (Package / LibraryPackage / PackageBodyElement)* EOF

# Whitespace and Comments (trivia capture for pretty printing)
_   <- TriviaCapture*

TriviaCapture
    <- LineCommentCapture
     / DocBlockCommentCapture
     / BlankLineCapture
     / WS

LineCommentCapture <- < '//' (![\n\r] .)* > { sysml2_capture_line_comment(auxil, $0s, $0e); }
DocBlockCommentCapture <- < '/**' (!'*/' .)* '*/' > { sysml2_capture_block_comment(auxil, $0s, $0e); }
BlankLineCapture <- < [\n\r][\n\r]+ > { sysml2_capture_blank_lines(auxil, $0s, $0e); }

WS  <- [ \t\n\r\f]+
LineComment <- '//' (![\n\r] .)*
BlockComment <- '/*' (!'*/' .)* '*/'
RegularComment <- '/*' (!'*/' .)* '*/' _
EOF <- !.

# Lexical
NAME <- BasicName / UnrestrictedName
BasicName <- [a-zA-Z_] [a-zA-Z0-9_]* _
UnrestrictedName <- '\'' (UnrestrictedNameChar / EscapeSequence)* '\'' _
UnrestrictedNameChar <- [^'\\]
EscapeSequence <- '\\' [fnrtv'\\]
StringChar <- [^"\\]
IdentCont <- [a-zA-Z0-9_]
DECIMAL_VALUE <- [0-9]+ _
REAL_VALUE <- [0-9]+ '.' !'.' [0-9]* ([eE] [+-]? [0-9]+)? _
           /  '.' [0-9]+ ([eE] [+-]? [0-9]+)? _
           /  [0-9]+ [eE] [+-]? [0-9]+ _
STRING_VALUE <- '"' (StringChar / EscapeSequence)* '"' _

QualifiedName <- ('::' _)? NameSegment ('::' _ NameSegment)*
NameSegment <- NAME / UnrestrictedName

# Keywords
KW_ABOUT       <- 'about'       !IdentCont _
KW_ABSTRACT    <- 'abstract'    !IdentCont _
KW_ACCEPT      <- 'accept'      !IdentCont _
KW_ACTION      <- 'action'      !IdentCont _
KW_ACTOR       <- 'actor'       !IdentCont _
KW_AFTER       <- 'after'       !IdentCont _
KW_ALIAS       <- 'alias'       !IdentCont _
KW_ALL         <- 'all'         !IdentCont _
KW_ALLOCATE    <- 'allocate'    !IdentCont _
KW_ALLOCATION  <- 'allocation'  !IdentCont _
KW_ANALYSIS    <- 'analysis'    !IdentCont _
KW_AND         <- 'and'         !IdentCont _
KW_AS          <- 'as'          !IdentCont _
KW_ASSERT      <- 'assert'      !IdentCont _
KW_ASSIGN      <- 'assign'      !IdentCont _
KW_ASSUME      <- 'assume'      !IdentCont _
KW_AT          <- 'at'          !IdentCont _
KW_ATTRIBUTE   <- 'attribute'   !IdentCont _
KW_BIND        <- 'bind'        !IdentCont _
KW_BINDING     <- 'binding'     !IdentCont _
KW_BY          <- 'by'          !IdentCont _
KW_CALC        <- 'calc'        !IdentCont _
KW_CASE        <- 'case'        !IdentCont _
KW_COMMENT     <- 'comment'     !IdentCont _
KW_CONCERN     <- 'concern'     !IdentCont _
KW_CONNECT     <- 'connect'     !IdentCont _
KW_CONNECTION  <- 'connection'  !IdentCont _
KW_DATATYPE    <- 'datatype'    !IdentCont _
KW_CONSTRAINT  <- 'constraint'  !IdentCont _
KW_CONSTANT    <- 'constant'    !IdentCont _
KW_CROSSES     <- 'crosses'     !IdentCont _
KW_DECIDE      <- 'decide'      !IdentCont _
KW_DEF         <- 'def'         !IdentCont _
KW_DEFAULT     <- 'default'     !IdentCont _
KW_DEFINED     <- 'defined'     !IdentCont _
KW_DEPENDENCY  <- 'dependency'  !IdentCont _
KW_DERIVED     <- 'derived'     !IdentCont _
KW_DO          <- 'do'          !IdentCont _
KW_DOC         <- 'doc'         !IdentCont _
KW_ELSE        <- 'else'        !IdentCont _
KW_END         <- 'end'         !IdentCont _
KW_ENTRY       <- 'entry'       !IdentCont _
KW_ENUM        <- 'enum'        !IdentCont _
KW_EVENT       <- 'event'       !IdentCont _
KW_EXHIBIT     <- 'exhibit'     !IdentCont _
KW_EXIT        <- 'exit'        !IdentCont _
KW_EXPOSE      <- 'expose'      !IdentCont _
KW_FALSE       <- 'false'       !IdentCont _
KW_FILTER      <- 'filter'      !IdentCont _
KW_FIRST       <- 'first'       !IdentCont _
KW_FLOW        <- 'flow'        !IdentCont _
KW_FOR         <- 'for'         !IdentCont _
KW_FORK        <- 'fork'        !IdentCont _
KW_FRAME       <- 'frame'       !IdentCont _
KW_FROM        <- 'from'        !IdentCont _
KW_HASTYPE     <- 'hastype'     !IdentCont _
KW_IF          <- 'if'          !IdentCont _
KW_IMPLIES     <- 'implies'     !IdentCont _
KW_IMPORT      <- 'import'      !IdentCont _
KW_IN          <- 'in'          !IdentCont _
KW_INCLUDE     <- 'include'     !IdentCont _
KW_INDIVIDUAL  <- 'individual'  !IdentCont _
KW_INOUT       <- 'inout'       !IdentCont _
KW_INTERFACE   <- 'interface'   !IdentCont _
KW_ISTYPE      <- 'istype'      !IdentCont _
KW_ITEM        <- 'item'        !IdentCont _
KW_JOIN        <- 'join'        !IdentCont _
KW_LANGUAGE    <- 'language'    !IdentCont _
KW_LIBRARY     <- 'library'     !IdentCont _
KW_LOCALE      <- 'locale'      !IdentCont _
KW_LOOP        <- 'loop'        !IdentCont _
KW_MEMBER      <- 'member'      !IdentCont _
KW_MERGE       <- 'merge'       !IdentCont _
KW_MESSAGE     <- 'message'     !IdentCont _
KW_META        <- 'meta'        !IdentCont _
KW_METADATA    <- 'metadata'    !IdentCont _
KW_NEW         <- 'new'         !IdentCont _
KW_NONUNIQUE   <- 'nonunique'   !IdentCont _
KW_NOT         <- 'not'         !IdentCont _
KW_NULL        <- 'null'        !IdentCont _
KW_OBJECTIVE   <- 'objective'   !IdentCont _
KW_OCCURRENCE  <- 'occurrence'  !IdentCont _
KW_OF          <- 'of'          !IdentCont _
KW_OR          <- 'or'          !IdentCont _
KW_ORDERED     <- 'ordered'     !IdentCont _
KW_OUT         <- 'out'         !IdentCont _
KW_PACKAGE     <- 'package'     !IdentCont _
KW_PARALLEL    <- 'parallel'    !IdentCont _
KW_PART        <- 'part'        !IdentCont _
KW_PERFORM     <- 'perform'     !IdentCont _
KW_PORT        <- 'port'        !IdentCont _
KW_PRIVATE     <- 'private'     !IdentCont _
KW_PROTECTED   <- 'protected'   !IdentCont _
KW_PUBLIC      <- 'public'      !IdentCont _
KW_READONLY    <- 'readonly'    !IdentCont _
KW_REDEFINES   <- 'redefines'   !IdentCont _
KW_REF         <- 'ref'         !IdentCont _
KW_REFERENCES  <- 'references'  !IdentCont _
KW_RENDER      <- 'render'      !IdentCont _
KW_RENDERING   <- 'rendering'   !IdentCont _
KW_REP         <- 'rep'         !IdentCont _
KW_REQUIRE     <- 'require'     !IdentCont _
KW_REQUIREMENT <- 'requirement' !IdentCont _
KW_RETURN      <- 'return'      !IdentCont _
KW_SATISFY     <- 'satisfy'     !IdentCont _
KW_SEND        <- 'send'        !IdentCont _
KW_SNAPSHOT    <- 'snapshot'    !IdentCont _
KW_SPECIALIZES <- 'specializes' !IdentCont _
KW_STAKEHOLDER <- 'stakeholder' !IdentCont _
KW_STANDARD    <- 'standard'    !IdentCont _
KW_STATE       <- 'state'       !IdentCont _
KW_SUBJECT     <- 'subject'     !IdentCont _
KW_SUBSETS     <- 'subsets'     !IdentCont _
KW_SUCCESSION  <- 'succession'  !IdentCont _
KW_TERMINATE   <- 'terminate'   !IdentCont _
KW_THEN        <- 'then'        !IdentCont _
KW_TIMESLICE   <- 'timeslice'   !IdentCont _
KW_TO          <- 'to'          !IdentCont _
KW_TRANSITION  <- 'transition'  !IdentCont _
KW_TRUE        <- 'true'        !IdentCont _
KW_UNTIL       <- 'until'       !IdentCont _
KW_USE         <- 'use'         !IdentCont _
KW_VAR         <- 'var'         !IdentCont _
KW_VARIANT     <- 'variant'     !IdentCont _
KW_VARIATION   <- 'variation'   !IdentCont _
KW_VERIFICATION <- 'verification' !IdentCont _
KW_VERIFY      <- 'verify'      !IdentCont _
KW_VIA         <- 'via'         !IdentCont _
KW_VIEW        <- 'view'        !IdentCont _
KW_VIEWPOINT   <- 'viewpoint'   !IdentCont _
KW_WHEN        <- 'when'        !IdentCont _
KW_WHILE       <- 'while'       !IdentCont _
KW_XOR         <- 'xor'         !IdentCont _

# KerML Keywords
KW_ASSOC       <- 'assoc'       !IdentCont _
KW_BEHAVIOR    <- 'behavior'    !IdentCont _
KW_BOOL        <- 'bool'        !IdentCont _
KW_CHAINS      <- 'chains'      !IdentCont _
KW_CLASS       <- 'class'       !IdentCont _
KW_CLASSIFIER  <- 'classifier'  !IdentCont _
KW_COMPOSITE   <- 'composite'   !IdentCont _
KW_CONJUGATE   <- 'conjugate'   !IdentCont _
KW_CONJUGATES  <- 'conjugates'  !IdentCont _
KW_CONJUGATION <- 'conjugation' !IdentCont _
KW_CONNECTOR   <- 'connector'   !IdentCont _
KW_DISJOINT    <- 'disjoint'    !IdentCont _
KW_DISJOINING  <- 'disjoining'  !IdentCont _
KW_EXPR        <- 'expr'        !IdentCont _
KW_FEATURE     <- 'feature'     !IdentCont _
KW_FEATURED    <- 'featured'    !IdentCont _
KW_FEATURING   <- 'featuring'   !IdentCont _
KW_FUNCTION    <- 'function'    !IdentCont _
KW_INTERACTION <- 'interaction' !IdentCont _
KW_INV         <- 'inv'         !IdentCont _
KW_INVERSE     <- 'inverse'     !IdentCont _
KW_INVERTING   <- 'inverting'   !IdentCont _
KW_METACLASS   <- 'metaclass'   !IdentCont _
KW_MULTIPLICITY <- 'multiplicity' !IdentCont _
KW_NAMESPACE   <- 'namespace'   !IdentCont _
KW_PORTION     <- 'portion'     !IdentCont _
KW_PREDICATE   <- 'predicate'   !IdentCont _
KW_REDEFINITION <- 'redefinition' !IdentCont _
KW_SPECIALIZATION <- 'specialization' !IdentCont _
KW_STEP        <- 'step'        !IdentCont _
KW_STRUCT      <- 'struct'      !IdentCont _
KW_SUBCLASSIFIER <- 'subclassifier' !IdentCont _
KW_SUBSET      <- 'subset'      !IdentCont _
KW_SUBTYPE     <- 'subtype'     !IdentCont _
KW_TYPE        <- 'type'        !IdentCont _
KW_TYPING      <- 'typing'      !IdentCont _
KW_UNIONS      <- 'unions'      !IdentCont _
KW_INTERSECTS  <- 'intersects'  !IdentCont _
KW_DIFFERENCES <- 'differences' !IdentCont _

# Operators
SEMICOLON <- ';' _
COMMA <- ',' _
LBRACE <- '{' _
RBRACE <- '}' _
LPAREN <- '(' _
RPAREN <- ')' _
LBRACKET <- '[' _
RBRACKET <- ']' _
LANGLE <- '<' ![=] _
RANGLE <- '>' ![=] _
DOT <- '.' ![.?] _
DOTDOT <- '..' _
DOTQ <- '.?' _
HASH <- '#' _
AT <- '@' _
COLON <- ':' ![>:=] _
COLONCOLON <- '::' ![>*] _
COLONCOLON_STAR <- '::*' !'*' _    # For import wildcards like Pkg::* (not Pkg::**)
COLONCOLON_STARSTAR <- '::**' _    # For recursive imports like Pkg::*::**
COLONGT <- ':>' ![>] _
COLONGTGT <- ':>>' _
COLONCOLONGT <- '::>' _
COLONEQ <- ':=' _
EQ <- '=' ![=] _
EQEQ <- '==' ![=] _
EQEQEQ <- '===' _
BANGEQ <- '!=' ![=] _
BANGEQEQ <- '!==' _
BANG <- '!' ![=] _
PLUS <- '+' _
MINUS <- '-' ![>] _
STAR <- '*' ![*] _
STARSTAR <- '**' _
SLASH <- '/' _
PERCENT <- '%' _
CARET <- '^' _
LT <- '<' ![=] _
GT <- '>' ![=] _
LE <- '<=' _
GE <- '>=' _
AMP <- '&' _
PIPE <- '|' _
TILDE <- '~' _
QMARK <- '?' ![?] _
QMARKQMARK <- '??' _
ARROW <- '->' _

# Relationships
SPECIALIZES <- COLONGT / KW_SPECIALIZES
SUBSETS <- COLONGT / KW_SUBSETS
REDEFINES <- COLONGTGT / KW_REDEFINES
REFERENCES <- COLONCOLONGT / KW_REFERENCES
TYPED_BY <- COLON / (KW_DEFINED KW_BY)

# Identification
Identification <- ShortName? IdentificationName?
IdentificationName <- !SpecializationKeyword !KW_ABOUT !KW_LOCALE !KW_FROM !KW_TO !KW_OF !KW_VIA NAME
SpecializationKeyword <- ('redefines' / 'subsets' / 'references' / 'specializes' / 'defined') !IdentCont
ShortName <- LANGLE (NAME / STRING_VALUE) RANGLE

# Visibility
VisibilityIndicator <- KW_PUBLIC / KW_PRIVATE / KW_PROTECTED
MemberPrefix <- PrefixMetadata* VisibilityIndicator?

# Relationship Body
RelationshipBody <- SEMICOLON / LBRACE AnnotatingElement* RBRACE

# Package Body Elements
PackageBodyElement <- _ MemberPrefix (DefinitionElement / KerMLFeatureElement / AssertConstraintUsage / BindUsage / ShorthandFeatureMember / UsageElement / Import / Alias / FilterPackageMember / AnnotatingElement)
FilterPackageMember <- KW_FILTER OwnedExpression SEMICOLON

# Packages
Package <- PrefixMetadata* KW_PACKAGE < Identification > { sysml2_build_push(auxil, SYSML_KIND_PACKAGE, $1, $1e - $1s); } PackageBody { sysml2_pop(auxil); }
LibraryPackage <- KW_STANDARD? KW_LIBRARY PrefixMetadata* KW_PACKAGE < Identification > { sysml2_build_push(auxil, SYSML_KIND_LIBRARY_PACKAGE, $1, $1e - $1s); } PackageBody { sysml2_pop(auxil); }
PackageBody <- SEMICOLON / LBRACE PackageBodyElement* RBRACE

# Imports
Import <- KW_IMPORT KW_ALL? < ImportDeclaration > { sysml2_build_import(auxil, $1, $1e - $1s); } ImportFilter? RelationshipBody
ImportDeclaration <- NamespaceImport / MembershipImport
MembershipImport <- QualifiedName (COLONCOLON STARSTAR)?
NamespaceImport <- QualifiedName (COLONCOLON_STAR COLONCOLON_STARSTAR? / COLONCOLON_STARSTAR)
ImportFilter <- LBRACKET OwnedExpression RBRACKET

# Alias
Alias <- KW_ALIAS (ShortName NAME / ShortName / NAME) KW_FOR QualifiedName RelationshipBody

# Dependency
Dependency <- PrefixMetadata* KW_DEPENDENCY (Identification KW_FROM)? QualifiedName (COMMA QualifiedName)* KW_TO QualifiedName (COMMA QualifiedName)* RelationshipBody

# ===== KerML Type Elements =====
# KerML NonFeature Elements (type hierarchy)
KerMLDefinitionElement <- NamespaceDefinition / TypeDefinition / ClassifierDefinition
                        / ClassDefinition / StructureDefinition / MetaclassDefinition
                        / AssociationDefinition / AssociationStructureDefinition
                        / InteractionDefinition / BehaviorDefinition / FunctionDefinition
                        / PredicateDefinition / MultiplicityDefinition
                        / SpecializationRelationship / ConjugationRelationship
                        / SubclassificationRelationship / DisjoiningRelationship
                        / FeatureInvertingRelationship / FeatureTypingRelationship
                        / SubsettingRelationship / RedefinitionRelationship
                        / TypeFeaturingRelationship

# KerML Type Prefix (abstract, etc)
KerMLTypePrefix <- KW_ABSTRACT? PrefixMetadata*

# Namespace: namespace Name { ... }
NamespaceDefinition <- KerMLTypePrefix KW_NAMESPACE < Identification >
    { sysml2_build_push(auxil, SYSML_KIND_NAMESPACE, $1, $1e - $1s); }
    NamespaceBody { sysml2_pop(auxil); }
NamespaceBody <- SEMICOLON / LBRACE NamespaceBodyElement* RBRACE
NamespaceBodyElement <- MemberPrefix (KerMLDefinitionElement / KerMLFeatureElement
                                     / Import / Alias / AnnotatingElement)

# Type: [abstract] type Name :> SuperType { ... }
TypeDefinition <- KerMLTypePrefix KW_TYPE < Identification TypeDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_TYPE, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }
TypeDeclarationPart <- Multiplicity? (KerMLSpecializationPart / KerMLConjugationPart)? TypeRelationshipPart*
KerMLSpecializationPart <- SPECIALIZES QualifiedName (COMMA QualifiedName)*
KerMLConjugationPart <- CONJUGATES QualifiedName
TypeRelationshipPart <- DisjoiningPart / UnioningPart / IntersectingPart / DifferencingPart
# Support feature chains like 'disjoint x.y from z.w'
DisjoiningPart <- KW_DISJOINT KW_FROM QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)*
UnioningPart <- KW_UNIONS QualifiedName (COMMA QualifiedName)*
IntersectingPart <- KW_INTERSECTS QualifiedName (COMMA QualifiedName)*
DifferencingPart <- KW_DIFFERENCES QualifiedName (COMMA QualifiedName)*
KerMLTypeBody <- SEMICOLON / LBRACE KerMLTypeBodyElement* RBRACE
KerMLTypeBodyElement <- MemberPrefix (KerMLDefinitionElement / KerMLParameterMember / KerMLFeatureElement
                                / ShorthandNamedFeature / Import / Alias / AnnotatingElement)
# Shorthand named feature: name : Type :>> target; (feature keyword implied)
ShorthandNamedFeature <- < Identification KerMLFeatureSpecializationPart > FeatureRelationshipPart* FeatureValue? UsageBody
CONJUGATES <- TILDE / KW_CONJUGATES

# Classifier: [abstract] classifier Name :> SuperClassifier { ... }
ClassifierDefinition <- KerMLTypePrefix KW_CLASSIFIER < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_CLASSIFIER, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }
ClassifierDeclarationPart <- Multiplicity? (KerMLSpecializationPart / KerMLConjugationPart)? TypeRelationshipPart*

# Class: [abstract] class [all] Name :> SuperClass { ... }
ClassDefinition <- KerMLTypePrefix KW_CLASS KW_ALL? < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_CLASS, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }

# Structure: [abstract] struct [all] Name :> SuperStruct { ... }
StructureDefinition <- KerMLTypePrefix KW_STRUCT KW_ALL? < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_STRUCTURE, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }

# Metaclass: [abstract] metaclass Name :> SuperMeta { ... }
MetaclassDefinition <- KerMLTypePrefix KW_METACLASS < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_METACLASS, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }

# Association: [abstract] [all] assoc Name :> SuperAssoc { ... }
AssociationDefinition <- KerMLTypePrefix KW_ASSOC KW_ALL? !KW_STRUCT < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_ASSOCIATION, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }

# AssociationStructure: [abstract] assoc struct Name :> Super { ... }
AssociationStructureDefinition <- KerMLTypePrefix KW_ASSOC KW_STRUCT < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_ASSOC_STRUCT, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }

# Interaction: [abstract] interaction Name :> Super { ... }
InteractionDefinition <- KerMLTypePrefix KW_INTERACTION < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_INTERACTION, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }

# Behavior: [abstract] behavior Name :> Super { in/out/inout params... }
BehaviorDefinition <- KerMLTypePrefix KW_BEHAVIOR < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_BEHAVIOR, $1, $1e - $1s); }
    KerMLBehaviorBody { sysml2_pop(auxil); }
KerMLBehaviorBody <- SEMICOLON / LBRACE KerMLBehaviorBodyElement* RBRACE
KerMLBehaviorBodyElement <- MemberPrefix (KerMLParameterMember / KerMLDefinitionElement
                                    / KerMLFeatureElement / Import / Alias / AnnotatingElement)

# Function: [abstract] function Name :> Super { ... result }
FunctionDefinition <- KerMLTypePrefix KW_FUNCTION < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_FUNCTION, $1, $1e - $1s); }
    KerMLFunctionBody { sysml2_pop(auxil); }
KerMLFunctionBody <- SEMICOLON / LBRACE KerMLFunctionBodyElement* ResultExpression? RBRACE
KerMLFunctionBodyElement <- MemberPrefix (ReturnFeatureMember / KerMLParameterMember / KerMLDefinitionElement
                                    / KerMLFeatureElement / Import / Alias / AnnotatingElement)
ReturnFeatureMember <- KW_RETURN (FeatureDefinition / KerMLParameterMember / ReturnNamedPart / ReturnTypePart)
ReturnNamedPart <- Identification KerMLFeatureSpecializationPart? FeatureValue? UsageBody
ReturnTypePart <- TypedBy FeatureValue? UsageBody
# Parameter-style features: in/out/inout [abstract] [feature] name : Type;
KerMLParameterMember <- Direction KW_ABSTRACT? KW_FEATURE? < Identification? UsageSpecializations? > FeatureValue? UsageBody

# Predicate: [abstract] predicate Name :> Super { ... }
PredicateDefinition <- KerMLTypePrefix KW_PREDICATE < Identification ClassifierDeclarationPart? >
    { sysml2_build_push(auxil, SYSML_KIND_PREDICATE, $1, $1e - $1s); }
    KerMLFunctionBody { sysml2_pop(auxil); }

# Multiplicity: multiplicity Name [bounds] { ... } OR multiplicity Name subsets Super [bounds] { ... }
MultiplicityDefinition <- KW_MULTIPLICITY < Identification? (KW_SUBSETS QualifiedName)? Multiplicity? >
    { sysml2_build_push(auxil, SYSML_KIND_MULTIPLICITY_DEF, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }

# ===== KerML Relationship Elements =====
# Specialization: specialization [name] subtype Specific :> General;
SpecializationRelationship <- (KW_SPECIALIZATION Identification?)? KW_SUBTYPE
    QualifiedName SPECIALIZES QualifiedName RelationshipBody

# Conjugation: conjugation [name] conjugate Conjugated ~ Original;
ConjugationRelationship <- (KW_CONJUGATION Identification?)? KW_CONJUGATE
    QualifiedName CONJUGATES QualifiedName RelationshipBody

# Subclassification: specialization [name] subclassifier Sub :> Super;
SubclassificationRelationship <- (KW_SPECIALIZATION Identification?)? KW_SUBCLASSIFIER
    QualifiedName SPECIALIZES QualifiedName RelationshipBody

# Disjoining: disjoining [name] disjoint A.chain from B.chain;
DisjoiningRelationship <- (KW_DISJOINING Identification?)? KW_DISJOINT
    QualifiedName FeatureChain? KW_FROM QualifiedName FeatureChain? RelationshipBody

# FeatureInverting: inverting [name] inverse A of B;
FeatureInvertingRelationship <- (KW_INVERTING Identification?)? KW_INVERSE
    QualifiedName KW_OF QualifiedName RelationshipBody

# FeatureTyping: specialization [name] typing Feature : Type;
FeatureTypingRelationship <- (KW_SPECIALIZATION Identification?)? KW_TYPING
    QualifiedName TYPED_BY QualifiedName RelationshipBody

# Subsetting: specialization [name] subset Sub.chain :> Super.chain;
SubsettingRelationship <- (KW_SPECIALIZATION Identification?)? KW_SUBSET
    QualifiedName FeatureChain? SUBSETS QualifiedName FeatureChain? RelationshipBody

# Redefinition: specialization [name] redefinition Specific :>> General;
RedefinitionRelationship <- (KW_SPECIALIZATION Identification?)? KW_REDEFINITION
    QualifiedName REDEFINES QualifiedName RelationshipBody

# TypeFeaturing: featuring [name] of Feature by Type;
TypeFeaturingRelationship <- KW_FEATURING (Identification KW_OF)?
    QualifiedName KW_BY QualifiedName RelationshipBody

# ===== KerML Feature Elements =====
KerMLFeatureElement <- KerMLEndFeature / ImplicitFeatureDefinition / FeatureDefinition / StepDefinition / ExpressionDefinition
                     / BooleanExpressionDefinition / InvariantDefinition
                     / ConnectorDefinition / BindingConnectorDefinition
                     / SuccessionFeatureDefinition / KerMLFlowDefinition / SuccessionFlowDefinition

# Implicit feature: portion name : Type (composite/portion without 'feature' keyword)
ImplicitFeatureDefinition <- (KW_COMPOSITE / KW_PORTION) < KerMLFeatureDeclaration >
    { sysml2_build_push(auxil, SYSML_KIND_FEATURE, $1, $1e - $1s); }
    FeatureValue? KerMLTypeBody { sysml2_pop(auxil); }

# End with cross-feature: end self2 [1] feature sameThing : Anything
# Or more complex: end happensWhile [1..*] subsets X feature thatOccurrence : Type
KerMLEndFeature <- KW_END EndCrossFeature? KW_FEATURE < KerMLFeatureDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_FEATURE, $1, $1e - $1s); }
    FeatureValue? KerMLTypeBody { sysml2_pop(auxil); }
# EndCrossFeature can have name, multiplicity, and specializations before 'feature'
EndCrossFeature <- NAME Multiplicity? KerMLFeatureSpecializationPart? / Multiplicity

# KerML Feature Prefix (supports derived, var, abstract, composite/portion, readonly/constant, end)
# Official order: direction → derived → abstract → composite|portion → var|readonly|constant → end
KerMLFeaturePrefix <- Direction? KW_DERIVED? KW_ABSTRACT? (KW_COMPOSITE / KW_PORTION)?
                 (KW_VAR / KW_READONLY / KW_CONSTANT)? KW_END? PrefixMetadata*

# Feature: [direction] [abstract] [member] feature [all] Name : Type [mult] = value { ... }
FeatureDefinition <- KerMLFeaturePrefix KW_MEMBER? KW_FEATURE KW_ALL? < KerMLFeatureDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_FEATURE, $1, $1e - $1s); }
    FeatureValue? KerMLTypeBody { sysml2_pop(auxil); }
KerMLFeatureDeclaration <- Identification? KerMLFeatureSpecializationPart? FeatureRelationshipPart*
KerMLFeatureSpecializationPart <- KerMLFeatureSpecialization+
KerMLFeatureSpecialization <- TypedBy / Subsets / References / Redefines / Crosses / Multiplicity
FeatureRelationshipPart <- TypeRelationshipPart / ChainingPart / InvertingFeaturePart / TypeFeaturingPart
ChainingPart <- KW_CHAINS QualifiedName FeatureChain?
InvertingFeaturePart <- KW_INVERSE KW_OF QualifiedName FeatureChain?
TypeFeaturingPart <- KW_FEATURED KW_BY QualifiedName (COMMA QualifiedName)*

# Step: step Name : Type { ... }
StepDefinition <- KerMLFeaturePrefix KW_STEP < KerMLFeatureDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_STEP, $1, $1e - $1s); }
    FeatureValue? KerMLTypeBody { sysml2_pop(auxil); }

# Expression: expr Name : Type { ... result }
ExpressionDefinition <- KerMLFeaturePrefix KW_EXPR < KerMLFeatureDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_EXPRESSION, $1, $1e - $1s); }
    FeatureValue? KerMLFunctionBody { sysml2_pop(auxil); }

# BooleanExpression: bool Name : Type { ... }
BooleanExpressionDefinition <- KerMLFeaturePrefix KW_BOOL < KerMLFeatureDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_BOOL_EXPRESSION, $1, $1e - $1s); }
    FeatureValue? KerMLFunctionBody { sysml2_pop(auxil); }

# Invariant: inv [true|false] Name { ... }
InvariantDefinition <- KerMLFeaturePrefix KW_INV (KW_TRUE / KW_FALSE)? < KerMLFeatureDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_INVARIANT, $1, $1e - $1s); }
    FeatureValue? KerMLFunctionBody { sysml2_pop(auxil); }

# Connector: [all] connector Name from A to B { ... }
ConnectorDefinition <- KerMLFeaturePrefix KW_CONNECTOR KW_ALL? < KerMLConnectorDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_CONNECTOR, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }
KerMLConnectorDeclaration <- KerMLFeatureDeclaration? (KerMLBinaryConnectorPart / NaryConnectorPart)?
KerMLBinaryConnectorPart <- KW_FROM? ConnectorEndMember KW_TO ConnectorEndMember

# BindingConnector: binding Name of A = B { ... }
BindingConnectorDefinition <- KerMLFeaturePrefix KW_BINDING < KerMLBindingConnectorDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_BINDING_CONNECTOR, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }
# Three alternatives to handle PEG greedy matching for 'binding result = trueValue;'
# Order matters: try specific patterns before general ones
KerMLBindingConnectorDeclaration <- KerMLFeatureDeclaration KW_OF ConnectorEndMember EQ ConnectorEndMember
                                  / KW_ALL? KW_OF? ConnectorEndMember EQ ConnectorEndMember
                                  / KerMLFeatureDeclaration

# Succession: [all] succession Name first A then B { ... }
SuccessionFeatureDefinition <- KerMLFeaturePrefix KW_SUCCESSION KW_ALL? !KW_FLOW < KerMLSuccessionDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_SUCCESSION, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }
# Official grammar: 'first'? is optional (KEBNF line 850)
# SuccessionConnectorEnd has optional multiplicity like [1] before the name
# Order matters: try specific patterns before general ones
KerMLSuccessionDeclaration <- KerMLFeatureDeclaration? KW_FIRST SuccessionConnectorEnd KW_THEN SuccessionConnectorEnd
                            / SuccessionConnectorEnd KW_THEN SuccessionConnectorEnd
                            / KerMLFeatureDeclaration
SuccessionConnectorEnd <- Multiplicity? ConnectorEndMember

# Flow: flow Name of Payload from A to B { ... }
KerMLFlowDefinition <- KerMLFeaturePrefix KW_FLOW < KerMLFlowDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_KERML_FLOW, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }
KerMLFlowDeclaration <- KerMLFeatureDeclaration? (KW_OF QualifiedName)?
                   (KW_FROM ConnectorEndMember KW_TO ConnectorEndMember)?

# SuccessionFlow: succession flow Name of Payload from A to B { ... }
SuccessionFlowDefinition <- KerMLFeaturePrefix KW_SUCCESSION KW_FLOW < KerMLFlowDeclaration? >
    { sysml2_build_push(auxil, SYSML_KIND_SUCCESSION_FLOW, $1, $1e - $1s); }
    KerMLTypeBody { sysml2_pop(auxil); }

# Metadata
PrefixMetadata <- HASH QualifiedName
MetadataUsage <- AT QualifiedName MetadataUsageTail / AT? KW_METADATA Identification? (COLON QualifiedName)? (KW_ABOUT QualifiedName (COMMA QualifiedName)*)? MetadataBody
MetadataUsageTail <- (KW_ABOUT QualifiedName (COMMA QualifiedName)*)? (MetadataBody / SEMICOLON)
MetadataBody <- SEMICOLON / LBRACE MetadataBodyElement* RBRACE
MetadataBodyElement <- ShorthandFeatureMember / AnnotatingElement / MetadataBodyFeature
MetadataBodyFeature <- MemberPrefix KW_REF? NAME FeatureValue? (SEMICOLON / MetadataBody)

# Annotating Elements
AnnotatingElement <- Comment / Documentation / TextualRepresentation / MetadataUsage
Comment <- (KW_COMMENT Identification (KW_ABOUT QualifiedName (COMMA QualifiedName)*)?)? (KW_LOCALE STRING_VALUE)? RegularComment
Documentation <- KW_DOC Identification (KW_LOCALE STRING_VALUE)? RegularComment
TextualRepresentation <- (KW_REP Identification)? KW_LANGUAGE STRING_VALUE RegularComment

# Definitions
DefinitionElement <- KerMLDefinitionElement / DatatypeDefinition / AttributeDefinition / EnumerationDefinition / ItemDefinition / PartDefinition / ConnectionDefinition / FlowDefinition / InterfaceDefinition / PortDefinition / AllocationDefinition / ActionDefinition / StateDefinition / ConstraintDefinition / RequirementDefinition / ConcernDefinition / CalcDefinition / CaseDefinition / AnalysisDefinition / VerificationDefinition / UseCaseDefinition / ViewDefinition / ViewpointDefinition / RenderingDefinition / MetadataDefinition / OccurrenceDefinition / Package / LibraryPackage / Dependency

# Definition Prefixes
DefinitionPrefix <- PrefixMetadata / KW_ABSTRACT / KW_VARIATION / BasicDefinitionPrefix
BasicDefinitionPrefix <- KW_INDIVIDUAL / LifeclassPrefix
LifeclassPrefix <- KW_SNAPSHOT / KW_TIMESLICE
UsagePrefix <- PrefixMetadata / KW_ABSTRACT / KW_VARIATION / KW_VARIANT / BasicUsagePrefix
BasicUsagePrefix <- Direction? RefPrefix? KW_INDIVIDUAL? / KW_INDIVIDUAL
RefPrefix <- KW_REF / KW_READONLY / KW_DERIVED / KW_CONSTANT / KW_END

# Definitions
AttributeDefinition <- DefinitionPrefix* KW_ATTRIBUTE KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_ATTRIBUTE_DEF, $1, $1e - $1s); } DefinitionBody { sysml2_pop(auxil); }
EnumerationDefinition <- DefinitionPrefix* KW_ENUM KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_ENUMERATION_DEF, $1, $1e - $1s); } EnumerationBody { sysml2_pop(auxil); }
DatatypeDefinition <- DefinitionPrefix* KW_DATATYPE < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_DATATYPE, $1, $1e - $1s); } DefinitionBody { sysml2_pop(auxil); }
EnumerationBody <- SEMICOLON / LBRACE (EnumeratedValue / AnnotatingElement)* RBRACE
EnumeratedValue <- _ MemberPrefix EnumeratedValueVariant
EnumeratedValueVariant <- KW_ENUM? UsageDeclaration UsageBody / KW_VARIANT UsageElement
OccurrenceDefinition <- DefinitionPrefix* KW_OCCURRENCE KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_OCCURRENCE_DEF, $1, $1e - $1s); } OccurrenceDefinitionBody { sysml2_pop(auxil); }
                      / DefinitionPrefix* KW_DEF Identification DefinitionSpecializations? OccurrenceDefinitionBody
OccurrenceDefinitionBody <- SEMICOLON / LBRACE OccurrenceDefinitionMember* RBRACE
# ThenMessageUsage for 'then message x of T' syntax in occurrences
ThenMessageUsage <- KW_THEN MessageUsage
OccurrenceDefinitionMember <- MemberPrefix (OccurrenceDefinitionElement / PortionUsage / ThenMessageUsage / MessageUsage / BindUsage / EventOccurrenceUsage / EventUsage / ShorthandFeatureMember / SuccessionMember / StructureUsageElement / OccurrenceUsage / Import / Alias / AnnotatingElement)
OccurrenceDefinitionElement <- DefinitionElement / BehaviorUsageElement
ItemDefinition <- DefinitionPrefix* KW_ITEM KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_ITEM_DEF, $1, $1e - $1s); } DefinitionBody { sysml2_pop(auxil); }
PartDefinition <- DefinitionPrefix* KW_PART KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_PART_DEF, $1, $1e - $1s); } DefinitionBody { sysml2_pop(auxil); }
ConnectionDefinition <- DefinitionPrefix* KW_CONNECTION KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_CONNECTION_DEF, $1, $1e - $1s); } DefinitionBody { sysml2_pop(auxil); }
FlowDefinition <- DefinitionPrefix* KW_FLOW KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_FLOW_DEF, $1, $1e - $1s); } DefinitionBody { sysml2_pop(auxil); }
InterfaceDefinition <- DefinitionPrefix* KW_INTERFACE KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_INTERFACE_DEF, $1, $1e - $1s); } InterfaceBody { sysml2_pop(auxil); }
InterfaceBody <- SEMICOLON / LBRACE InterfaceBodyElement* RBRACE
InterfaceBodyElement <- MemberPrefix (EndMember / DefinitionElement / InterfaceUsageElement / AnnotatingElement)
InterfaceUsageElement <- UsageElement
PortDefinition <- DefinitionPrefix* KW_PORT KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_PORT_DEF, $1, $1e - $1s); } PortDefinitionBody { sysml2_pop(auxil); }
PortDefinitionBody <- SEMICOLON / LBRACE (PortDefinitionMember / ConjugatedPortDefinitionMember)* RBRACE
PortDefinitionMember <- MemberPrefix (DefinitionElement / PortUsageElement / Alias / AnnotatingElement)
ConjugatedPortDefinitionMember <- MemberPrefix KW_PORT (TILDE NAME SEMICOLON / ConjugatedPortDeclaration)
ConjugatedPortDeclaration <- Identification TILDE QualifiedName SEMICOLON
PortUsageElement <- ParameterUsage / UsageElement
AllocationDefinition <- DefinitionPrefix* KW_ALLOCATION KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_ALLOCATION_DEF, $1, $1e - $1s); } DefinitionBody { sysml2_pop(auxil); }
ActionDefinition <- DefinitionPrefix* KW_ACTION KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_ACTION_DEF, $1, $1e - $1s); } ActionBody { sysml2_pop(auxil); }
ActionBody <- SEMICOLON / LBRACE ActionBodyItem* RBRACE
ActionBodyItem <- MemberPrefix ActionBodyElement
ActionBodyElement <- DefinitionElement / BindUsage / TerminateAction / SuccessionUsage / StateUsage / CalcUsage / ShorthandFeatureMember / AssertConstraintUsage / VariantUsage / ActionUsageElement / AnnotatingElement / Import / Alias / StructureUsageElement
StateDefinition <- DefinitionPrefix* KW_STATE KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_STATE_DEF, $1, $1e - $1s); } StateBody { sysml2_pop(auxil); }
StateBody <- SEMICOLON / LBRACE StateBodyItem* RBRACE
StateBodyItem <- MemberPrefix StateBodyElement
StateBodyElement <- DefinitionElement / AssertConstraintUsage / StateUsageElement / AnnotatingElement / Import / Alias
StateUsageElement <- EntryAction / ExitAction / DoAction / EntryTransition / AcceptTransition / StateUsage / ExhibitStateUsage / TransitionUsage / SuccessionUsage / SuccessionMember / ConstraintUsage / ActionUsageElement
AcceptTransition <- KW_ACCEPT TriggerActionBody? EffectAction? TransitionEndAction
EntryAction <- KW_ENTRY (KW_ACTION UsageDeclaration ActionBody / KW_ACTION? UsageDeclaration SEMICOLON / AssignmentAction / SendAction / PerformActionUsage / QualifiedName FeatureChain? ActionBody / ActionBody)
ExitAction <- KW_EXIT (KW_ACTION UsageDeclaration ActionBody / KW_ACTION? UsageDeclaration SEMICOLON / AssignmentAction / SendAction / PerformActionUsage / QualifiedName FeatureChain? ActionBody / ActionBody)
DoAction <- KW_DO (KW_ACTION UsageDeclaration ActionBody / AssignmentAction / SendAction / PerformActionUsage / QualifiedName FeatureChain? (SEMICOLON / ActionBody) / ActionBody)
# perform action name; OR perform name;
# perform action name { } OR perform name.feature { } OR perform name; OR perform name redefines other;
# variation perform action doXorY { variant action doX; variant action doY; }
PerformActionUsage <- KW_VARIATION? KW_PERFORM (KW_ACTION UsageDeclaration ActionBody / QualifiedName FeatureChain? FeatureSpecialization* ActionBody)
EntryTransition <- KW_ENTRY? TransitionDeclaration TransitionBody
ConstraintDefinition <- DefinitionPrefix* KW_CONSTRAINT KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_CONSTRAINT_DEF, $1, $1e - $1s); } ConstraintBody { sysml2_pop(auxil); }
ConstraintBody <- SEMICOLON / LBRACE ConstraintBodyElement* ResultExpression? RBRACE
ConstraintBodyElement <- MemberPrefix (DefinitionElement / ConstraintUsageElement / AnnotatingElement)
RequirementDefinition <- DefinitionPrefix* KW_REQUIREMENT KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_REQUIREMENT_DEF, $1, $1e - $1s); } RequirementBody { sysml2_pop(auxil); }
RequirementBody <- SEMICOLON / LBRACE RequirementBodyItem* RBRACE
RequirementBodyItem <- MemberPrefix RequirementBodyElement
RequirementBodyElement <- DefinitionElement / VariantUsage / ReturnUsage / ReferenceUsage / RequirementUsageElement / ShorthandFeatureMember / SuccessionMember / AnnotatingElement / Import / Alias
# Variant can be: variant name;  OR  variant action name;  OR  variant perform name;
VariantUsage <- KW_VARIANT KW_PERFORM QualifiedName FeatureChain? SEMICOLON
              / KW_VARIANT KW_ACTION UsageDeclaration UsageBody
              / KW_VARIANT UsageDeclaration UsageBody
ConcernDefinition <- DefinitionPrefix* KW_CONCERN KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_CONCERN_DEF, $1, $1e - $1s); } RequirementBody { sysml2_pop(auxil); }
CalcDefinition <- DefinitionPrefix* KW_CALC KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_CALC_DEF, $1, $1e - $1s); } CalcBody { sysml2_pop(auxil); }
CalcBody <- SEMICOLON / LBRACE CalcBodyItem* ResultExpression? RBRACE
CalcBodyItem <- MemberPrefix CalcBodyElement
CalcBodyElement <- DefinitionElement / AssertConstraintUsage / CalcUsageElement / AnnotatingElement / Import / Alias / StructureUsageElement
CaseDefinition <- DefinitionPrefix* KW_CASE KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_CASE_DEF, $1, $1e - $1s); } CaseBody { sysml2_pop(auxil); }
CaseBody <- SEMICOLON / LBRACE CaseBodyItem* ResultExpression? RBRACE
CaseBodyItem <- MemberPrefix CaseBodyElement
CaseBodyElement <- DefinitionElement / CaseUsageElement / AnnotatingElement / Import / Alias / StructureUsageElement
AnalysisDefinition <- DefinitionPrefix* KW_ANALYSIS KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_ANALYSIS_DEF, $1, $1e - $1s); } CaseBody { sysml2_pop(auxil); }
VerificationDefinition <- DefinitionPrefix* KW_VERIFICATION KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_VERIFICATION_DEF, $1, $1e - $1s); } RequirementBody { sysml2_pop(auxil); }
UseCaseDefinition <- DefinitionPrefix* KW_USE KW_CASE KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_USE_CASE_DEF, $1, $1e - $1s); } CaseBody { sysml2_pop(auxil); }
ViewDefinition <- DefinitionPrefix* KW_VIEW KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_VIEW_DEF, $1, $1e - $1s); } ViewBody { sysml2_pop(auxil); }
ViewBody <- SEMICOLON / LBRACE ViewBodyElement* RBRACE
ViewBodyElement <- MemberPrefix (DefinitionElement / ViewUsageElement / Import / Alias / FilterPackageMember / AnnotatingElement)
ViewpointDefinition <- DefinitionPrefix* KW_VIEWPOINT KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_VIEWPOINT_DEF, $1, $1e - $1s); } RequirementBody { sysml2_pop(auxil); }
RenderingDefinition <- DefinitionPrefix* KW_RENDERING KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_RENDERING_DEF, $1, $1e - $1s); } ViewBody { sysml2_pop(auxil); }
MetadataDefinition <- DefinitionPrefix* KW_METADATA KW_DEF < Identification DefinitionSpecializations? > { sysml2_build_push(auxil, SYSML_KIND_METADATA_DEF, $1, $1e - $1s); } DefinitionBody { sysml2_pop(auxil); }

# Definition Body
DefinitionBody <- SEMICOLON / LBRACE DefinitionBodyItem* RBRACE
DefinitionBodyItem <- MemberPrefix (EndMember / DefinitionElement / KerMLFeatureElement / AssertConstraintUsage / BindUsage / ShorthandFeatureMember / SuccessionMember / UsageElement / Import / Alias / AnnotatingElement)
DefinitionSpecializations <- DefinitionSpecialization+
DefinitionSpecialization <- SPECIALIZES QualifiedName (COMMA QualifiedName)*
                          / TypeRelationshipPart

# Usages
UsageElement <- AssertSatisfyUsage / SatisfyUsage / ExhibitStateUsage / PerformActionUsage / MessageUsage / ReferenceUsage / AttributeUsage / EnumerationUsage / ItemUsage / PartUsage / ConnectionUsage / FlowUsage / InterfaceUsage / PortUsage / AllocationUsage / ActionUsage / StateUsage / ConstraintUsage / RequirementUsage / ConcernUsage / CalcUsage / CaseUsage / AnalysisUsage / VerificationUsage / UseCaseUsage / ViewUsage / ViewpointUsage / RenderingUsage / SuccessionUsage / PortionUsage / SubjectUsage / ActorUsage / StakeholderUsage / IncludeUseCaseUsage / EventOccurrenceUsage / EventUsage / OccurrenceUsage
PortionUsage <- BasicUsagePrefix* KW_INDIVIDUAL? PortionKind PortionUsageKind? UsageDeclaration UsageBody
PortionKind <- KW_SNAPSHOT / KW_TIMESLICE
PortionUsageKind <- KW_ITEM / KW_PART / KW_OCCURRENCE / KW_ATTRIBUTE
# Succession: the optional UsageDeclaration can't consume 'first' keyword
SuccessionUsage <- UsagePrefix* KW_SUCCESSION (!KW_FIRST UsageDeclaration)? SuccessionFirstPart? SuccessionUsageBody
SuccessionFirstPart <- KW_FIRST ConnectorEndMember (KW_THEN ConnectorEndMember)?
SuccessionUsageBody <- DecisionBranches / UsageBody
DecisionBranches <- DecisionBranch+
DecisionBranch <- KW_IF OwnedExpression KW_THEN ConnectorEndMember SEMICOLON / KW_ELSE ConnectorEndMember SEMICOLON

# Reference usage (standalone ref)
# Supports: ref name, ref state name, ref action name, ref requirement name, etc.
RefBehavioralKeyword <- KW_STATE / KW_ACTION / KW_OCCURRENCE / KW_CASE
                      / KW_REQUIREMENT / KW_MESSAGE / KW_CALC / KW_CONSTRAINT
                      / KW_VIEWPOINT / KW_CONCERN / KW_VIEW / KW_RENDERING
ReferenceUsage <- Direction? KW_REF PrefixMetadata* RefBehavioralKeyword? UsageDeclaration UsageBody
                / Direction? RefPrefix PrefixMetadata* UsageDeclaration UsageBody
StructureUsageElement <- AttributeUsage / ItemUsage / PartUsage / PortUsage / ConnectionUsage / FlowUsage / InterfaceUsage
BehaviorUsageElement <- ActionUsage / StateUsage / ConstraintUsage / CalcUsage
ActionUsageElement <- ParameterUsage / ActionUsage / PerformActionUsage / SendAction / AcceptAction / AssignmentAction / IfAction / WhileLoop / ForLoop / ControlNode / SuccessionMember
ConstraintUsageElement <- ParameterUsage / ReturnUsage / ConstraintUsage
RequirementUsageElement <- SubjectUsage / ActorUsage / StakeholderUsage / AssumeConstraint / RequireConstraint / AssertSatisfyUsage / SatisfyUsage / RequirementUsage / ConcernUsage / ConstraintUsage / ObjectiveUsage / FrameUsage / VerifyRequirementUsage / RequirementReference / VerificationUsage / CalcUsage / ActionUsage / AllocationUsage / ParameterUsage / StructureUsageElement
CalcUsageElement <- CalcUsage / ReturnUsage / ActionUsageElement / ConstraintUsage / StructureUsageElement
CaseUsageElement <- SubjectUsage / ActorUsage / StakeholderUsage / ObjectiveUsage / IncludeUseCaseUsage / UseCaseUsage / AnalysisUsage / VerificationUsage / AssertConstraintUsage / CalcUsageElement
IncludeUseCaseUsage <- KW_INCLUDE (KW_USE KW_CASE UsageDeclaration / QualifiedName FeatureChain? Multiplicity?) UsageBody
ViewUsageElement <- RenderUsage / ViewUsage / ViewpointUsage / RenderingUsage / ExposeUsage / RequireConstraint / SatisfyUsage / StructureUsageElement
ExposeUsage <- KW_EXPOSE (QualifiedName (COLONCOLON_STAR COLONCOLON_STARSTAR? / COLONCOLON_STARSTAR) / QualifiedName FeatureChain?) ImportFilter? UsageBody

# Usages
AttributeUsage <- UsagePrefix* KW_ATTRIBUTE < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_ATTRIBUTE_USAGE, $1, $1e - $1s); } UsageBody { sysml2_pop(auxil); }
EnumerationUsage <- UsagePrefix* KW_ENUM < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_ENUMERATION_USAGE, $1, $1e - $1s); } UsageBody { sysml2_pop(auxil); }
OccurrenceUsage <- UsagePrefix* KW_OCCURRENCE < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_OCCURRENCE_USAGE, $1, $1e - $1s); } OccurrenceUsageBody { sysml2_pop(auxil); }
                 / UsagePrefix+ UsageDeclaration OccurrenceUsageBody
EventOccurrenceUsage <- UsagePrefix* KW_EVENT KW_OCCURRENCE UsageDeclaration OccurrenceUsageBody
# Event can have feature chain with redefines: event x.y[1] :>> z;
# Or just reference: event name.feature;
EventUsage <- UsagePrefix* KW_EVENT QualifiedName FeatureChain? Multiplicity? REDEFINES QualifiedName SEMICOLON
            / UsagePrefix* KW_EVENT QualifiedName FeatureChain? Multiplicity SEMICOLON
            / UsagePrefix* KW_EVENT QualifiedName FeatureChain SEMICOLON
            / UsagePrefix* KW_EVENT QualifiedName SEMICOLON
            / UsagePrefix* KW_EVENT UsageDeclaration UsageBody
OccurrenceUsageBody <- SEMICOLON / LBRACE OccurrenceUsageMember* RBRACE
OccurrenceUsageMember <- MemberPrefix (OccurrenceDefinitionElement / AssertConstraintUsage / PortionUsage / EventOccurrenceUsage / EventUsage / OccurrenceUsage / MessageUsage / BindUsage / ShorthandFeatureMember / SuccessionMember / StructureUsageElement / AnnotatingElement)
ItemUsage <- UsagePrefix* KW_ITEM < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_ITEM_USAGE, $1, $1e - $1s); } UsageBody { sysml2_pop(auxil); }
PartUsage <- UsagePrefix* KW_PART < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_PART_USAGE, $1, $1e - $1s); } UsageBody { sysml2_pop(auxil); }
ConnectionUsage <- UsagePrefix* KW_CONNECTION UsageDeclaration? (KW_CONNECT ConnectionPart)? UsageBody / UsagePrefix* KW_CONNECT ConnectionPart UsageBody
ConnectionPart <- BinaryConnectorPart / NaryConnectorPart
BinaryConnectorPart <- ConnectorEndMember KW_TO ConnectorEndMember
NaryConnectorPart <- LPAREN ConnectorEndMember (COMMA ConnectorEndMember)+ RPAREN
ConnectorEndMember <- (NAME REFERENCES)? Multiplicity? QualifiedName FeatureChain? (REFERENCES QualifiedName FeatureChain?)?
# Flow can be: flow name of Type from x to y; OR flow x to y; OR flow name;
FlowUsage <- UsagePrefix* KW_SUCCESSION? KW_FLOW FlowBody
# Restructured to avoid partial match issues with optional FlowConnectionPart
# Supports: flow : Type of Payload from x to y; OR flow name of Payload from x to y;
FlowBody <- (COLONGTGT / COLONGT) QualifiedName FlowConnectionPart UsageBody
          / FlowConnectionPart UsageBody
          / UsageDeclaration (KW_OF NAME COLON QualifiedName Multiplicity? / KW_OF QualifiedName Multiplicity?)? (FlowConnectionPart UsageBody / UsageBody)
FlowConnectionPart <- KW_FROM FlowEndMember KW_TO FlowEndMember / FlowEndMember (KW_TO / KW_FROM) FlowEndMember
FlowEndMember <- QualifiedName FeatureChain?
# Interface: anonymous connection, or named with optional connect keyword
InterfaceUsage <- UsagePrefix* KW_INTERFACE &(ConnectorEndMember KW_TO) ConnectionPart InterfaceBody
                / UsagePrefix* KW_INTERFACE UsageDeclaration? (KW_CONNECT ConnectionPart)? InterfaceBody
PortUsage <- UsagePrefix* KW_PORT < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_PORT_USAGE, $1, $1e - $1s); } UsageBody { sysml2_pop(auxil); }
AllocationUsage <- UsagePrefix* KW_ALLOCATION UsageDeclaration? AllocationPart? UsageBody / UsagePrefix* KW_ALLOCATE AllocationPart UsageBody
AllocationPart <- KW_ALLOCATE? (BinaryConnectorPart / NaryConnectorPart)
# Action can be: action name; OR action name { } OR action name send/accept/while/for ...
# Also supports ref action name (params) :>> other;
ActionUsage <- UsagePrefix* KW_ACTION < ActionDeclaration > { sysml2_build_push(auxil, SYSML_KIND_ACTION_USAGE, $1, $1e - $1s); } ActionUsageBody { sysml2_pop(auxil); }
ActionDeclaration <- Identification? ActionParameterList? UsageSpecializations? FeatureValue?
ActionParameterList <- LPAREN ActionParameter (COMMA ActionParameter)* RPAREN
ActionParameter <- Direction? KW_REF? KW_ITEM? NAME (TypedBy / Subsets)? (EQ OwnedExpression)?
ActionUsageBody <- KW_TERMINATE SEMICOLON / KW_SEND SendActionTail / KW_ACCEPT AcceptActionTail / ActionAssignBody / ActionWhileBody / ActionForBody / ActionBody
ActionAssignBody <- KW_ASSIGN QualifiedName FeatureChain? COLONEQ OwnedExpression SEMICOLON
AcceptActionTail <- QualifiedName (COLON QualifiedName)? (KW_VIA QualifiedName FeatureChain?)? (ActionBody / SEMICOLON)
# Send can have expression or not: send expr via/to...; OR send via/to...;
SendActionTail <- (!KW_VIA !KW_TO OwnedExpression)? (KW_VIA QualifiedName FeatureChain?)? (KW_TO QualifiedName FeatureChain?)? (ActionBody / SEMICOLON)
ActionWhileBody <- KW_WHILE OwnedExpression ActionBodyParameter (KW_UNTIL OwnedExpression)? SEMICOLON?
ActionForBody <- KW_FOR NAME ForVariableSpec (ActionBodyParameter / ActionBody) SEMICOLON?
ForVariableSpec <- COLON QualifiedName (KW_IN OwnedExpression)? / KW_IN OwnedExpression
StateUsage <- UsagePrefix* KW_PARALLEL? KW_STATE < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_STATE_USAGE, $1, $1e - $1s); } KW_PARALLEL? StateBody { sysml2_pop(auxil); }
ExhibitStateUsage <- KW_EXHIBIT KW_STATE? QualifiedName FeatureChain KW_PARALLEL? ExhibitStateBody
                   / KW_EXHIBIT KW_STATE? UsageDeclaration KW_PARALLEL? ExhibitStateBody
ExhibitStateBody <- SEMICOLON / StateBody
ConstraintUsage <- UsagePrefix* KW_CONSTRAINT < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_CONSTRAINT_USAGE, $1, $1e - $1s); } ConstraintBody { sysml2_pop(auxil); }
RequirementUsage <- UsagePrefix* KW_REQUIREMENT < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_REQUIREMENT_USAGE, $1, $1e - $1s); } RequirementBody { sysml2_pop(auxil); }
ConcernUsage <- UsagePrefix* KW_CONCERN < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_CONCERN_USAGE, $1, $1e - $1s); } RequirementBody { sysml2_pop(auxil); }
CalcUsage <- UsagePrefix* KW_CALC < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_CALC_USAGE, $1, $1e - $1s); } CalcBody { sysml2_pop(auxil); }
CaseUsage <- UsagePrefix* KW_CASE < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_CASE_USAGE, $1, $1e - $1s); } CaseBody { sysml2_pop(auxil); }
AnalysisUsage <- UsagePrefix* KW_ANALYSIS < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_ANALYSIS_USAGE, $1, $1e - $1s); } CaseBody { sysml2_pop(auxil); }
VerificationUsage <- UsagePrefix* KW_VERIFICATION < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_VERIFICATION_USAGE, $1, $1e - $1s); } RequirementBody { sysml2_pop(auxil); }
UseCaseUsage <- UsagePrefix* KW_USE KW_CASE < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_USE_CASE_USAGE, $1, $1e - $1s); } CaseBody { sysml2_pop(auxil); }
ViewUsage <- UsagePrefix* KW_VIEW < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_VIEW_USAGE, $1, $1e - $1s); } ViewBody { sysml2_pop(auxil); }
ViewpointUsage <- UsagePrefix* KW_VIEWPOINT < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_VIEWPOINT_USAGE, $1, $1e - $1s); } RequirementBody { sysml2_pop(auxil); }
RenderingUsage <- UsagePrefix* KW_RENDERING < UsageDeclaration > { sysml2_build_push(auxil, SYSML_KIND_RENDERING_USAGE, $1, $1e - $1s); } ViewBody { sysml2_pop(auxil); }

# Specialized Usages
ParameterKind <- KW_ATTRIBUTE / KW_ITEM / KW_PART / KW_REQUIREMENT / KW_OCCURRENCE
               / KW_EVENT KW_OCCURRENCE / KW_ACTION / KW_STATE / KW_CASE
               / KW_MESSAGE / KW_CONSTRAINT / KW_CALC
ParameterUsage <- Direction? UsagePrefix* ParameterKind? UsageDeclaration UsageBody
Direction <- KW_IN / KW_OUT / KW_INOUT
SubjectUsage <- KW_SUBJECT (UsageDeclaration UsageBody / FeatureValue SEMICOLON)
ActorUsage <- KW_ACTOR (UsageDeclaration UsageBody / FeatureValue SEMICOLON)
StakeholderUsage <- KW_STAKEHOLDER (UsageDeclaration UsageBody / FeatureValue SEMICOLON)
ObjectiveUsage <- KW_OBJECTIVE UsageDeclaration RequirementBody
FrameUsage <- KW_FRAME (KW_CONCERN / KW_REQUIREMENT)? UsageDeclaration RequirementBody
RequirementReference <- RequirementConstraintKind UsageDeclaration? UsageBody
RequirementConstraintKind <- KW_ASSUME KW_CONSTRAINT? / KW_REQUIRE KW_CONSTRAINT?
VerifyRequirementUsage <- KW_VERIFY KW_REQUIREMENT? UsageDeclaration? UsageBody
                        / KW_VERIFY QualifiedName FeatureChain UsageBody
ReturnUsage <- KW_RETURN ReturnUsageKind? UsageDeclaration UsageBody
ReturnUsageKind <- KW_ATTRIBUTE / KW_PART / KW_ITEM / KW_REF
RenderUsage <- KW_RENDER KW_RENDERING? UsageDeclaration UsageBody

# Action Elements
SendAction <- KW_SEND OwnedExpression (KW_VIA QualifiedName FeatureChain?)? (KW_TO QualifiedName FeatureChain?)? SEMICOLON
AcceptAction <- KW_ACCEPT AcceptParameterPart (ActionBody / SEMICOLON)
AcceptParameterPart <- PayloadParameter (KW_VIA QualifiedName FeatureChain?)?
PayloadParameter <- TriggerPart / Identification? PayloadFeatureSpec? TriggerPart?
PayloadFeatureSpec <- TypedBy
TriggerPart <- TriggerKind OwnedExpression
TriggerKind <- KW_AT / KW_AFTER / KW_WHEN
AssignmentAction <- KW_ASSIGN QualifiedName FeatureChain? COLONEQ OwnedExpression SEMICOLON
IfAction <- KW_IF OwnedExpression IfThenPart IfElsePart?
IfThenPart <- KW_THEN? (ActionBodyParameter / ActionBodyElement)
IfElsePart <- KW_ELSE (IfAction / ActionBodyParameter / ActionBodyElement)
ActionBodyParameter <- (KW_ACTION UsageDeclaration?)? LBRACE ActionBodyItem* RBRACE
WhileLoop <- KW_WHILE OwnedExpression (KW_UNTIL OwnedExpression)? (ActionBodyParameter / ActionBody)
           / KW_LOOP (ActionBodyParameter / ActionBody) KW_UNTIL OwnedExpression SEMICOLON
           / KW_LOOP (ActionBodyParameter / ActionBody)
ForLoop <- KW_FOR NAME ForVariableSpec (ActionBodyParameter / ActionBody)
ControlNode <- MergeNode / DecisionNode / JoinNode / ForkNode
MergeNode <- KW_MERGE UsageDeclaration? ActionBody
DecisionNode <- KW_DECIDE UsageDeclaration? ActionBody
JoinNode <- KW_JOIN UsageDeclaration? ActionBody
ForkNode <- KW_FORK UsageDeclaration? ActionBody
# Guarded succession: first x if cond then y;
GuardedSuccession <- KW_IF OwnedExpression KW_THEN QualifiedName FeatureChain? SEMICOLON
SuccessionMember <- KW_FIRST QualifiedName FeatureChain? GuardedSuccession
                  / KW_FIRST SuccessionBody
                  / KW_THEN ThenTarget
                  / QualifiedName FeatureChain? KW_THEN SuccessionBody
ThenTarget <- SuccessionInlineAction / QualifiedName ActionBody / QualifiedName FeatureChain? SEMICOLON / ActionBody
# Allow visibility indicator (public/private/protected) before inline actions
SuccessionInlineAction <- VisibilityIndicator? (AcceptActionUsage / AcceptAction / SendAction / AssignmentAction / IfAction / WhileLoop / ForLoop / ControlNode / IncludeUseCaseUsage / UseCaseUsage / PortionUsage / StateUsage / EventOccurrenceUsage / EventUsage / OccurrenceUsage / PerformActionUsage / ActionUsage)
AcceptActionUsage <- KW_ACTION KW_ACCEPT NAME TypedBy ActionBody
                   / KW_ACTION KW_ACCEPT NAME TypedBy SEMICOLON
SuccessionBody <- QualifiedName FeatureChain? KW_THEN QualifiedName FeatureChain? ActionBody
                / QualifiedName FeatureChain? (KW_THEN QualifiedName FeatureChain?)? SEMICOLON
                / QualifiedName? ActionBody

# Transition Elements
TransitionUsage <- KW_TRANSITION TransitionDeclaration? TransitionBody
TransitionDeclaration <- KW_FIRST? TransitionName? (COLON QualifiedName)? TransitionSourceTarget?
TransitionName <- !KW_ACCEPT !KW_FIRST !KW_THEN !KW_DO NAME
TransitionSourceTarget <- KW_FIRST? TransitionTarget (KW_THEN TransitionTarget)?
TransitionTarget <- !KW_ACCEPT !KW_THEN !KW_DO QualifiedName FeatureChain?
TransitionBody <- SEMICOLON / TransitionActionBody
TransitionActionBody <- TriggerAction* GuardAction? EffectAction? TransitionEndAction
GuardAction <- KW_IF OwnedExpression
TriggerAction <- (KW_ACCEPT / KW_FIRST) TriggerActionBody?
TriggerActionBody <- (AcceptPayload (KW_VIA QualifiedName FeatureChain?)?)? TriggerPart?
AcceptPayload <- !TriggerKind NAME (COLON QualifiedName)?
EffectAction <- KW_DO (EffectSendAction / KW_ACTION NAME / KW_ACTION ActionBody / NAME / ActionBody)
EffectSendAction <- KW_SEND OwnedExpression (KW_VIA QualifiedName FeatureChain?)? (KW_TO QualifiedName FeatureChain?)?
TransitionEndAction <- KW_THEN (QualifiedName FeatureChain? ActionBody / QualifiedName FeatureChain? SEMICOLON / ActionBody)

# Usage Declaration
UsageDeclaration <- Identification? UsageSpecializations? FeatureValue?
UsageSpecializations <- UsageSpecialization+
UsageSpecialization <- Multiplicity / TypedBy / Subsets / Redefines / References / Crosses
TypedBy <- TYPED_BY TILDE? QualifiedName Multiplicity? (COMMA QualifiedName Multiplicity?)*
Subsets <- SUBSETS QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)*
Redefines <- REDEFINES QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)*
References <- REFERENCES QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)*
Crosses <- KW_CROSSES QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)*
FeatureSpecialization <- Multiplicity / TypedBy / Subsets / Redefines / References / Crosses

# Feature Value
FeatureValue <- (EQ / COLONEQ / KW_DEFAULT (EQ / COLONEQ)?) OwnedExpression

# Multiplicity
Multiplicity <- LBRACKET MultiplicityBounds? RBRACKET OrderedNonunique?
MultiplicityBounds <- OwnedExpression (DOTDOT (OwnedExpression / STAR))? / STAR
OrderedNonunique <- (KW_ORDERED KW_NONUNIQUE?) / (KW_NONUNIQUE KW_ORDERED?)

# Usage Body
UsageBody <- SEMICOLON / LBRACE UsageBodyItem* RBRACE
UsageBodyItem <- MemberPrefix (DefinitionElement / AssertConstraintUsage / BindUsage / ShorthandFeatureMember / SuccessionMember / VariantUsage / RequireConstraint / AssumeConstraint / UsageElement / Import / Alias / AnnotatingElement)

# Shorthand feature member like :>> name = value; or :> name = value; or :>> name : Type { }
# Also supports comma-separated targets: :>> a, b;
ShorthandFeatureMember <- (COLONGTGT / COLONGT) QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)* (COLON QualifiedName Multiplicity?)? FeatureValue? UsageBody
                        / KW_REDEFINES QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)* FeatureValue? UsageBody
                        / ImplicitInvocation
                        / ImplicitShorthand
# Implicit invocation like P::Q(args) as a body element
# Must not match usage keywords that take arguments like connect, allocate
ImplicitInvocation <- !SpecializationKeyword !UsageKeyword QualifiedName ArgumentList
UsageKeyword <- ('connect' / 'allocate' / 'include' / 'perform' / 'exhibit' / 'send' / 'accept') !IdentCont
ImplicitShorthand <- !SpecializationKeyword NAME FeatureChain? FeatureSpecialization* FeatureValue? UsageBody

# === BIND STATEMENT ===
# Supports: bind x = y; or binding [mult] bind [mult] x = [mult] y;
BindUsage <- KW_BINDING Multiplicity? KW_BIND Multiplicity? QualifiedName FeatureChain? EQ Multiplicity? QualifiedName FeatureChain? RelationshipBody
           / KW_BIND Multiplicity? QualifiedName FeatureChain? EQ Multiplicity? QualifiedName FeatureChain? RelationshipBody

# === ASSERT CONSTRUCTS ===
AssertConstraintUsage <- KW_ASSERT KW_NOT? AssertConstraintBody
AssertConstraintBody <- KW_CONSTRAINT UsageDeclaration? ConstraintBody
                      / UsageDeclaration ConstraintBody

# === SATISFY USAGE ===
# Pattern 1: satisfy [requirement] usageDecl by target body
# Pattern 2: satisfy qualifiedName by target body (reference existing requirement)
SatisfyUsage <- KW_NOT? KW_SATISFY KW_REQUIREMENT? UsageDeclaration (KW_BY QualifiedName FeatureChain?)? UsageBody
              / KW_NOT? KW_SATISFY QualifiedName FeatureChain? (KW_BY QualifiedName FeatureChain?)? UsageBody
AssertSatisfyUsage <- KW_ASSERT KW_NOT? KW_SATISFY KW_REQUIREMENT? UsageDeclaration KW_BY QualifiedName FeatureChain? UsageBody
                    / KW_ASSERT KW_NOT? KW_SATISFY QualifiedName FeatureChain? KW_BY QualifiedName FeatureChain? UsageBody

# === ASSUME/REQUIRE IN REQUIREMENTS ===
AssumeConstraint <- KW_ASSUME PrefixMetadata* KW_CONSTRAINT? UsageDeclaration ConstraintBody
# RequireConstraint: with 'constraint' keyword uses ConstraintBody, otherwise uses UsageBody
# Also supports feature chain: require name.feature;
RequireConstraint <- KW_REQUIRE PrefixMetadata* KW_CONSTRAINT UsageDeclaration? ConstraintBody
                   / KW_REQUIRE PrefixMetadata* QualifiedName FeatureChain UsageBody
                   / KW_REQUIRE PrefixMetadata* UsageDeclaration UsageBody

# === END MEMBER FOR CONNECTIONS ===
# End member can have identification before multiplicity: end inCart[0..1] item cart: Type;
EndMember <- KW_END Identification? Multiplicity? KW_REF? (KW_PORT / KW_ITEM / KW_PART / KW_OCCURRENCE / KW_ACTION)? UsageDeclaration UsageBody

# === MESSAGE USAGE ===
# Message can have 'of' for payload type: message name of Type from x to y;
# Also supports typed-only: message : Type from x to y;
MessageUsage <- UsagePrefix* KW_MESSAGE (TypedBy / Identification? UsageSpecializations? (KW_OF NAME (COLON QualifiedName)? Multiplicity?)? FeatureValue?) MessageFlowPart? UsageBody
MessageFlowPart <- KW_FROM FlowEndMember KW_TO FlowEndMember / FlowConnectionPart

# === TERMINATE ACTION ===
TerminateAction <- KW_TERMINATE QualifiedName FeatureChain? SEMICOLON
                 / KW_TERMINATE SEMICOLON

# === RESULT EXPRESSION (bare expression in bodies) ===
ResultExpression <- OwnedExpression

# Expressions
OwnedExpression <- ConditionalExpression
# Support: 1) postfix: expr if condition else expr  2) prefix: if condition [?] then-expr [else else-expr]
# Use ConditionalExpression for else to allow else-if chaining
# The ? is optional between condition and then-expr in prefix form
ConditionalExpression <- KW_IF ImplicationExpression QMARK? ImplicationExpression (KW_ELSE ConditionalExpression)? / ImplicationExpression (KW_IF ImplicationExpression KW_ELSE ConditionalExpression)?
ImplicationExpression <- NullCoalescingExpression (KW_IMPLIES NullCoalescingExpression)?
NullCoalescingExpression <- OrExpression (QMARKQMARK OrExpression)?
OrExpression <- XorExpression (OrOperator XorExpression)*
OrOperator <- PIPE / KW_OR
XorExpression <- AndExpression (XorOperator AndExpression)*
XorOperator <- KW_XOR
AndExpression <- EqualityExpression (AndOperator EqualityExpression)*
AndOperator <- AMP / KW_AND
EqualityExpression <- ClassificationExpression (EqualityOperator ClassificationExpression)?
EqualityOperator <- EQEQ / BANGEQ / EQEQEQ / BANGEQEQ
ClassificationExpression <- RelationalExpression (ClassificationOperator QualifiedName)?
ClassificationOperator <- KW_HASTYPE / KW_ISTYPE / AT / KW_AS
RelationalExpression <- RangeExpression (RelationalOperator RangeExpression)?
RelationalOperator <- LT / GT / LE / GE
RangeExpression <- AdditiveExpression (DOTDOT AdditiveExpression)?
AdditiveExpression <- MultiplicativeExpression (AdditiveOperator MultiplicativeExpression)*
AdditiveOperator <- PLUS / MINUS
MultiplicativeExpression <- ExponentiationExpression (MultiplicativeOperator ExponentiationExpression)*
MultiplicativeOperator <- STAR / SLASH / PERCENT
ExponentiationExpression <- UnaryExpression ((STARSTAR / CARET) UnaryExpression)?
UnaryExpression <- UnaryOperator? ExtentExpression
UnaryOperator <- PLUS / MINUS / BANG / KW_NOT / TILDE
ExtentExpression <- (KW_ALL ExtentExpression) / SequenceExpression
SequenceExpression <- BracketExpression (SequenceTail)*
SequenceTail <- COMMA UnaryExpression
# BracketExpression with optional collection operators like ->forAll {} and index operator #() and select .?{}
# Note: Inside brackets we use OwnedExpression to support unit expressions like [N * m]
# FeatureChain can be followed by ArgumentList for method calls like a.b(args)
BracketExpression <- PrimaryExpression FeatureChain? ArgumentList? QMARK? SelectOperator? IndexExpression? (LBRACKET OwnedExpression? RBRACKET)? FeatureChain? CollectionOperator* IndexExpression?
SelectOperator <- DOTQ CollectionBody
IndexExpression <- HASH LPAREN OwnedExpression RPAREN
# Support function reference args like ->reduce '+' or ->reduce min
CollectionOperator <- ARROW NAME (CollectionBody / FunctionReferenceArg / ArgumentList)?
FunctionReferenceArg <- STRING_VALUE / QualifiedName
CollectionBody <- LBRACE AnnotatingElement* CollectionBodyParameter* OwnedExpression? RBRACE
CollectionBodyParameter <- VisibilityIndicator? KW_IN? KW_REF? (KW_ATTRIBUTE / KW_PART / KW_ITEM)? NAME (TypedBy / Subsets)? (EQ OwnedExpression)? (SEMICOLON / CollectionParameterBody)
CollectionParameterBody <- LBRACE (ShorthandFeatureMember / AnnotatingElement)* RBRACE
PrimaryExpression <- BodyExpression / LPAREN OwnedExpression? RPAREN / NewExpression / SelectExpression / CollectExpression / NullExpression / MetadataAccessExpression / MetadataReferenceExpression / MetaExpression / InvocationExpression / NameExpression / LiteralExpression
MetadataReferenceExpression <- AT QualifiedName
MetaExpression <- QualifiedName KW_META QualifiedName
BodyExpression <- LBRACE OwnedExpression RBRACE
NewExpression <- KW_NEW QualifiedName ArgumentList? FeatureChain?
SelectExpression <- DOT QMARK? SequenceExpression
CollectExpression <- DOTQ SequenceExpression
NullExpression <- KW_NULL
MetadataAccessExpression <- QualifiedName DOT KW_METADATA
InvocationExpression <- QualifiedName ArgumentList FeatureChain?
ArgumentList <- LPAREN ArgumentListItems? RPAREN
ArgumentListItems <- Argument (COMMA Argument)*
Argument <- (NAME EQ)? ArgumentExpression
ArgumentExpression <- ConditionalArgumentExpression
# Support both prefix (if cond ? then else else) and postfix (then if cond else else)
ConditionalArgumentExpression <- KW_IF NullCoalescingArgumentExpression QMARK? NullCoalescingArgumentExpression (KW_ELSE ConditionalArgumentExpression)?
                               / NullCoalescingArgumentExpression (KW_IF NullCoalescingArgumentExpression KW_ELSE ConditionalArgumentExpression)?
NullCoalescingArgumentExpression <- OrArgumentExpression (QMARKQMARK OrArgumentExpression)?
OrArgumentExpression <- XorArgumentExpression (OrOperator XorArgumentExpression)*
XorArgumentExpression <- AndArgumentExpression (XorOperator AndArgumentExpression)*
AndArgumentExpression <- EqualityArgumentExpression (AndOperator EqualityArgumentExpression)*
EqualityArgumentExpression <- ClassificationArgumentExpression (EqualityOperator ClassificationArgumentExpression)?
ClassificationArgumentExpression <- RelationalArgumentExpression (ClassificationOperator QualifiedName)?
RelationalArgumentExpression <- RangeArgumentExpression (RelationalOperator RangeArgumentExpression)?
RangeArgumentExpression <- AdditiveArgumentExpression (DOTDOT AdditiveArgumentExpression)?
AdditiveArgumentExpression <- MultiplicativeArgumentExpression (AdditiveOperator MultiplicativeArgumentExpression)*
MultiplicativeArgumentExpression <- ExponentiationArgumentExpression (MultiplicativeOperator ExponentiationArgumentExpression)*
ExponentiationArgumentExpression <- UnaryArgumentExpression ((STARSTAR / CARET) UnaryArgumentExpression)?
UnaryArgumentExpression <- UnaryOperator? ExtentArgumentExpression
ExtentArgumentExpression <- (KW_ALL ExtentArgumentExpression) / BracketExpression
NameExpression <- QualifiedName FeatureChain?
FeatureChain <- (DOT QualifiedName)+
LiteralExpression <- LiteralBoolean / LiteralString / LiteralReal / LiteralInteger
LiteralBoolean <- KW_TRUE / KW_FALSE
LiteralString <- STRING_VALUE
LiteralReal <- REAL_VALUE
LiteralInteger <- DECIMAL_VALUE

%%

# SysML v2 PEG Grammar for packcc
#
# Syntax checking only - no AST building
#
# SPDX-License-Identifier: MIT

%prefix "sysml"

%header {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    const char *filename;
    const char *input;
    size_t input_len;
    size_t input_pos;
    int error_count;
    int line;
    int col;

    /* Furthest failure tracking for better error messages */
    size_t furthest_pos;
    int furthest_line;
    int furthest_col;
    const char *failed_rules[16];  /* Rules that failed at furthest pos */
    int failed_rule_count;
    const char *context_rule;       /* Enclosing rule for context */
} SysmlParserContext;

#define PCC_GETCHAR(auxil) sysml_getchar(auxil)
#define PCC_ERROR(auxil) sysml_error(auxil)

static inline int sysml_getchar(SysmlParserContext *ctx) {
    if (ctx->input_pos >= ctx->input_len) return EOF;
    int c = (unsigned char)ctx->input[ctx->input_pos++];
    if (c == '\n') {
        ctx->line++;
        ctx->col = 1;
    } else {
        ctx->col++;
    }
    return c;
}

/* Check if a rule name is "noise" that we don't want to report */
static inline int sysml_is_noise_rule(const char *rule) {
    return strcmp(rule, "_") == 0 || strcmp(rule, "WS") == 0 ||
           strcmp(rule, "LineComment") == 0 || strcmp(rule, "BlockComment") == 0 ||
           strcmp(rule, "IdentCont") == 0 || strcmp(rule, "StringChar") == 0 ||
           strcmp(rule, "EscapeSequence") == 0 || strcmp(rule, "UnrestrictedNameChar") == 0;
}

/* Debug hook to track furthest failure position */
static inline void sysml_debug_hook(SysmlParserContext *ctx, int event,
                                     const char *rule, size_t pos) {
    if (event != 2) return;  /* Only track NOMATCH (event == 2) */
    if (sysml_is_noise_rule(rule)) return;

    if (pos > ctx->furthest_pos) {
        /* New furthest position - reset tracking */
        ctx->furthest_pos = pos;
        ctx->furthest_line = ctx->line;
        ctx->furthest_col = ctx->col;
        ctx->failed_rule_count = 0;
        ctx->context_rule = NULL;
    }

    if (pos == ctx->furthest_pos && ctx->failed_rule_count < 16) {
        /* Record this failure at furthest position */
        for (int i = 0; i < ctx->failed_rule_count; i++) {
            if (strcmp(ctx->failed_rules[i], rule) == 0) return;
        }
        ctx->failed_rules[ctx->failed_rule_count++] = rule;
    }
}

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
    sysml_debug_hook((auxil), (event), (rule), (pos))

#define ANSI_BOLD    "\x1b[1m"
#define ANSI_RED     "\x1b[31m"
#define ANSI_GREEN   "\x1b[32m"
#define ANSI_CYAN    "\x1b[36m"
#define ANSI_RESET   "\x1b[0m"

/* Rule-to-message mapping for better error diagnostics */
typedef struct {
    const char *rule;
    const char *expectation;
    const char *help;
} SysmlExpectation;

static const SysmlExpectation expectations[] = {
    /* Terminals */
    {"SEMICOLON", "';'", NULL},
    {"LBRACE", "'{'", NULL},
    {"RBRACE", "'}'", NULL},
    {"LPAREN", "'('", NULL},
    {"RPAREN", "')'", NULL},
    {"LBRACKET", "'['", NULL},
    {"RBRACKET", "']'", NULL},
    {"COLON", "':'", NULL},
    {"EQ", "'='", NULL},
    {"COMMA", "','", NULL},
    {"DOT", "'.'", NULL},
    {"DOTDOT", "'..'", NULL},
    {"ARROW", "'->'", NULL},
    {"COLONGT", "':>'", NULL},
    {"COLONGTGT", "':>>'", NULL},

    /* Names and identifiers */
    {"NAME", "identifier", NULL},
    {"BasicName", "identifier", NULL},
    {"QualifiedName", "qualified name", NULL},
    {"Identification", "name", NULL},

    /* Expressions */
    {"OwnedExpression", "expression", NULL},
    {"PrimaryExpression", "expression", NULL},
    {"LiteralExpression", "literal value", NULL},
    {"MultiplicityBounds", "multiplicity value",
     "use [1], [0..1], [*], or [1..*]"},

    /* Declarations */
    {"UsageDeclaration", "declaration", NULL},
    {"TypedBy", "type", "use ':' followed by a type name"},
    {"FeatureValue", "value", "use '=' followed by an expression"},

    /* Keywords - common ones users might mis-type or forget */
    {"KW_PACKAGE", "'package'", NULL},
    {"KW_PART", "'part'", NULL},
    {"KW_DEF", "'def'", NULL},
    {"KW_IMPORT", "'import'", NULL},
    {"KW_ACTION", "'action'", NULL},
    {"KW_ITEM", "'item'", NULL},
    {"KW_ATTRIBUTE", "'attribute'", NULL},
    {"KW_PORT", "'port'", NULL},
    {"KW_CONNECTION", "'connection'", NULL},
    {"KW_FLOW", "'flow'", NULL},
    {"KW_STATE", "'state'", NULL},
    {"KW_CONSTRAINT", "'constraint'", NULL},
    {"KW_REQUIREMENT", "'requirement'", NULL},
    {"KW_CALC", "'calc'", NULL},
    {"KW_CASE", "'case'", NULL},
    {"KW_IF", "'if'", NULL},
    {"KW_THEN", "'then'", NULL},
    {"KW_ELSE", "'else'", NULL},
    {"KW_TO", "'to'", NULL},
    {"KW_FROM", "'from'", NULL},
    {"KW_FOR", "'for'", NULL},

    /* Body elements */
    {"PackageBodyElement", "package member", NULL},
    {"DefinitionBodyItem", "definition member", NULL},
    {"UsageBodyItem", "usage member", NULL},
    {"ActionBodyItem", "action body member", NULL},

    /* Definitions and usages */
    {"DefinitionElement", "definition", NULL},
    {"UsageElement", "usage", NULL},

    {NULL, NULL, NULL}
};

static const SysmlExpectation *sysml_lookup_expectation(const char *rule) {
    for (int i = 0; expectations[i].rule; i++) {
        if (strcmp(expectations[i].rule, rule) == 0) {
            return &expectations[i];
        }
    }
    return NULL;
}

/* Compute line and column from position */
static void sysml_pos_to_line_col(SysmlParserContext *ctx, size_t pos,
                                   int *out_line, int *out_col) {
    int line = 1;
    int col = 1;
    for (size_t i = 0; i < pos && i < ctx->input_len; i++) {
        if (ctx->input[i] == '\n') {
            line++;
            col = 1;
        } else {
            col++;
        }
    }
    *out_line = line;
    *out_col = col;
}

static inline void sysml_error(SysmlParserContext *ctx) {
    ctx->error_count++;

    /* Use furthest position for error location if available */
    int err_line, err_col;
    if (ctx->furthest_pos > 0 && ctx->failed_rule_count > 0) {
        sysml_pos_to_line_col(ctx, ctx->furthest_pos, &err_line, &err_col);
    } else {
        err_line = ctx->line;
        err_col = ctx->col;
    }

    /* Build expectation message from failed rules */
    char expected[256] = "";
    const char *help = NULL;
    int count = 0;

    for (int i = 0; i < ctx->failed_rule_count && count < 3; i++) {
        const SysmlExpectation *exp = sysml_lookup_expectation(ctx->failed_rules[i]);
        if (!exp) continue;

        if (count > 0) {
            if (count == 1 && ctx->failed_rule_count <= 2) {
                strcat(expected, " or ");
            } else {
                strcat(expected, ", ");
            }
        }
        strcat(expected, exp->expectation);
        if (!help && exp->help) help = exp->help;
        count++;
    }

    /* Find the source line for display */
    const char *line_start = ctx->input;
    int cur_line = 1;
    while (cur_line < err_line && *line_start) {
        if (*line_start == '\n') cur_line++;
        line_start++;
    }
    const char *line_end = line_start;
    while (*line_end && *line_end != '\n') line_end++;

    /* Print error header with specific expectation if available */
    fprintf(stderr, ANSI_BOLD "%s:%d:%d: " ANSI_RED "error: " ANSI_RESET ANSI_BOLD,
            ctx->filename, err_line, err_col);

    if (count > 0) {
        fprintf(stderr, "expected %s" ANSI_RESET "\n", expected);
    } else {
        fprintf(stderr, "syntax error" ANSI_RESET "\n");
    }

    /* Print source line context */
    fprintf(stderr, " %5d | %.*s\n", err_line, (int)(line_end - line_start), line_start);
    fprintf(stderr, "       | " ANSI_GREEN);
    for (int i = 1; i < err_col; i++) {
        char c = (i <= (int)(line_end - line_start)) ? line_start[i-1] : ' ';
        fprintf(stderr, "%c", (c == '\t') ? '\t' : ' ');
    }
    fprintf(stderr, "^" ANSI_RESET "\n");

    /* Print help text if available */
    if (help) {
        fprintf(stderr, "       = " ANSI_CYAN "help: " ANSI_RESET "%s\n", help);
    }
}
}

%auxil "SysmlParserContext *"
%value "void *"

# Entry point - parse entire file
File <- _ (Package / LibraryPackage / PackageBodyElement)* EOF

# Whitespace and Comments
_   <- (WS / BlockComment / LineComment)*
WS  <- [ \t\n\r\f]+
LineComment <- '//' (![\n\r] .)*
BlockComment <- '//*' (!'*/' .)* '*/'
RegularComment <- '/*' (!'*/' .)* '*/' _
EOF <- !.

# Lexical
NAME <- BasicName / UnrestrictedName
BasicName <- [a-zA-Z_] [a-zA-Z0-9_]* _
UnrestrictedName <- '\'' (UnrestrictedNameChar / EscapeSequence)* '\'' _
UnrestrictedNameChar <- [^'\\]
EscapeSequence <- '\\' [fnrtv'\\]
StringChar <- [^"\\]
IdentCont <- [a-zA-Z0-9_]
DECIMAL_VALUE <- [0-9]+ _
REAL_VALUE <- [0-9]+ '.' !'.' [0-9]* ([eE] [+-]? [0-9]+)? _
           /  '.' [0-9]+ ([eE] [+-]? [0-9]+)? _
           /  [0-9]+ [eE] [+-]? [0-9]+ _
STRING_VALUE <- '"' (StringChar / EscapeSequence)* '"' _

QualifiedName <- ('::' _)? NameSegment ('::' _ NameSegment)*
NameSegment <- NAME / UnrestrictedName

# Keywords
KW_ABOUT       <- 'about'       !IdentCont _
KW_ABSTRACT    <- 'abstract'    !IdentCont _
KW_ACCEPT      <- 'accept'      !IdentCont _
KW_ACTION      <- 'action'      !IdentCont _
KW_ACTOR       <- 'actor'       !IdentCont _
KW_AFTER       <- 'after'       !IdentCont _
KW_ALIAS       <- 'alias'       !IdentCont _
KW_ALL         <- 'all'         !IdentCont _
KW_ALLOCATE    <- 'allocate'    !IdentCont _
KW_ALLOCATION  <- 'allocation'  !IdentCont _
KW_ANALYSIS    <- 'analysis'    !IdentCont _
KW_AND         <- 'and'         !IdentCont _
KW_AS          <- 'as'          !IdentCont _
KW_ASSERT      <- 'assert'      !IdentCont _
KW_ASSIGN      <- 'assign'      !IdentCont _
KW_ASSUME      <- 'assume'      !IdentCont _
KW_AT          <- 'at'          !IdentCont _
KW_ATTRIBUTE   <- 'attribute'   !IdentCont _
KW_BIND        <- 'bind'        !IdentCont _
KW_BINDING     <- 'binding'     !IdentCont _
KW_BY          <- 'by'          !IdentCont _
KW_CALC        <- 'calc'        !IdentCont _
KW_CASE        <- 'case'        !IdentCont _
KW_COMMENT     <- 'comment'     !IdentCont _
KW_CONCERN     <- 'concern'     !IdentCont _
KW_CONNECT     <- 'connect'     !IdentCont _
KW_CONNECTION  <- 'connection'  !IdentCont _
KW_CONSTRAINT  <- 'constraint'  !IdentCont _
KW_CONSTANT    <- 'constant'    !IdentCont _
KW_CROSSES     <- 'crosses'     !IdentCont _
KW_DECIDE      <- 'decide'      !IdentCont _
KW_DEF         <- 'def'         !IdentCont _
KW_DEFAULT     <- 'default'     !IdentCont _
KW_DEFINED     <- 'defined'     !IdentCont _
KW_DEPENDENCY  <- 'dependency'  !IdentCont _
KW_DERIVED     <- 'derived'     !IdentCont _
KW_DO          <- 'do'          !IdentCont _
KW_DOC         <- 'doc'         !IdentCont _
KW_ELSE        <- 'else'        !IdentCont _
KW_END         <- 'end'         !IdentCont _
KW_ENTRY       <- 'entry'       !IdentCont _
KW_ENUM        <- 'enum'        !IdentCont _
KW_EVENT       <- 'event'       !IdentCont _
KW_EXHIBIT     <- 'exhibit'     !IdentCont _
KW_EXIT        <- 'exit'        !IdentCont _
KW_EXPOSE      <- 'expose'      !IdentCont _
KW_FALSE       <- 'false'       !IdentCont _
KW_FILTER      <- 'filter'      !IdentCont _
KW_FIRST       <- 'first'       !IdentCont _
KW_FLOW        <- 'flow'        !IdentCont _
KW_FOR         <- 'for'         !IdentCont _
KW_FORK        <- 'fork'        !IdentCont _
KW_FRAME       <- 'frame'       !IdentCont _
KW_FROM        <- 'from'        !IdentCont _
KW_HASTYPE     <- 'hastype'     !IdentCont _
KW_IF          <- 'if'          !IdentCont _
KW_IMPLIES     <- 'implies'     !IdentCont _
KW_IMPORT      <- 'import'      !IdentCont _
KW_IN          <- 'in'          !IdentCont _
KW_INCLUDE     <- 'include'     !IdentCont _
KW_INDIVIDUAL  <- 'individual'  !IdentCont _
KW_INOUT       <- 'inout'       !IdentCont _
KW_INTERFACE   <- 'interface'   !IdentCont _
KW_ISTYPE      <- 'istype'      !IdentCont _
KW_ITEM        <- 'item'        !IdentCont _
KW_JOIN        <- 'join'        !IdentCont _
KW_LANGUAGE    <- 'language'    !IdentCont _
KW_LIBRARY     <- 'library'     !IdentCont _
KW_LOCALE      <- 'locale'      !IdentCont _
KW_LOOP        <- 'loop'        !IdentCont _
KW_MERGE       <- 'merge'       !IdentCont _
KW_MESSAGE     <- 'message'     !IdentCont _
KW_META        <- 'meta'        !IdentCont _
KW_METADATA    <- 'metadata'    !IdentCont _
KW_NEW         <- 'new'         !IdentCont _
KW_NONUNIQUE   <- 'nonunique'   !IdentCont _
KW_NOT         <- 'not'         !IdentCont _
KW_NULL        <- 'null'        !IdentCont _
KW_OBJECTIVE   <- 'objective'   !IdentCont _
KW_OCCURRENCE  <- 'occurrence'  !IdentCont _
KW_OF          <- 'of'          !IdentCont _
KW_OR          <- 'or'          !IdentCont _
KW_ORDERED     <- 'ordered'     !IdentCont _
KW_OUT         <- 'out'         !IdentCont _
KW_PACKAGE     <- 'package'     !IdentCont _
KW_PARALLEL    <- 'parallel'    !IdentCont _
KW_PART        <- 'part'        !IdentCont _
KW_PERFORM     <- 'perform'     !IdentCont _
KW_PORT        <- 'port'        !IdentCont _
KW_PRIVATE     <- 'private'     !IdentCont _
KW_PROTECTED   <- 'protected'   !IdentCont _
KW_PUBLIC      <- 'public'      !IdentCont _
KW_READONLY    <- 'readonly'    !IdentCont _
KW_REDEFINES   <- 'redefines'   !IdentCont _
KW_REF         <- 'ref'         !IdentCont _
KW_REFERENCES  <- 'references'  !IdentCont _
KW_RENDER      <- 'render'      !IdentCont _
KW_RENDERING   <- 'rendering'   !IdentCont _
KW_REP         <- 'rep'         !IdentCont _
KW_REQUIRE     <- 'require'     !IdentCont _
KW_REQUIREMENT <- 'requirement' !IdentCont _
KW_RETURN      <- 'return'      !IdentCont _
KW_SATISFY     <- 'satisfy'     !IdentCont _
KW_SEND        <- 'send'        !IdentCont _
KW_SNAPSHOT    <- 'snapshot'    !IdentCont _
KW_SPECIALIZES <- 'specializes' !IdentCont _
KW_STAKEHOLDER <- 'stakeholder' !IdentCont _
KW_STANDARD    <- 'standard'    !IdentCont _
KW_STATE       <- 'state'       !IdentCont _
KW_SUBJECT     <- 'subject'     !IdentCont _
KW_SUBSETS     <- 'subsets'     !IdentCont _
KW_SUCCESSION  <- 'succession'  !IdentCont _
KW_TERMINATE   <- 'terminate'   !IdentCont _
KW_THEN        <- 'then'        !IdentCont _
KW_TIMESLICE   <- 'timeslice'   !IdentCont _
KW_TO          <- 'to'          !IdentCont _
KW_TRANSITION  <- 'transition'  !IdentCont _
KW_TRUE        <- 'true'        !IdentCont _
KW_UNTIL       <- 'until'       !IdentCont _
KW_USE         <- 'use'         !IdentCont _
KW_VARIANT     <- 'variant'     !IdentCont _
KW_VARIATION   <- 'variation'   !IdentCont _
KW_VERIFICATION <- 'verification' !IdentCont _
KW_VERIFY      <- 'verify'      !IdentCont _
KW_VIA         <- 'via'         !IdentCont _
KW_VIEW        <- 'view'        !IdentCont _
KW_VIEWPOINT   <- 'viewpoint'   !IdentCont _
KW_WHEN        <- 'when'        !IdentCont _
KW_WHILE       <- 'while'       !IdentCont _
KW_XOR         <- 'xor'         !IdentCont _

# Operators
SEMICOLON <- ';' _
COMMA <- ',' _
LBRACE <- '{' _
RBRACE <- '}' _
LPAREN <- '(' _
RPAREN <- ')' _
LBRACKET <- '[' _
RBRACKET <- ']' _
LANGLE <- '<' ![=] _
RANGLE <- '>' ![=] _
DOT <- '.' ![.?] _
DOTDOT <- '..' _
DOTQ <- '.?' _
HASH <- '#' _
AT <- '@' _
COLON <- ':' ![>:=] _
COLONCOLON <- '::' ![>*] _
COLONCOLON_STAR <- '::*' !'*' _    # For import wildcards like Pkg::* (not Pkg::**)
COLONCOLON_STARSTAR <- '::**' _    # For recursive imports like Pkg::*::**
COLONGT <- ':>' ![>] _
COLONGTGT <- ':>>' _
COLONCOLONGT <- '::>' _
COLONEQ <- ':=' _
EQ <- '=' ![=] _
EQEQ <- '==' ![=] _
EQEQEQ <- '===' _
BANGEQ <- '!=' ![=] _
BANGEQEQ <- '!==' _
BANG <- '!' ![=] _
PLUS <- '+' _
MINUS <- '-' ![>] _
STAR <- '*' ![*] _
STARSTAR <- '**' _
SLASH <- '/' _
PERCENT <- '%' _
CARET <- '^' _
LT <- '<' ![=] _
GT <- '>' ![=] _
LE <- '<=' _
GE <- '>=' _
AMP <- '&' _
PIPE <- '|' _
TILDE <- '~' _
QMARK <- '?' ![?] _
ARROW <- '->' _

# Relationships
SPECIALIZES <- COLONGT / KW_SPECIALIZES
SUBSETS <- COLONGT / KW_SUBSETS
REDEFINES <- COLONGTGT / KW_REDEFINES
REFERENCES <- COLONCOLONGT / KW_REFERENCES
TYPED_BY <- COLON / (KW_DEFINED KW_BY)

# Identification
Identification <- ShortName? IdentificationName?
IdentificationName <- !SpecializationKeyword !KW_ABOUT !KW_LOCALE !KW_FROM !KW_TO !KW_OF !KW_VIA NAME
SpecializationKeyword <- ('redefines' / 'subsets' / 'references' / 'specializes' / 'defined') !IdentCont
ShortName <- LANGLE (NAME / STRING_VALUE) RANGLE

# Visibility
VisibilityIndicator <- KW_PUBLIC / KW_PRIVATE / KW_PROTECTED
MemberPrefix <- PrefixMetadata* VisibilityIndicator?

# Relationship Body
RelationshipBody <- SEMICOLON / LBRACE AnnotatingElement* RBRACE

# Package Body Elements
PackageBodyElement <- _ MemberPrefix (DefinitionElement / AssertConstraintUsage / BindUsage / ShorthandFeatureMember / UsageElement / Import / Alias / FilterPackageMember / AnnotatingElement)
FilterPackageMember <- KW_FILTER OwnedExpression SEMICOLON

# Packages
Package <- PrefixMetadata* KW_PACKAGE Identification PackageBody
LibraryPackage <- KW_STANDARD? KW_LIBRARY PrefixMetadata* KW_PACKAGE Identification PackageBody
PackageBody <- SEMICOLON / LBRACE PackageBodyElement* RBRACE

# Imports
Import <- KW_IMPORT KW_ALL? ImportDeclaration ImportFilter? RelationshipBody
ImportDeclaration <- NamespaceImport / MembershipImport
MembershipImport <- QualifiedName (COLONCOLON STARSTAR)?
NamespaceImport <- QualifiedName (COLONCOLON_STAR COLONCOLON_STARSTAR? / COLONCOLON_STARSTAR)
ImportFilter <- LBRACKET OwnedExpression RBRACKET

# Alias
Alias <- KW_ALIAS (ShortName NAME / ShortName / NAME) KW_FOR QualifiedName RelationshipBody

# Dependency
Dependency <- PrefixMetadata* KW_DEPENDENCY (Identification KW_FROM)? QualifiedName (COMMA QualifiedName)* KW_TO QualifiedName (COMMA QualifiedName)* RelationshipBody

# Metadata
PrefixMetadata <- HASH QualifiedName
MetadataUsage <- AT QualifiedName MetadataUsageTail / AT? KW_METADATA Identification? (COLON QualifiedName)? (KW_ABOUT QualifiedName (COMMA QualifiedName)*)? MetadataBody
MetadataUsageTail <- (KW_ABOUT QualifiedName (COMMA QualifiedName)*)? (MetadataBody / SEMICOLON)
MetadataBody <- SEMICOLON / LBRACE MetadataBodyElement* RBRACE
MetadataBodyElement <- ShorthandFeatureMember / AnnotatingElement / MetadataBodyFeature
MetadataBodyFeature <- MemberPrefix KW_REF? NAME FeatureValue? (SEMICOLON / MetadataBody)

# Annotating Elements
AnnotatingElement <- Comment / Documentation / TextualRepresentation / MetadataUsage
Comment <- (KW_COMMENT Identification (KW_ABOUT QualifiedName (COMMA QualifiedName)*)?)? (KW_LOCALE STRING_VALUE)? RegularComment
Documentation <- KW_DOC Identification (KW_LOCALE STRING_VALUE)? RegularComment
TextualRepresentation <- (KW_REP Identification)? KW_LANGUAGE STRING_VALUE RegularComment

# Definitions
DefinitionElement <- AttributeDefinition / EnumerationDefinition / ItemDefinition / PartDefinition / ConnectionDefinition / FlowDefinition / InterfaceDefinition / PortDefinition / AllocationDefinition / ActionDefinition / StateDefinition / ConstraintDefinition / RequirementDefinition / ConcernDefinition / CalcDefinition / CaseDefinition / AnalysisDefinition / VerificationDefinition / UseCaseDefinition / ViewDefinition / ViewpointDefinition / RenderingDefinition / MetadataDefinition / OccurrenceDefinition / Package / LibraryPackage / Dependency

# Definition Prefixes
DefinitionPrefix <- PrefixMetadata / KW_ABSTRACT / KW_VARIATION / BasicDefinitionPrefix
BasicDefinitionPrefix <- KW_INDIVIDUAL / LifeclassPrefix
LifeclassPrefix <- KW_SNAPSHOT / KW_TIMESLICE
UsagePrefix <- PrefixMetadata / KW_ABSTRACT / KW_VARIATION / KW_VARIANT / BasicUsagePrefix
BasicUsagePrefix <- Direction? RefPrefix? KW_INDIVIDUAL? / KW_INDIVIDUAL
RefPrefix <- KW_REF / KW_READONLY / KW_DERIVED / KW_CONSTANT / KW_END

# Definitions
AttributeDefinition <- DefinitionPrefix* KW_ATTRIBUTE KW_DEF Identification DefinitionSpecializations? DefinitionBody
EnumerationDefinition <- DefinitionPrefix* KW_ENUM KW_DEF Identification DefinitionSpecializations? EnumerationBody
EnumerationBody <- SEMICOLON / LBRACE (EnumeratedValue / AnnotatingElement)* RBRACE
EnumeratedValue <- _ MemberPrefix EnumeratedValueVariant
EnumeratedValueVariant <- KW_ENUM? UsageDeclaration UsageBody / KW_VARIANT UsageElement
OccurrenceDefinition <- DefinitionPrefix* KW_OCCURRENCE KW_DEF Identification DefinitionSpecializations? OccurrenceDefinitionBody
                      / DefinitionPrefix* KW_DEF Identification DefinitionSpecializations? OccurrenceDefinitionBody
OccurrenceDefinitionBody <- SEMICOLON / LBRACE OccurrenceDefinitionMember* RBRACE
# ThenMessageUsage for 'then message x of T' syntax in occurrences
ThenMessageUsage <- KW_THEN MessageUsage
OccurrenceDefinitionMember <- MemberPrefix (OccurrenceDefinitionElement / PortionUsage / ThenMessageUsage / MessageUsage / BindUsage / EventOccurrenceUsage / EventUsage / ShorthandFeatureMember / SuccessionMember / StructureUsageElement / OccurrenceUsage / Import / Alias / AnnotatingElement)
OccurrenceDefinitionElement <- DefinitionElement / BehaviorUsageElement
ItemDefinition <- DefinitionPrefix* KW_ITEM KW_DEF Identification DefinitionSpecializations? DefinitionBody
PartDefinition <- DefinitionPrefix* KW_PART KW_DEF Identification DefinitionSpecializations? DefinitionBody
ConnectionDefinition <- DefinitionPrefix* KW_CONNECTION KW_DEF Identification DefinitionSpecializations? DefinitionBody
FlowDefinition <- DefinitionPrefix* KW_FLOW KW_DEF Identification DefinitionSpecializations? DefinitionBody
InterfaceDefinition <- DefinitionPrefix* KW_INTERFACE KW_DEF Identification DefinitionSpecializations? InterfaceBody
InterfaceBody <- SEMICOLON / LBRACE InterfaceBodyElement* RBRACE
InterfaceBodyElement <- MemberPrefix (EndMember / DefinitionElement / InterfaceUsageElement / AnnotatingElement)
InterfaceUsageElement <- UsageElement
PortDefinition <- DefinitionPrefix* KW_PORT KW_DEF Identification DefinitionSpecializations? PortDefinitionBody
PortDefinitionBody <- SEMICOLON / LBRACE (PortDefinitionMember / ConjugatedPortDefinitionMember)* RBRACE
PortDefinitionMember <- MemberPrefix (DefinitionElement / PortUsageElement / Alias / AnnotatingElement)
ConjugatedPortDefinitionMember <- MemberPrefix KW_PORT (TILDE NAME SEMICOLON / ConjugatedPortDeclaration)
ConjugatedPortDeclaration <- Identification TILDE QualifiedName SEMICOLON
PortUsageElement <- ParameterUsage / UsageElement
AllocationDefinition <- DefinitionPrefix* KW_ALLOCATION KW_DEF Identification DefinitionSpecializations? DefinitionBody
ActionDefinition <- DefinitionPrefix* KW_ACTION KW_DEF Identification DefinitionSpecializations? ActionBody
ActionBody <- SEMICOLON / LBRACE ActionBodyItem* RBRACE
ActionBodyItem <- MemberPrefix ActionBodyElement
ActionBodyElement <- DefinitionElement / BindUsage / TerminateAction / SuccessionUsage / StateUsage / CalcUsage / ShorthandFeatureMember / AssertConstraintUsage / VariantUsage / ActionUsageElement / AnnotatingElement / Import / Alias / StructureUsageElement
StateDefinition <- DefinitionPrefix* KW_STATE KW_DEF Identification DefinitionSpecializations? StateBody
StateBody <- SEMICOLON / LBRACE StateBodyItem* RBRACE
StateBodyItem <- MemberPrefix StateBodyElement
StateBodyElement <- DefinitionElement / AssertConstraintUsage / StateUsageElement / AnnotatingElement / Import / Alias
StateUsageElement <- EntryAction / ExitAction / DoAction / EntryTransition / AcceptTransition / StateUsage / ExhibitStateUsage / TransitionUsage / SuccessionUsage / SuccessionMember / ConstraintUsage / ActionUsageElement
AcceptTransition <- KW_ACCEPT TriggerActionBody? EffectAction? TransitionEndAction
EntryAction <- KW_ENTRY (KW_ACTION UsageDeclaration ActionBody / KW_ACTION? UsageDeclaration SEMICOLON / AssignmentAction / SendAction / PerformActionUsage / QualifiedName FeatureChain? ActionBody / ActionBody)
ExitAction <- KW_EXIT (KW_ACTION UsageDeclaration ActionBody / KW_ACTION? UsageDeclaration SEMICOLON / AssignmentAction / SendAction / PerformActionUsage / QualifiedName FeatureChain? ActionBody / ActionBody)
DoAction <- KW_DO (KW_ACTION UsageDeclaration ActionBody / AssignmentAction / SendAction / PerformActionUsage / QualifiedName FeatureChain? (SEMICOLON / ActionBody) / ActionBody)
# perform action name; OR perform name;
# perform action name { } OR perform name.feature { } OR perform name; OR perform name redefines other;
# variation perform action doXorY { variant action doX; variant action doY; }
PerformActionUsage <- KW_VARIATION? KW_PERFORM (KW_ACTION UsageDeclaration ActionBody / QualifiedName FeatureChain? FeatureSpecialization* ActionBody)
EntryTransition <- KW_ENTRY? TransitionDeclaration TransitionBody
ConstraintDefinition <- DefinitionPrefix* KW_CONSTRAINT KW_DEF Identification DefinitionSpecializations? ConstraintBody
ConstraintBody <- SEMICOLON / LBRACE ConstraintBodyElement* ResultExpression? RBRACE
ConstraintBodyElement <- MemberPrefix (DefinitionElement / ConstraintUsageElement / AnnotatingElement)
RequirementDefinition <- DefinitionPrefix* KW_REQUIREMENT KW_DEF Identification DefinitionSpecializations? RequirementBody
RequirementBody <- SEMICOLON / LBRACE RequirementBodyItem* RBRACE
RequirementBodyItem <- MemberPrefix RequirementBodyElement
RequirementBodyElement <- DefinitionElement / VariantUsage / ReturnUsage / ReferenceUsage / RequirementUsageElement / ShorthandFeatureMember / SuccessionMember / AnnotatingElement / Import / Alias
# Variant can be: variant name;  OR  variant action name;  OR  variant perform name;
VariantUsage <- KW_VARIANT KW_PERFORM QualifiedName FeatureChain? SEMICOLON
              / KW_VARIANT KW_ACTION UsageDeclaration UsageBody
              / KW_VARIANT UsageDeclaration UsageBody
ConcernDefinition <- DefinitionPrefix* KW_CONCERN KW_DEF Identification DefinitionSpecializations? RequirementBody
CalcDefinition <- DefinitionPrefix* KW_CALC KW_DEF Identification DefinitionSpecializations? CalcBody
CalcBody <- SEMICOLON / LBRACE CalcBodyItem* ResultExpression? RBRACE
CalcBodyItem <- MemberPrefix CalcBodyElement
CalcBodyElement <- DefinitionElement / AssertConstraintUsage / CalcUsageElement / AnnotatingElement / Import / Alias / StructureUsageElement
CaseDefinition <- DefinitionPrefix* KW_CASE KW_DEF Identification DefinitionSpecializations? CaseBody
CaseBody <- SEMICOLON / LBRACE CaseBodyItem* ResultExpression? RBRACE
CaseBodyItem <- MemberPrefix CaseBodyElement
CaseBodyElement <- DefinitionElement / CaseUsageElement / AnnotatingElement / Import / Alias / StructureUsageElement
AnalysisDefinition <- DefinitionPrefix* KW_ANALYSIS KW_DEF Identification DefinitionSpecializations? CaseBody
VerificationDefinition <- DefinitionPrefix* KW_VERIFICATION KW_DEF Identification DefinitionSpecializations? RequirementBody
UseCaseDefinition <- DefinitionPrefix* KW_USE KW_CASE KW_DEF Identification DefinitionSpecializations? CaseBody
ViewDefinition <- DefinitionPrefix* KW_VIEW KW_DEF Identification DefinitionSpecializations? ViewBody
ViewBody <- SEMICOLON / LBRACE ViewBodyElement* RBRACE
ViewBodyElement <- MemberPrefix (DefinitionElement / ViewUsageElement / Import / Alias / FilterPackageMember / AnnotatingElement)
ViewpointDefinition <- DefinitionPrefix* KW_VIEWPOINT KW_DEF Identification DefinitionSpecializations? RequirementBody
RenderingDefinition <- DefinitionPrefix* KW_RENDERING KW_DEF Identification DefinitionSpecializations? ViewBody
MetadataDefinition <- DefinitionPrefix* KW_METADATA KW_DEF Identification DefinitionSpecializations? DefinitionBody

# Definition Body
DefinitionBody <- SEMICOLON / LBRACE DefinitionBodyItem* RBRACE
DefinitionBodyItem <- MemberPrefix (EndMember / DefinitionElement / AssertConstraintUsage / BindUsage / ShorthandFeatureMember / SuccessionMember / UsageElement / Import / Alias / AnnotatingElement)
DefinitionSpecializations <- DefinitionSpecialization+
DefinitionSpecialization <- SPECIALIZES QualifiedName (COMMA QualifiedName)*

# Usages
UsageElement <- AssertSatisfyUsage / SatisfyUsage / ExhibitStateUsage / PerformActionUsage / MessageUsage / ReferenceUsage / AttributeUsage / EnumerationUsage / ItemUsage / PartUsage / ConnectionUsage / FlowUsage / InterfaceUsage / PortUsage / AllocationUsage / ActionUsage / StateUsage / ConstraintUsage / RequirementUsage / ConcernUsage / CalcUsage / CaseUsage / AnalysisUsage / VerificationUsage / UseCaseUsage / ViewUsage / ViewpointUsage / RenderingUsage / SuccessionUsage / PortionUsage / SubjectUsage / ActorUsage / StakeholderUsage / IncludeUseCaseUsage / EventOccurrenceUsage / EventUsage / OccurrenceUsage
PortionUsage <- BasicUsagePrefix* KW_INDIVIDUAL? PortionKind PortionUsageKind? UsageDeclaration UsageBody
PortionKind <- KW_SNAPSHOT / KW_TIMESLICE
PortionUsageKind <- KW_ITEM / KW_PART / KW_OCCURRENCE / KW_ATTRIBUTE
# Succession: the optional UsageDeclaration can't consume 'first' keyword
SuccessionUsage <- UsagePrefix* KW_SUCCESSION (!KW_FIRST UsageDeclaration)? SuccessionFirstPart? SuccessionUsageBody
SuccessionFirstPart <- KW_FIRST ConnectorEndMember (KW_THEN ConnectorEndMember)?
SuccessionUsageBody <- DecisionBranches / UsageBody
DecisionBranches <- DecisionBranch+
DecisionBranch <- KW_IF OwnedExpression KW_THEN ConnectorEndMember SEMICOLON / KW_ELSE ConnectorEndMember SEMICOLON

# Reference usage (standalone ref)
# Supports: ref name, ref state name, ref action name, ref requirement name, etc.
RefBehavioralKeyword <- KW_STATE / KW_ACTION / KW_OCCURRENCE / KW_CASE
                      / KW_REQUIREMENT / KW_MESSAGE / KW_CALC / KW_CONSTRAINT
                      / KW_VIEWPOINT / KW_CONCERN / KW_VIEW / KW_RENDERING
ReferenceUsage <- Direction? KW_REF PrefixMetadata* RefBehavioralKeyword? UsageDeclaration UsageBody
                / Direction? RefPrefix PrefixMetadata* UsageDeclaration UsageBody
StructureUsageElement <- AttributeUsage / ItemUsage / PartUsage / PortUsage / ConnectionUsage / FlowUsage / InterfaceUsage
BehaviorUsageElement <- ActionUsage / StateUsage / ConstraintUsage / CalcUsage
ActionUsageElement <- ParameterUsage / ActionUsage / PerformActionUsage / SendAction / AcceptAction / AssignmentAction / IfAction / WhileLoop / ForLoop / ControlNode / SuccessionMember
ConstraintUsageElement <- ParameterUsage / ReturnUsage / ConstraintUsage
RequirementUsageElement <- SubjectUsage / ActorUsage / StakeholderUsage / AssumeConstraint / RequireConstraint / AssertSatisfyUsage / SatisfyUsage / RequirementUsage / ConcernUsage / ConstraintUsage / ObjectiveUsage / FrameUsage / VerifyRequirementUsage / RequirementReference / VerificationUsage / CalcUsage / ActionUsage / AllocationUsage / ParameterUsage / StructureUsageElement
CalcUsageElement <- CalcUsage / ReturnUsage / ActionUsageElement / ConstraintUsage / StructureUsageElement
CaseUsageElement <- SubjectUsage / ActorUsage / StakeholderUsage / ObjectiveUsage / IncludeUseCaseUsage / UseCaseUsage / AnalysisUsage / VerificationUsage / AssertConstraintUsage / CalcUsageElement
IncludeUseCaseUsage <- KW_INCLUDE (KW_USE KW_CASE UsageDeclaration / QualifiedName FeatureChain? Multiplicity?) UsageBody
ViewUsageElement <- RenderUsage / ViewUsage / ViewpointUsage / RenderingUsage / ExposeUsage / RequireConstraint / SatisfyUsage / StructureUsageElement
ExposeUsage <- KW_EXPOSE (QualifiedName (COLONCOLON_STAR COLONCOLON_STARSTAR? / COLONCOLON_STARSTAR) / QualifiedName FeatureChain?) ImportFilter? UsageBody

# Usages
AttributeUsage <- UsagePrefix* KW_ATTRIBUTE UsageDeclaration UsageBody
EnumerationUsage <- UsagePrefix* KW_ENUM UsageDeclaration UsageBody
OccurrenceUsage <- UsagePrefix* KW_OCCURRENCE UsageDeclaration OccurrenceUsageBody
                 / UsagePrefix+ UsageDeclaration OccurrenceUsageBody
EventOccurrenceUsage <- UsagePrefix* KW_EVENT KW_OCCURRENCE UsageDeclaration OccurrenceUsageBody
# Event can have feature chain with redefines: event x.y[1] :>> z;
# Or just reference: event name.feature;
EventUsage <- UsagePrefix* KW_EVENT QualifiedName FeatureChain? Multiplicity? REDEFINES QualifiedName SEMICOLON
            / UsagePrefix* KW_EVENT QualifiedName FeatureChain? Multiplicity SEMICOLON
            / UsagePrefix* KW_EVENT QualifiedName FeatureChain SEMICOLON
            / UsagePrefix* KW_EVENT QualifiedName SEMICOLON
            / UsagePrefix* KW_EVENT UsageDeclaration UsageBody
OccurrenceUsageBody <- SEMICOLON / LBRACE OccurrenceUsageMember* RBRACE
OccurrenceUsageMember <- MemberPrefix (OccurrenceDefinitionElement / AssertConstraintUsage / PortionUsage / EventOccurrenceUsage / EventUsage / OccurrenceUsage / MessageUsage / BindUsage / ShorthandFeatureMember / SuccessionMember / StructureUsageElement / AnnotatingElement)
ItemUsage <- UsagePrefix* KW_ITEM UsageDeclaration UsageBody
PartUsage <- UsagePrefix* KW_PART UsageDeclaration UsageBody
ConnectionUsage <- UsagePrefix* KW_CONNECTION UsageDeclaration? (KW_CONNECT ConnectionPart)? UsageBody / UsagePrefix* KW_CONNECT ConnectionPart UsageBody
ConnectionPart <- BinaryConnectorPart / NaryConnectorPart
BinaryConnectorPart <- ConnectorEndMember KW_TO ConnectorEndMember
NaryConnectorPart <- LPAREN ConnectorEndMember (COMMA ConnectorEndMember)+ RPAREN
ConnectorEndMember <- (NAME REFERENCES)? Multiplicity? QualifiedName FeatureChain? (REFERENCES QualifiedName FeatureChain?)?
# Flow can be: flow name of Type from x to y; OR flow x to y; OR flow name;
FlowUsage <- UsagePrefix* KW_SUCCESSION? KW_FLOW FlowBody
# Restructured to avoid partial match issues with optional FlowConnectionPart
# Supports: flow : Type of Payload from x to y; OR flow name of Payload from x to y;
FlowBody <- (COLONGTGT / COLONGT) QualifiedName FlowConnectionPart UsageBody
          / FlowConnectionPart UsageBody
          / UsageDeclaration (KW_OF NAME COLON QualifiedName Multiplicity? / KW_OF QualifiedName Multiplicity?)? (FlowConnectionPart UsageBody / UsageBody)
FlowConnectionPart <- KW_FROM FlowEndMember KW_TO FlowEndMember / FlowEndMember (KW_TO / KW_FROM) FlowEndMember
FlowEndMember <- QualifiedName FeatureChain?
# Interface: anonymous connection, or named with optional connect keyword
InterfaceUsage <- UsagePrefix* KW_INTERFACE &(ConnectorEndMember KW_TO) ConnectionPart InterfaceBody
                / UsagePrefix* KW_INTERFACE UsageDeclaration? (KW_CONNECT ConnectionPart)? InterfaceBody
PortUsage <- UsagePrefix* KW_PORT UsageDeclaration UsageBody
AllocationUsage <- UsagePrefix* KW_ALLOCATION UsageDeclaration? AllocationPart? UsageBody / UsagePrefix* KW_ALLOCATE AllocationPart UsageBody
AllocationPart <- KW_ALLOCATE? (BinaryConnectorPart / NaryConnectorPart)
# Action can be: action name; OR action name { } OR action name send/accept/while/for ...
# Also supports ref action name (params) :>> other;
ActionUsage <- UsagePrefix* KW_ACTION ActionDeclaration ActionUsageBody
ActionDeclaration <- Identification? ActionParameterList? UsageSpecializations? FeatureValue?
ActionParameterList <- LPAREN ActionParameter (COMMA ActionParameter)* RPAREN
ActionParameter <- Direction? KW_REF? KW_ITEM? NAME (TypedBy / Subsets)? (EQ OwnedExpression)?
ActionUsageBody <- KW_TERMINATE SEMICOLON / KW_SEND SendActionTail / KW_ACCEPT AcceptActionTail / ActionAssignBody / ActionWhileBody / ActionForBody / ActionBody
ActionAssignBody <- KW_ASSIGN QualifiedName FeatureChain? COLONEQ OwnedExpression SEMICOLON
AcceptActionTail <- QualifiedName (COLON QualifiedName)? (KW_VIA QualifiedName FeatureChain?)? (ActionBody / SEMICOLON)
# Send can have expression or not: send expr via/to...; OR send via/to...;
SendActionTail <- (!KW_VIA !KW_TO OwnedExpression)? (KW_VIA QualifiedName FeatureChain?)? (KW_TO QualifiedName FeatureChain?)? (ActionBody / SEMICOLON)
ActionWhileBody <- KW_WHILE OwnedExpression ActionBodyParameter (KW_UNTIL OwnedExpression)? SEMICOLON?
ActionForBody <- KW_FOR NAME ForVariableSpec (ActionBodyParameter / ActionBody) SEMICOLON?
ForVariableSpec <- COLON QualifiedName (KW_IN OwnedExpression)? / KW_IN OwnedExpression
StateUsage <- UsagePrefix* KW_PARALLEL? KW_STATE UsageDeclaration KW_PARALLEL? StateBody
ExhibitStateUsage <- KW_EXHIBIT KW_STATE? QualifiedName FeatureChain KW_PARALLEL? ExhibitStateBody
                   / KW_EXHIBIT KW_STATE? UsageDeclaration KW_PARALLEL? ExhibitStateBody
ExhibitStateBody <- SEMICOLON / StateBody
ConstraintUsage <- UsagePrefix* KW_CONSTRAINT UsageDeclaration ConstraintBody
RequirementUsage <- UsagePrefix* KW_REQUIREMENT UsageDeclaration RequirementBody
ConcernUsage <- UsagePrefix* KW_CONCERN UsageDeclaration RequirementBody
CalcUsage <- UsagePrefix* KW_CALC UsageDeclaration CalcBody
CaseUsage <- UsagePrefix* KW_CASE UsageDeclaration CaseBody
AnalysisUsage <- UsagePrefix* KW_ANALYSIS UsageDeclaration CaseBody
VerificationUsage <- UsagePrefix* KW_VERIFICATION UsageDeclaration RequirementBody
UseCaseUsage <- UsagePrefix* KW_USE KW_CASE UsageDeclaration CaseBody
ViewUsage <- UsagePrefix* KW_VIEW UsageDeclaration ViewBody
ViewpointUsage <- UsagePrefix* KW_VIEWPOINT UsageDeclaration RequirementBody
RenderingUsage <- UsagePrefix* KW_RENDERING UsageDeclaration ViewBody

# Specialized Usages
ParameterKind <- KW_ATTRIBUTE / KW_ITEM / KW_PART / KW_REQUIREMENT / KW_OCCURRENCE
               / KW_EVENT KW_OCCURRENCE / KW_ACTION / KW_STATE / KW_CASE
               / KW_MESSAGE / KW_CONSTRAINT / KW_CALC
ParameterUsage <- Direction? UsagePrefix* ParameterKind? UsageDeclaration UsageBody
Direction <- KW_IN / KW_OUT / KW_INOUT
SubjectUsage <- KW_SUBJECT (UsageDeclaration UsageBody / FeatureValue SEMICOLON)
ActorUsage <- KW_ACTOR (UsageDeclaration UsageBody / FeatureValue SEMICOLON)
StakeholderUsage <- KW_STAKEHOLDER (UsageDeclaration UsageBody / FeatureValue SEMICOLON)
ObjectiveUsage <- KW_OBJECTIVE UsageDeclaration RequirementBody
FrameUsage <- KW_FRAME (KW_CONCERN / KW_REQUIREMENT)? UsageDeclaration RequirementBody
RequirementReference <- RequirementConstraintKind UsageDeclaration? UsageBody
RequirementConstraintKind <- KW_ASSUME KW_CONSTRAINT? / KW_REQUIRE KW_CONSTRAINT?
VerifyRequirementUsage <- KW_VERIFY KW_REQUIREMENT? UsageDeclaration? UsageBody
                        / KW_VERIFY QualifiedName FeatureChain UsageBody
ReturnUsage <- KW_RETURN ReturnUsageKind? UsageDeclaration UsageBody
ReturnUsageKind <- KW_ATTRIBUTE / KW_PART / KW_ITEM / KW_REF
RenderUsage <- KW_RENDER KW_RENDERING? UsageDeclaration UsageBody

# Action Elements
SendAction <- KW_SEND OwnedExpression (KW_VIA QualifiedName FeatureChain?)? (KW_TO QualifiedName FeatureChain?)? SEMICOLON
AcceptAction <- KW_ACCEPT AcceptParameterPart (ActionBody / SEMICOLON)
AcceptParameterPart <- PayloadParameter (KW_VIA QualifiedName FeatureChain?)?
PayloadParameter <- TriggerPart / Identification? PayloadFeatureSpec? TriggerPart?
PayloadFeatureSpec <- TypedBy
TriggerPart <- TriggerKind OwnedExpression
TriggerKind <- KW_AT / KW_AFTER / KW_WHEN
AssignmentAction <- KW_ASSIGN QualifiedName FeatureChain? COLONEQ OwnedExpression SEMICOLON
IfAction <- KW_IF OwnedExpression IfThenPart IfElsePart?
IfThenPart <- KW_THEN? (ActionBodyParameter / ActionBodyElement)
IfElsePart <- KW_ELSE (IfAction / ActionBodyParameter / ActionBodyElement)
ActionBodyParameter <- (KW_ACTION UsageDeclaration?)? LBRACE ActionBodyItem* RBRACE
WhileLoop <- KW_WHILE OwnedExpression (KW_UNTIL OwnedExpression)? (ActionBodyParameter / ActionBody)
           / KW_LOOP (ActionBodyParameter / ActionBody) KW_UNTIL OwnedExpression SEMICOLON
           / KW_LOOP (ActionBodyParameter / ActionBody)
ForLoop <- KW_FOR NAME ForVariableSpec (ActionBodyParameter / ActionBody)
ControlNode <- MergeNode / DecisionNode / JoinNode / ForkNode
MergeNode <- KW_MERGE UsageDeclaration? ActionBody
DecisionNode <- KW_DECIDE UsageDeclaration? ActionBody
JoinNode <- KW_JOIN UsageDeclaration? ActionBody
ForkNode <- KW_FORK UsageDeclaration? ActionBody
# Guarded succession: first x if cond then y;
GuardedSuccession <- KW_IF OwnedExpression KW_THEN QualifiedName FeatureChain? SEMICOLON
SuccessionMember <- KW_FIRST QualifiedName FeatureChain? GuardedSuccession
                  / KW_FIRST SuccessionBody
                  / KW_THEN ThenTarget
                  / QualifiedName FeatureChain? KW_THEN SuccessionBody
ThenTarget <- SuccessionInlineAction / QualifiedName ActionBody / QualifiedName FeatureChain? SEMICOLON / ActionBody
# Allow visibility indicator (public/private/protected) before inline actions
SuccessionInlineAction <- VisibilityIndicator? (AcceptActionUsage / AcceptAction / SendAction / AssignmentAction / IfAction / WhileLoop / ForLoop / ControlNode / IncludeUseCaseUsage / UseCaseUsage / PortionUsage / StateUsage / EventOccurrenceUsage / EventUsage / OccurrenceUsage / PerformActionUsage / ActionUsage)
AcceptActionUsage <- KW_ACTION KW_ACCEPT NAME TypedBy ActionBody
                   / KW_ACTION KW_ACCEPT NAME TypedBy SEMICOLON
SuccessionBody <- QualifiedName FeatureChain? KW_THEN QualifiedName FeatureChain? ActionBody
                / QualifiedName FeatureChain? (KW_THEN QualifiedName FeatureChain?)? SEMICOLON
                / QualifiedName? ActionBody

# Transition Elements
TransitionUsage <- KW_TRANSITION TransitionDeclaration? TransitionBody
TransitionDeclaration <- KW_FIRST? TransitionName? (COLON QualifiedName)? TransitionSourceTarget?
TransitionName <- !KW_ACCEPT !KW_FIRST !KW_THEN !KW_DO NAME
TransitionSourceTarget <- KW_FIRST? TransitionTarget (KW_THEN TransitionTarget)?
TransitionTarget <- !KW_ACCEPT !KW_THEN !KW_DO QualifiedName FeatureChain?
TransitionBody <- SEMICOLON / TransitionActionBody
TransitionActionBody <- TriggerAction* GuardAction? EffectAction? TransitionEndAction
GuardAction <- KW_IF OwnedExpression
TriggerAction <- (KW_ACCEPT / KW_FIRST) TriggerActionBody?
TriggerActionBody <- (AcceptPayload (KW_VIA QualifiedName FeatureChain?)?)? TriggerPart?
AcceptPayload <- !TriggerKind NAME (COLON QualifiedName)?
EffectAction <- KW_DO (EffectSendAction / KW_ACTION NAME / KW_ACTION ActionBody / NAME / ActionBody)
EffectSendAction <- KW_SEND OwnedExpression (KW_VIA QualifiedName FeatureChain?)? (KW_TO QualifiedName FeatureChain?)?
TransitionEndAction <- KW_THEN (QualifiedName FeatureChain? ActionBody / QualifiedName FeatureChain? SEMICOLON / ActionBody)

# Usage Declaration
UsageDeclaration <- Identification? UsageSpecializations? FeatureValue?
UsageSpecializations <- UsageSpecialization+
UsageSpecialization <- Multiplicity / TypedBy / Subsets / Redefines / References / Crosses
TypedBy <- TYPED_BY TILDE? QualifiedName (COMMA QualifiedName)*
Subsets <- SUBSETS QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)*
Redefines <- REDEFINES QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)*
References <- REFERENCES QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)*
Crosses <- KW_CROSSES QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)*
FeatureSpecialization <- Multiplicity / TypedBy / Subsets / Redefines / References / Crosses

# Feature Value
FeatureValue <- (EQ / COLONEQ / KW_DEFAULT (EQ / COLONEQ)?) OwnedExpression

# Multiplicity
Multiplicity <- LBRACKET MultiplicityBounds? RBRACKET OrderedNonunique?
MultiplicityBounds <- OwnedExpression (DOTDOT (OwnedExpression / STAR))? / STAR
OrderedNonunique <- (KW_ORDERED KW_NONUNIQUE?) / (KW_NONUNIQUE KW_ORDERED?)

# Usage Body
UsageBody <- SEMICOLON / LBRACE UsageBodyItem* RBRACE
UsageBodyItem <- MemberPrefix (DefinitionElement / AssertConstraintUsage / BindUsage / ShorthandFeatureMember / SuccessionMember / VariantUsage / RequireConstraint / AssumeConstraint / UsageElement / Import / Alias / AnnotatingElement)

# Shorthand feature member like :>> name = value; or :> name = value; or :>> name : Type { }
# Also supports comma-separated targets: :>> a, b;
ShorthandFeatureMember <- (COLONGTGT / COLONGT) QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)* (COLON QualifiedName Multiplicity?)? FeatureValue? UsageBody
                        / KW_REDEFINES QualifiedName FeatureChain? (COMMA QualifiedName FeatureChain?)* FeatureValue? UsageBody
                        / ImplicitInvocation
                        / ImplicitShorthand
# Implicit invocation like P::Q(args) as a body element
# Must not match usage keywords that take arguments like connect, allocate
ImplicitInvocation <- !SpecializationKeyword !UsageKeyword QualifiedName ArgumentList
UsageKeyword <- ('connect' / 'allocate' / 'include' / 'perform' / 'exhibit' / 'send' / 'accept') !IdentCont
ImplicitShorthand <- !SpecializationKeyword NAME FeatureChain? FeatureSpecialization* FeatureValue? UsageBody

# === BIND STATEMENT ===
# Supports: bind x = y; or binding [mult] bind [mult] x = [mult] y;
BindUsage <- KW_BINDING Multiplicity? KW_BIND Multiplicity? QualifiedName FeatureChain? EQ Multiplicity? QualifiedName FeatureChain? RelationshipBody
           / KW_BIND Multiplicity? QualifiedName FeatureChain? EQ Multiplicity? QualifiedName FeatureChain? RelationshipBody

# === ASSERT CONSTRUCTS ===
AssertConstraintUsage <- KW_ASSERT KW_NOT? AssertConstraintBody
AssertConstraintBody <- KW_CONSTRAINT UsageDeclaration? ConstraintBody
                      / UsageDeclaration ConstraintBody

# === SATISFY USAGE ===
# Pattern 1: satisfy [requirement] usageDecl by target body
# Pattern 2: satisfy qualifiedName by target body (reference existing requirement)
SatisfyUsage <- KW_NOT? KW_SATISFY KW_REQUIREMENT? UsageDeclaration (KW_BY QualifiedName FeatureChain?)? UsageBody
              / KW_NOT? KW_SATISFY QualifiedName FeatureChain? (KW_BY QualifiedName FeatureChain?)? UsageBody
AssertSatisfyUsage <- KW_ASSERT KW_NOT? KW_SATISFY KW_REQUIREMENT? UsageDeclaration KW_BY QualifiedName FeatureChain? UsageBody
                    / KW_ASSERT KW_NOT? KW_SATISFY QualifiedName FeatureChain? KW_BY QualifiedName FeatureChain? UsageBody

# === ASSUME/REQUIRE IN REQUIREMENTS ===
AssumeConstraint <- KW_ASSUME PrefixMetadata* KW_CONSTRAINT? UsageDeclaration ConstraintBody
# RequireConstraint: with 'constraint' keyword uses ConstraintBody, otherwise uses UsageBody
# Also supports feature chain: require name.feature;
RequireConstraint <- KW_REQUIRE PrefixMetadata* KW_CONSTRAINT UsageDeclaration? ConstraintBody
                   / KW_REQUIRE PrefixMetadata* QualifiedName FeatureChain UsageBody
                   / KW_REQUIRE PrefixMetadata* UsageDeclaration UsageBody

# === END MEMBER FOR CONNECTIONS ===
# End member can have identification before multiplicity: end inCart[0..1] item cart: Type;
EndMember <- KW_END Identification? Multiplicity? KW_REF? (KW_PORT / KW_ITEM / KW_PART / KW_OCCURRENCE / KW_ACTION)? UsageDeclaration UsageBody

# === MESSAGE USAGE ===
# Message can have 'of' for payload type: message name of Type from x to y;
# Also supports typed-only: message : Type from x to y;
MessageUsage <- UsagePrefix* KW_MESSAGE (TypedBy / Identification? UsageSpecializations? (KW_OF NAME (COLON QualifiedName)? Multiplicity?)? FeatureValue?) MessageFlowPart? UsageBody
MessageFlowPart <- KW_FROM FlowEndMember KW_TO FlowEndMember / FlowConnectionPart

# === TERMINATE ACTION ===
TerminateAction <- KW_TERMINATE QualifiedName FeatureChain? SEMICOLON
                 / KW_TERMINATE SEMICOLON

# === RESULT EXPRESSION (bare expression in bodies) ===
ResultExpression <- OwnedExpression

# Expressions
OwnedExpression <- ConditionalExpression
# Support: 1) postfix: expr if condition else expr  2) prefix: if condition [?] then-expr [else else-expr]
# Use ConditionalExpression for else to allow else-if chaining
# The ? is optional between condition and then-expr in prefix form
ConditionalExpression <- KW_IF ImplicationExpression QMARK? ImplicationExpression (KW_ELSE ConditionalExpression)? / ImplicationExpression (KW_IF ImplicationExpression KW_ELSE ConditionalExpression)?
ImplicationExpression <- OrExpression (KW_IMPLIES OrExpression)?
OrExpression <- XorExpression (OrOperator XorExpression)*
OrOperator <- PIPE / KW_OR
XorExpression <- AndExpression (XorOperator AndExpression)*
XorOperator <- KW_XOR
AndExpression <- EqualityExpression (AndOperator EqualityExpression)*
AndOperator <- AMP / KW_AND
EqualityExpression <- ClassificationExpression (EqualityOperator ClassificationExpression)?
EqualityOperator <- EQEQ / BANGEQ / EQEQEQ / BANGEQEQ
ClassificationExpression <- RelationalExpression (ClassificationOperator QualifiedName)?
ClassificationOperator <- KW_HASTYPE / KW_ISTYPE / AT / KW_AS
RelationalExpression <- RangeExpression (RelationalOperator RangeExpression)?
RelationalOperator <- LT / GT / LE / GE
RangeExpression <- AdditiveExpression (DOTDOT AdditiveExpression)?
AdditiveExpression <- MultiplicativeExpression (AdditiveOperator MultiplicativeExpression)*
AdditiveOperator <- PLUS / MINUS
MultiplicativeExpression <- ExponentiationExpression (MultiplicativeOperator ExponentiationExpression)*
MultiplicativeOperator <- STAR / SLASH / PERCENT
ExponentiationExpression <- UnaryExpression ((STARSTAR / CARET) UnaryExpression)?
UnaryExpression <- UnaryOperator? ExtentExpression
UnaryOperator <- PLUS / MINUS / BANG / KW_NOT / TILDE
ExtentExpression <- (KW_ALL ExtentExpression) / SequenceExpression
SequenceExpression <- BracketExpression (SequenceTail)*
SequenceTail <- COMMA UnaryExpression
# BracketExpression with optional collection operators like ->forAll {} and index operator #() and select .?{}
# Note: Inside brackets we use OwnedExpression to support unit expressions like [N * m]
# FeatureChain can be followed by ArgumentList for method calls like a.b(args)
BracketExpression <- PrimaryExpression FeatureChain? ArgumentList? QMARK? SelectOperator? IndexExpression? (LBRACKET OwnedExpression? RBRACKET)? FeatureChain? CollectionOperator* IndexExpression?
SelectOperator <- DOTQ CollectionBody
IndexExpression <- HASH LPAREN OwnedExpression RPAREN
CollectionOperator <- ARROW NAME (CollectionBody / ArgumentList)
CollectionBody <- LBRACE AnnotatingElement* CollectionBodyParameter* OwnedExpression? RBRACE
CollectionBodyParameter <- VisibilityIndicator? KW_IN? KW_REF? (KW_ATTRIBUTE / KW_PART / KW_ITEM)? NAME (TypedBy / Subsets)? (EQ OwnedExpression)? (SEMICOLON / CollectionParameterBody)
CollectionParameterBody <- LBRACE (ShorthandFeatureMember / AnnotatingElement)* RBRACE
PrimaryExpression <- BodyExpression / LPAREN OwnedExpression? RPAREN / NewExpression / SelectExpression / CollectExpression / NullExpression / MetadataAccessExpression / MetadataReferenceExpression / MetaExpression / InvocationExpression / NameExpression / LiteralExpression
MetadataReferenceExpression <- AT QualifiedName
MetaExpression <- QualifiedName KW_META QualifiedName
BodyExpression <- LBRACE OwnedExpression RBRACE
NewExpression <- KW_NEW QualifiedName ArgumentList? FeatureChain?
SelectExpression <- DOT QMARK? SequenceExpression
CollectExpression <- DOTQ SequenceExpression
NullExpression <- KW_NULL
MetadataAccessExpression <- QualifiedName DOT KW_METADATA
InvocationExpression <- QualifiedName ArgumentList FeatureChain?
ArgumentList <- LPAREN ArgumentListItems? RPAREN
ArgumentListItems <- Argument (COMMA Argument)*
Argument <- (NAME EQ)? ArgumentExpression
ArgumentExpression <- ConditionalArgumentExpression
ConditionalArgumentExpression <- OrArgumentExpression (KW_IF OrArgumentExpression KW_ELSE OrArgumentExpression)?
OrArgumentExpression <- XorArgumentExpression (OrOperator XorArgumentExpression)*
XorArgumentExpression <- AndArgumentExpression (XorOperator AndArgumentExpression)*
AndArgumentExpression <- EqualityArgumentExpression (AndOperator EqualityArgumentExpression)*
EqualityArgumentExpression <- ClassificationArgumentExpression (EqualityOperator ClassificationArgumentExpression)?
ClassificationArgumentExpression <- RelationalArgumentExpression (ClassificationOperator QualifiedName)?
RelationalArgumentExpression <- RangeArgumentExpression (RelationalOperator RangeArgumentExpression)?
RangeArgumentExpression <- AdditiveArgumentExpression (DOTDOT AdditiveArgumentExpression)?
AdditiveArgumentExpression <- MultiplicativeArgumentExpression (AdditiveOperator MultiplicativeArgumentExpression)*
MultiplicativeArgumentExpression <- ExponentiationArgumentExpression (MultiplicativeOperator ExponentiationArgumentExpression)*
ExponentiationArgumentExpression <- UnaryArgumentExpression ((STARSTAR / CARET) UnaryArgumentExpression)?
UnaryArgumentExpression <- UnaryOperator? ExtentArgumentExpression
ExtentArgumentExpression <- (KW_ALL ExtentArgumentExpression) / BracketExpression
NameExpression <- QualifiedName FeatureChain?
FeatureChain <- (DOT QualifiedName)+
LiteralExpression <- LiteralBoolean / LiteralString / LiteralReal / LiteralInteger
LiteralBoolean <- KW_TRUE / KW_FALSE
LiteralString <- STRING_VALUE
LiteralReal <- REAL_VALUE
LiteralInteger <- DECIMAL_VALUE

%%

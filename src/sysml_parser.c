/* A packrat parser generated by PackCC 2.2.0 */

#ifdef _MSC_VER
#undef _CRT_NONSTDC_NO_WARNINGS
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_NONSTDC_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "sysml_parser.h"

#include "sysml2/ast_builder.h"

/* Forward declarations for trivia capture functions (use size_t offsets) */
void sysml2_capture_line_comment(SysmlParserContext *ctx, size_t start_offset, size_t end_offset);
void sysml2_capture_block_comment(SysmlParserContext *ctx, size_t start_offset, size_t end_offset);
void sysml2_capture_blank_lines(SysmlParserContext *ctx, size_t start_offset, size_t end_offset);
void sysml2_capture_documentation(SysmlParserContext *ctx, size_t start_offset, size_t end_offset);

/* Forward declarations for new capture functions (from ast_builder.h) */
void sysml2_capture_multiplicity(SysmlBuildContext *ctx, const char *text, size_t len);
void sysml2_capture_default_value(SysmlBuildContext *ctx, const char *text, size_t len, bool has_default_keyword);
void sysml2_capture_abstract(SysmlBuildContext *ctx);
void sysml2_capture_variation(SysmlBuildContext *ctx);
void sysml2_capture_direction(SysmlBuildContext *ctx, SysmlDirection dir);
void sysml2_capture_import_visibility(SysmlBuildContext *ctx, bool is_private);
void sysml2_build_alias(SysmlBuildContext *ctx, const char *name, size_t name_len, const char *target, size_t target_len);

/* Helper: check if character is a type/specialization marker */
static int sysml2_is_marker(char c, char next) {
    if (c == '[' || c == '=' || c == '{' || c == ';') return 1;
    if (c == ':' && next != ':') return 1;  /* : but not :: */
    return 0;
}

/* Helper: extract just the name portion from captured text (stops at type markers) */
static const char *sysml2_extract_name(SysmlParserContext *ctx, const char *text, size_t len) {
    if (!ctx->build_ctx || !text || len == 0) return NULL;
    /* Skip leading whitespace */
    while (len > 0 && (*text == ' ' || *text == '\t' || *text == '\n' || *text == '\r')) { text++; len--; }
    if (len == 0) return NULL;

    /* Find end of name (stop at type markers) */
    size_t name_end = 0;
    int in_quote = 0;
    for (size_t i = 0; i < len; i++) {
        if (text[i] == '\'') in_quote = !in_quote;
        if (!in_quote && sysml2_is_marker(text[i], (i + 1 < len) ? text[i + 1] : 0)) {
            break;
        }
        name_end = i + 1;
    }
    if (name_end == 0) return NULL;

    /* Trim trailing whitespace from name */
    while (name_end > 0 && (text[name_end-1] == ' ' || text[name_end-1] == '\t' ||
           text[name_end-1] == '\n' || text[name_end-1] == '\r')) name_end--;
    if (name_end == 0) return NULL;

    /* Handle quoted name: 'name' */
    if (text[0] == '\'' && name_end > 2 && text[name_end-1] == '\'') {
        return sysml2_intern_n(ctx->build_ctx->intern, text + 1, name_end - 2);
    }
    /* Handle short name: <name> name */
    if (text[0] == '<') {
        size_t i = 1;
        while (i < name_end && text[i] != '>') i++;
        if (i < name_end) {
            i++;
            while (i < name_end && (text[i] == ' ' || text[i] == '\t')) i++;
            if (i < name_end) {
                /* There's a name after the short name */
                size_t nlen = name_end - i;
                while (nlen > 0 && (text[i + nlen - 1] == ' ' || text[i + nlen - 1] == '\t')) nlen--;
                if (text[i] == '\'' && nlen > 2 && text[i + nlen - 1] == '\'') {
                    return sysml2_intern_n(ctx->build_ctx->intern, text + i + 1, nlen - 2);
                }
                return sysml2_intern_n(ctx->build_ctx->intern, text + i, nlen);
            }
            /* Just short name, extract content */
            const char *start = text + 1;
            size_t nlen = i - 2;  /* Skip < and > */
            while (nlen > 0 && (*start == ' ' || *start == '\t')) { start++; nlen--; }
            while (nlen > 0 && (start[nlen-1] == ' ' || start[nlen-1] == '\t')) nlen--;
            if (start[0] == '\'' && nlen > 2 && start[nlen-1] == '\'') {
                return sysml2_intern_n(ctx->build_ctx->intern, start + 1, nlen - 2);
            }
            return nlen > 0 ? sysml2_intern_n(ctx->build_ctx->intern, start, nlen) : NULL;
        }
    }
    return sysml2_intern_n(ctx->build_ctx->intern, text, name_end);
}

/* Operator kind for type relationships */
typedef enum {
    SYSML_OP_NONE = 0,
    SYSML_OP_TYPED_BY,      /* : */
    SYSML_OP_SPECIALIZES,   /* :> */
    SYSML_OP_REDEFINES,     /* :>> */
    SYSML_OP_REFERENCES,    /* ::> */
} SysmlOperatorKind;

/* Result of extracting a type reference with its operator */
typedef struct {
    SysmlOperatorKind op;
    const char *ref;
} SysmlTypeRefResult;

/* Helper: extract next type reference from captured text at position i, returning operator and reference */
static SysmlTypeRefResult sysml2_extract_next_type_ref(SysmlParserContext *ctx, const char *text, size_t len, size_t *pos) {
    SysmlTypeRefResult result = { SYSML_OP_NONE, NULL };
    if (!ctx->build_ctx || !text || len == 0) return result;

    size_t i = *pos;
    int in_quote = 0;

    while (i < len) {
        if (text[i] == '\'') in_quote = !in_quote;
        if (!in_quote && text[i] == ':') {
            SysmlOperatorKind op = SYSML_OP_NONE;
            size_t op_end = i;

            /* Determine operator type */
            if (i + 2 < len && text[i + 1] == ':' && text[i + 2] == '>') {
                /* ::> - references */
                op = SYSML_OP_REFERENCES;
                op_end = i + 3;
            } else if (i + 1 < len && text[i + 1] == '>') {
                if (i + 2 < len && text[i + 2] == '>') {
                    /* :>> - redefines */
                    op = SYSML_OP_REDEFINES;
                    op_end = i + 3;
                } else {
                    /* :> - specializes */
                    op = SYSML_OP_SPECIALIZES;
                    op_end = i + 2;
                }
            } else if (i + 1 < len && text[i + 1] == ':') {
                /* :: - qualified name separator, skip both */
                i += 2;
                continue;
            } else {
                /* : - typed by */
                op = SYSML_OP_TYPED_BY;
                op_end = i + 1;
            }

            /* Skip whitespace and optional ~ after operator */
            i = op_end;
            while (i < len && (text[i] == ' ' || text[i] == '\t' || text[i] == '~')) i++;
            if (i >= len) {
                *pos = i;
                return result;
            }

            /* Find end of type name (stop at comma, [, =, {, ;, another operator) */
            size_t ref_start = i;
            size_t ref_end = i;
            while (i < len) {
                if (text[i] == ',' || text[i] == '[' || text[i] == '=' ||
                    text[i] == '{' || text[i] == ';') {
                    break;
                }
                if (text[i] == ':') {
                    if (i + 2 < len && text[i + 1] == ':' && text[i + 2] == '>') {
                        break;  /* ::> */
                    }
                    if (i + 1 < len && text[i + 1] == '>') {
                        break;  /* :> or :>> */
                    }
                    if (i + 1 < len && text[i + 1] == ':') {
                        /* :: in qualified name, keep going */
                        i += 2;
                        ref_end = i;
                        continue;
                    }
                    break;  /* Another : */
                }
                ref_end = i + 1;
                i++;
            }

            /* Trim trailing whitespace */
            while (ref_end > ref_start && (text[ref_end-1] == ' ' || text[ref_end-1] == '\t' ||
                   text[ref_end-1] == '\n' || text[ref_end-1] == '\r')) ref_end--;

            if (ref_end > ref_start) {
                result.op = op;
                result.ref = sysml2_intern_n(ctx->build_ctx->intern, text + ref_start, ref_end - ref_start);
            }
            *pos = i;
            return result;
        }
        i++;
    }
    *pos = i;
    return result;
}

/* Helper: extract all type references from captured text */
static void sysml2_extract_all_type_refs(SysmlParserContext *ctx, SysmlNode *node, const char *text, size_t len) {
    if (!ctx->build_ctx || !node || !text || len == 0) return;

    size_t pos = 0;
    while (pos < len) {
        SysmlTypeRefResult result = sysml2_extract_next_type_ref(ctx, text, len, &pos);
        if (result.op == SYSML_OP_NONE || !result.ref) break;

        switch (result.op) {
            case SYSML_OP_TYPED_BY:
                sysml2_build_add_typed_by(ctx->build_ctx, node, result.ref);
                break;
            case SYSML_OP_SPECIALIZES:
                sysml2_build_add_specializes(ctx->build_ctx, node, result.ref);
                break;
            case SYSML_OP_REDEFINES:
                sysml2_build_add_redefines(ctx->build_ctx, node, result.ref);
                break;
            case SYSML_OP_REFERENCES:
                sysml2_build_add_references(ctx->build_ctx, node, result.ref);
                break;
            default:
                break;
        }
    }
}

/* Build node, add to model, push scope */
static void sysml2_build_push(SysmlParserContext *ctx, SysmlNodeKind kind, const char *text, size_t len) {
    if (!ctx->build_ctx) return;
    const char *name = sysml2_extract_name(ctx, text, len);
    SysmlNode *node = sysml2_build_node(ctx->build_ctx, kind, name);
    if (node) {
        /* Extract all type references with correct operator types */
        sysml2_extract_all_type_refs(ctx, node, text, len);
        sysml2_build_add_element(ctx->build_ctx, node);
        sysml2_build_push_scope(ctx->build_ctx, node->id);
    }
}

/* Pop scope */
static void sysml2_pop(SysmlParserContext *ctx) {
    if (ctx->build_ctx) sysml2_build_pop_scope(ctx->build_ctx);
}

/* Build import and add to model */
static void sysml2_build_import(SysmlParserContext *ctx, const char *text, size_t len) {
    if (!ctx->build_ctx || !text || len == 0) return;

    /* Skip leading whitespace */
    while (len > 0 && (*text == ' ' || *text == '\t' || *text == '\n' || *text == '\r')) { text++; len--; }
    if (len == 0) return;

    /* Trim trailing whitespace */
    while (len > 0 && (text[len-1] == ' ' || text[len-1] == '\t' || text[len-1] == '\n' || text[len-1] == '\r')) len--;
    if (len == 0) return;

    /* Determine import kind based on suffix patterns */
    SysmlNodeKind kind = SYSML_KIND_IMPORT;
    size_t target_len = len;

    /* Check for ::** (recursive) first */
    if (len >= 4 && text[len-4] == ':' && text[len-3] == ':' && text[len-2] == '*' && text[len-1] == '*') {
        kind = SYSML_KIND_IMPORT_RECURSIVE;
        target_len = len - 4;
    }
    /* Check for ::* (namespace) */
    else if (len >= 3 && text[len-3] == ':' && text[len-2] == ':' && text[len-1] == '*') {
        kind = SYSML_KIND_IMPORT_ALL;
        target_len = len - 3;
    }

    /* Trim trailing whitespace from target */
    while (target_len > 0 && (text[target_len-1] == ' ' || text[target_len-1] == '\t')) target_len--;
    if (target_len == 0) return;

    /* Intern the target */
    const char *target = sysml2_intern_n(ctx->build_ctx->intern, text, target_len);
    if (target) {
        sysml2_build_add_import(ctx->build_ctx, kind, target);
    }
}

/* Capture visibility indicator (called from MemberPrefix) */
static void sysml2_capture_visibility_private(SysmlParserContext *ctx) {
    if (!ctx->build_ctx) return;
    /* Set pending import private for imports, pending_visibility for nodes */
    ctx->build_ctx->pending_import_private = true;
    ctx->build_ctx->pending_visibility = SYSML_VIS_PRIVATE;
}

static void sysml2_capture_visibility_public(SysmlParserContext *ctx) {
    if (!ctx->build_ctx) return;
    ctx->build_ctx->pending_import_private = false;
    ctx->build_ctx->pending_visibility = SYSML_VIS_PUBLIC;
}

static void sysml2_capture_visibility_protected(SysmlParserContext *ctx) {
    if (!ctx->build_ctx) return;
    ctx->build_ctx->pending_import_private = false;
    ctx->build_ctx->pending_visibility = SYSML_VIS_PROTECTED;
}

/* Capture prefix metadata (#MetadataName) */
static void sysml2_capture_prefix_metadata(SysmlParserContext *ctx, const char *text, size_t len) {
    if (!ctx->build_ctx || !text || len == 0) return;
    /* Skip leading whitespace */
    while (len > 0 && (*text == ' ' || *text == '\t')) { text++; len--; }
    /* Trim trailing whitespace */
    while (len > 0 && (text[len-1] == ' ' || text[len-1] == '\t')) len--;
    if (len == 0) return;
    /* Intern and add to pending */
    const char *ref = sysml2_intern_n(ctx->build_ctx->intern, text, len);
    if (ref) {
        sysml2_build_add_pending_prefix_metadata(ctx->build_ctx, ref);
    }
}

/* Start capturing a metadata usage (@Type { ... }) */
static void sysml2_capture_start_metadata(SysmlParserContext *ctx, const char *text, size_t len) {
    if (!ctx->build_ctx || !text || len == 0) return;
    /* Skip leading whitespace */
    while (len > 0 && (*text == ' ' || *text == '\t')) { text++; len--; }
    /* Trim trailing whitespace */
    while (len > 0 && (text[len-1] == ' ' || text[len-1] == '\t')) len--;
    if (len == 0) return;
    /* Intern and start metadata */
    const char *ref = sysml2_intern_n(ctx->build_ctx->intern, text, len);
    if (ref) {
        sysml2_build_start_metadata(ctx->build_ctx, ref);
    }
}

/* End capturing a metadata usage */
static void sysml2_capture_end_metadata(SysmlParserContext *ctx) {
    if (!ctx->build_ctx) return;
    sysml2_build_end_metadata(ctx->build_ctx);
}

/* Helper: extract feature value from captured text (strips = or := prefix, stops at ; or }) */
static const char *sysml2_extract_feature_value(SysmlParserContext *ctx, const char *text, size_t len) {
    if (!ctx->build_ctx || !text || len == 0) return NULL;
    /* Skip leading whitespace */
    while (len > 0 && (*text == ' ' || *text == '\t')) { text++; len--; }
    /* Skip assignment operator (= or :=) */
    if (len > 0 && *text == '=') { text++; len--; }
    else if (len > 1 && text[0] == ':' && text[1] == '=') { text += 2; len -= 2; }
    /* Skip whitespace after operator */
    while (len > 0 && (*text == ' ' || *text == '\t')) { text++; len--; }
    /* Trim trailing whitespace and terminators */
    while (len > 0 && (text[len-1] == ' ' || text[len-1] == '\t' ||
                       text[len-1] == ';' || text[len-1] == '{' || text[len-1] == '}')) len--;
    if (len == 0) return NULL;
    return sysml2_intern_n(ctx->build_ctx->intern, text, len);
}

/* Capture metadata feature assignment (name = value) */
static void sysml2_capture_metadata_feature(SysmlParserContext *ctx, const char *name_text, size_t name_len,
                                            const char *value_text, size_t value_len) {
    if (!ctx->build_ctx || !ctx->build_ctx->current_metadata) return;
    if (!name_text || name_len == 0) return;

    /* Skip leading whitespace in name */
    while (name_len > 0 && (*name_text == ' ' || *name_text == '\t')) { name_text++; name_len--; }
    /* Trim trailing whitespace in name */
    while (name_len > 0 && (name_text[name_len-1] == ' ' || name_text[name_len-1] == '\t')) name_len--;
    if (name_len == 0) return;

    const char *name = sysml2_intern_n(ctx->build_ctx->intern, name_text, name_len);
    const char *value = sysml2_extract_feature_value(ctx, value_text, value_len);

    sysml2_build_metadata_add_feature(ctx->build_ctx, ctx->build_ctx->current_metadata, name, value);
}

#if !defined __has_attribute || defined _MSC_VER
#define __attribute__(x)
#endif

#ifdef _MSC_VER
#define MARK_FUNC_AS_USED __pragma(warning(suppress:4505))
#else
#define MARK_FUNC_AS_USED __attribute__((__unused__))
#endif

#ifdef _MSC_VER
#define MARK_VAR_AS_USED __pragma(warning(suppress:4189))
#else
#define MARK_VAR_AS_USED __attribute__((__unused__))
#endif

#ifndef PCC_BUFFER_MIN_SIZE
#define PCC_BUFFER_MIN_SIZE 256
#endif /* !PCC_BUFFER_MIN_SIZE */

#ifndef PCC_ARRAY_MIN_SIZE
#define PCC_ARRAY_MIN_SIZE 2
#endif /* !PCC_ARRAY_MIN_SIZE */

#ifndef PCC_POOL_MIN_SIZE
#define PCC_POOL_MIN_SIZE 65536
#endif /* !PCC_POOL_MIN_SIZE */

#define PCC_DBG_EVALUATE 0
#define PCC_DBG_MATCH    1
#define PCC_DBG_NOMATCH  2

#define PCC_VOID_VALUE (~(size_t)0)

typedef enum pcc_bool_tag {
    PCC_FALSE = 0,
    PCC_TRUE
} pcc_bool_t;

typedef struct pcc_char_array_tag {
    char *buf;
    size_t max;
    size_t len;
} pcc_char_array_t;

typedef struct pcc_range_tag {
    size_t start;
    size_t end;
} pcc_range_t;

typedef void *pcc_value_t;

typedef SysmlParserContext *pcc_auxil_t;

typedef sysml2_context_t pcc_context_t;

typedef struct pcc_value_table_tag {
    pcc_value_t *buf;
    size_t max;
    size_t len;
} pcc_value_table_t;

typedef struct pcc_value_refer_table_tag {
    pcc_value_t **buf;
    size_t max;
    size_t len;
} pcc_value_refer_table_t;

typedef struct pcc_capture_tag {
    pcc_range_t range;
    pcc_char_array_t string; /* mutable */
} pcc_capture_t;

typedef struct pcc_capture_table_tag {
    pcc_capture_t *buf;
    size_t max;
    size_t len;
} pcc_capture_table_t;

typedef struct pcc_capture_const_table_tag {
    const pcc_capture_t **buf;
    size_t max;
    size_t len;
} pcc_capture_const_table_t;

typedef struct pcc_thunk_tag pcc_thunk_t;
typedef struct pcc_thunk_array_tag pcc_thunk_array_t;

typedef void (*pcc_action_t)(pcc_context_t *, pcc_thunk_t *, pcc_value_t *);

typedef enum pcc_thunk_type_tag {
    PCC_THUNK_LEAF,
    PCC_THUNK_NODE
} pcc_thunk_type_t;

typedef struct pcc_thunk_leaf_tag {
    pcc_value_refer_table_t values;
    pcc_capture_const_table_t capts;
    pcc_capture_t capt0;
    pcc_action_t action;
} pcc_thunk_leaf_t;

typedef struct pcc_thunk_node_tag {
    const pcc_thunk_array_t *thunks; /* just a reference */
    pcc_value_t *value; /* just a reference */
} pcc_thunk_node_t;

typedef union pcc_thunk_data_tag {
    pcc_thunk_leaf_t leaf;
    pcc_thunk_node_t node;
} pcc_thunk_data_t;

struct pcc_thunk_tag {
    pcc_thunk_type_t type;
    pcc_thunk_data_t data;
};

struct pcc_thunk_array_tag {
    pcc_thunk_t **buf;
    size_t max;
    size_t len;
};

typedef struct pcc_thunk_chunk_tag {
    pcc_value_table_t values;
    pcc_capture_table_t capts;
    pcc_thunk_array_t thunks;
    size_t pos; /* the starting position in the character buffer */
} pcc_thunk_chunk_t;

typedef struct pcc_lr_entry_tag pcc_lr_entry_t;

typedef enum pcc_lr_answer_type_tag {
    PCC_LR_ANSWER_LR,
    PCC_LR_ANSWER_CHUNK
} pcc_lr_answer_type_t;

typedef union pcc_lr_answer_data_tag {
    pcc_lr_entry_t *lr;
    pcc_thunk_chunk_t *chunk;
} pcc_lr_answer_data_t;

typedef struct pcc_lr_answer_tag pcc_lr_answer_t;

struct pcc_lr_answer_tag {
    pcc_lr_answer_type_t type;
    pcc_lr_answer_data_t data;
    size_t pos; /* the absolute position in the input */
    pcc_lr_answer_t *hold;
};

typedef pcc_thunk_chunk_t *(*pcc_rule_t)(pcc_context_t *);

typedef struct pcc_rule_set_tag {
    pcc_rule_t *buf;
    size_t max;
    size_t len;
} pcc_rule_set_t;

typedef struct pcc_lr_head_tag pcc_lr_head_t;

struct pcc_lr_head_tag {
    pcc_rule_t rule;
    pcc_rule_set_t invol;
    pcc_rule_set_t eval;
    pcc_lr_head_t *hold;
};

typedef struct pcc_lr_memo_tag {
    pcc_rule_t rule;
    pcc_lr_answer_t *answer;
    size_t next; /* the index of the next instance with the same hash value */
} pcc_lr_memo_t;

typedef struct pcc_lr_memo_map_tag {
    pcc_lr_memo_t *buf;
    size_t max;
    size_t len;
} pcc_lr_memo_map_t;

typedef struct pcc_lr_table_entry_tag {
    pcc_lr_head_t *head; /* just a reference */
    pcc_lr_memo_map_t memos;
    pcc_lr_answer_t *hold_a;
    pcc_lr_head_t *hold_h;
} pcc_lr_table_entry_t;

typedef struct pcc_lr_table_tag {
    pcc_lr_table_entry_t **buf;
    size_t max;
    size_t len;
    size_t ofs;
} pcc_lr_table_t;

struct pcc_lr_entry_tag {
    pcc_rule_t rule;
    pcc_thunk_chunk_t *seed; /* just a reference */
    pcc_lr_head_t *head; /* just a reference */
};

typedef struct pcc_lr_stack_tag {
    pcc_lr_entry_t **buf;
    size_t max;
    size_t len;
} pcc_lr_stack_t;

typedef struct pcc_memory_entry_tag pcc_memory_entry_t;
typedef struct pcc_memory_pool_tag pcc_memory_pool_t;

struct pcc_memory_entry_tag {
    pcc_memory_entry_t *next;
};

struct pcc_memory_pool_tag {
    pcc_memory_pool_t *next;
    size_t allocated;
    size_t unused;
};

typedef struct pcc_memory_recycler_tag {
    pcc_memory_pool_t *pool_list;
    pcc_memory_entry_t *entry_list;
    size_t element_size;
} pcc_memory_recycler_t;

struct sysml2_context_tag {
    size_t pos; /* the position in the input of the first character currently buffered */
    size_t cur; /* the current parsing position in the character buffer */
    size_t level;
    pcc_char_array_t buffer;
    pcc_lr_table_t lrtable;
    pcc_lr_stack_t lrstack;
    pcc_thunk_array_t thunks;
    pcc_auxil_t auxil;
    pcc_memory_recycler_t thunk_recycler;
    pcc_memory_recycler_t thunk_chunk_recycler;
    pcc_memory_recycler_t lr_head_recycler;
    pcc_memory_recycler_t lr_answer_recycler;
    pcc_memory_recycler_t lr_table_entry_recycler;
    pcc_memory_recycler_t lr_entry_recycler;
};

#ifndef PCC_ERROR
#define PCC_ERROR(auxil) pcc_error()
MARK_FUNC_AS_USED
static void pcc_error(void) {
    fprintf(stderr, "Syntax error\n");
    exit(1);
}
#endif /* !PCC_ERROR */

#ifndef PCC_GETCHAR
#define PCC_GETCHAR(auxil) getchar()
#endif /* !PCC_GETCHAR */

#ifndef PCC_MALLOC
#define PCC_MALLOC(auxil, size) pcc_malloc_e(size)
static void *pcc_malloc_e(size_t size) {
    void *const p = malloc(size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_MALLOC */

#ifndef PCC_REALLOC
#define PCC_REALLOC(auxil, ptr, size) pcc_realloc_e(ptr, size)
static void *pcc_realloc_e(void *ptr, size_t size) {
    void *const p = realloc(ptr, size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_REALLOC */

#ifndef PCC_FREE
#define PCC_FREE(auxil, ptr) free(ptr)
#endif /* !PCC_FREE */

#ifndef PCC_DEBUG
#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) ((void)0)
#endif /* !PCC_DEBUG */

static void pcc_char_array__init(pcc_auxil_t auxil, pcc_char_array_t *array) {
    array->len = 0;
    array->max = 0;
    array->buf = NULL;
}

static void pcc_char_array__resize(pcc_auxil_t auxil, pcc_char_array_t *array, size_t len) {
    if (array->max < len) {
        size_t m = array->max;
        if (m == 0) m = PCC_BUFFER_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        array->buf = (char *)PCC_REALLOC(auxil, array->buf, m);
        array->max = m;
    }
    array->len = len;
}

static void pcc_char_array__add(pcc_auxil_t auxil, pcc_char_array_t *array, char ch) {
    if (array->max <= array->len) {
        const size_t n = array->len + 1;
        size_t m = array->max;
        if (m == 0) m = PCC_BUFFER_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        array->buf = (char *)PCC_REALLOC(auxil, array->buf, m);
        array->max = m;
    }
    array->buf[array->len++] = ch;
}

static void pcc_char_array__term(pcc_auxil_t auxil, pcc_char_array_t *array) {
    PCC_FREE(auxil, array->buf);
}

static void pcc_value_table__init(pcc_auxil_t auxil, pcc_value_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

MARK_FUNC_AS_USED
static void pcc_value_table__resize(pcc_auxil_t auxil, pcc_value_table_t *table, size_t len) {
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_value_t *)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t) * m);
        table->max = m;
    }
    table->len = len;
}

MARK_FUNC_AS_USED
static void pcc_value_table__clear(pcc_auxil_t auxil, pcc_value_table_t *table) {
    memset(table->buf, 0, sizeof(pcc_value_t) * table->len);
}

static void pcc_value_table__term(pcc_auxil_t auxil, pcc_value_table_t *table) {
    PCC_FREE(auxil, table->buf);
}

static void pcc_value_refer_table__init(pcc_auxil_t auxil, pcc_value_refer_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void pcc_value_refer_table__resize(pcc_auxil_t auxil, pcc_value_refer_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_value_t **)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_value_refer_table__term(pcc_auxil_t auxil, pcc_value_refer_table_t *table) {
    PCC_FREE(auxil, table->buf);
}

static void pcc_capture__init(pcc_auxil_t auxil, pcc_capture_t *capt) {
    capt->range.start = 0;
    capt->range.end = 0;
    pcc_char_array__init(auxil, &capt->string);
}

static void pcc_capture__term(pcc_auxil_t auxil, pcc_capture_t *capt) {
    pcc_char_array__term(auxil, &capt->string);
}

static void pcc_capture_table__init(pcc_auxil_t auxil, pcc_capture_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

MARK_FUNC_AS_USED
static void pcc_capture_table__resize(pcc_auxil_t auxil, pcc_capture_table_t *table, size_t len) {
    size_t i;
    for (i = len; i < table->len; i++) pcc_capture__term(auxil, &table->buf[i]);
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_capture_t *)PCC_REALLOC(auxil, table->buf, sizeof(pcc_capture_t) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) pcc_capture__init(auxil, &table->buf[i]);
    table->len = len;
}

static void pcc_capture_table__term(pcc_auxil_t auxil, pcc_capture_table_t *table) {
    while (table->len > 0) {
        table->len--;
        pcc_capture__term(auxil, &table->buf[table->len]);
    }
    PCC_FREE(auxil, table->buf);
}

static void pcc_capture_const_table__init(pcc_auxil_t auxil, pcc_capture_const_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void pcc_capture_const_table__resize(pcc_auxil_t auxil, pcc_capture_const_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (const pcc_capture_t **)PCC_REALLOC(auxil, (pcc_capture_t **)table->buf, sizeof(const pcc_capture_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_capture_const_table__term(pcc_auxil_t auxil, pcc_capture_const_table_t *table) {
    PCC_FREE(auxil, (void *)table->buf);
}

static void pcc_memory_recycler__init(pcc_auxil_t auxil, pcc_memory_recycler_t *recycler, size_t element_size) {
    recycler->pool_list = NULL;
    recycler->entry_list = NULL;
    recycler->element_size = element_size;
}

static void *pcc_memory_recycler__supply(pcc_auxil_t auxil, pcc_memory_recycler_t *recycler) {
    if (recycler->entry_list) {
        pcc_memory_entry_t *const tmp = recycler->entry_list;
        recycler->entry_list = tmp->next;
        return tmp;
    }
    if (!recycler->pool_list || recycler->pool_list->unused == 0) {
        size_t size = PCC_POOL_MIN_SIZE;
        if (recycler->pool_list) {
            size = recycler->pool_list->allocated << 1;
            if (size == 0) size = recycler->pool_list->allocated;
        }
        {
            pcc_memory_pool_t *const pool = (pcc_memory_pool_t *)PCC_MALLOC(
                auxil, sizeof(pcc_memory_pool_t) + recycler->element_size * size
            );
            pool->allocated = size;
            pool->unused = size;
            pool->next = recycler->pool_list;
            recycler->pool_list = pool;
        }
    }
    recycler->pool_list->unused--;
    return (char *)recycler->pool_list + sizeof(pcc_memory_pool_t) + recycler->element_size * recycler->pool_list->unused;
}

static void pcc_memory_recycler__recycle(pcc_auxil_t auxil, pcc_memory_recycler_t *recycler, void *ptr) {
    pcc_memory_entry_t *const tmp = (pcc_memory_entry_t *)ptr;
    tmp->next = recycler->entry_list;
    recycler->entry_list = tmp;
}

static void pcc_memory_recycler__term(pcc_auxil_t auxil, pcc_memory_recycler_t *recycler) {
    while (recycler->pool_list) {
        pcc_memory_pool_t *const tmp = recycler->pool_list;
        recycler->pool_list = tmp->next;
        PCC_FREE(auxil, tmp);
    }
}

MARK_FUNC_AS_USED
static pcc_thunk_t *pcc_thunk__create_leaf(pcc_context_t *ctx, pcc_action_t action, size_t valuec, size_t captc) {
    pcc_thunk_t *const thunk = (pcc_thunk_t *)pcc_memory_recycler__supply(ctx->auxil, &ctx->thunk_recycler);
    thunk->type = PCC_THUNK_LEAF;
    pcc_value_refer_table__init(ctx->auxil, &thunk->data.leaf.values);
    pcc_value_refer_table__resize(ctx->auxil, &thunk->data.leaf.values, valuec);
    pcc_capture_const_table__init(ctx->auxil, &thunk->data.leaf.capts);
    pcc_capture_const_table__resize(ctx->auxil, &thunk->data.leaf.capts, captc);
    pcc_capture__init(ctx->auxil, &thunk->data.leaf.capt0);
    thunk->data.leaf.action = action;
    return thunk;
}

static pcc_thunk_t *pcc_thunk__create_node(pcc_context_t *ctx, const pcc_thunk_array_t *thunks, pcc_value_t *value) {
    pcc_thunk_t *const thunk = (pcc_thunk_t *)pcc_memory_recycler__supply(ctx->auxil, &ctx->thunk_recycler);
    thunk->type = PCC_THUNK_NODE;
    thunk->data.node.thunks = thunks;
    thunk->data.node.value = value;
    return thunk;
}

static void pcc_thunk__destroy(pcc_context_t *ctx, pcc_thunk_t *thunk) {
    if (thunk == NULL) return;
    switch (thunk->type) {
    case PCC_THUNK_LEAF:
        pcc_capture__term(ctx->auxil, &thunk->data.leaf.capt0);
        pcc_capture_const_table__term(ctx->auxil, &thunk->data.leaf.capts);
        pcc_value_refer_table__term(ctx->auxil, &thunk->data.leaf.values);
        break;
    case PCC_THUNK_NODE:
        break;
    default: /* unknown */
        break;
    }
    pcc_memory_recycler__recycle(ctx->auxil, &ctx->thunk_recycler, thunk);
}

static void pcc_thunk_array__init(pcc_context_t *ctx, pcc_thunk_array_t *array) {
    array->len = 0;
    array->max = 0;
    array->buf = NULL;
}

static void pcc_thunk_array__add(pcc_context_t *ctx, pcc_thunk_array_t *array, pcc_thunk_t *thunk) {
    if (array->max <= array->len) {
        const size_t n = array->len + 1;
        size_t m = array->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        array->buf = (pcc_thunk_t **)PCC_REALLOC(ctx->auxil, array->buf, sizeof(pcc_thunk_t *) * m);
        array->max = m;
    }
    array->buf[array->len++] = thunk;
}

static void pcc_thunk_array__revert(pcc_context_t *ctx, pcc_thunk_array_t *array, size_t len) {
    while (array->len > len) {
        array->len--;
        pcc_thunk__destroy(ctx, array->buf[array->len]);
    }
}

static void pcc_thunk_array__term(pcc_context_t *ctx, pcc_thunk_array_t *array) {
    while (array->len > 0) {
        array->len--;
        pcc_thunk__destroy(ctx, array->buf[array->len]);
    }
    PCC_FREE(ctx->auxil, array->buf);
}

MARK_FUNC_AS_USED
static pcc_thunk_chunk_t *pcc_thunk_chunk__create(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = (pcc_thunk_chunk_t *)pcc_memory_recycler__supply(ctx->auxil, &ctx->thunk_chunk_recycler);
    pcc_value_table__init(ctx->auxil, &chunk->values);
    pcc_capture_table__init(ctx->auxil, &chunk->capts);
    pcc_thunk_array__init(ctx, &chunk->thunks);
    chunk->pos = 0;
    return chunk;
}

static void pcc_thunk_chunk__destroy(pcc_context_t *ctx, pcc_thunk_chunk_t *chunk) {
    if (chunk == NULL) return;
    pcc_thunk_array__term(ctx, &chunk->thunks);
    pcc_capture_table__term(ctx->auxil, &chunk->capts);
    pcc_value_table__term(ctx->auxil, &chunk->values);
    pcc_memory_recycler__recycle(ctx->auxil, &ctx->thunk_chunk_recycler, chunk);
}

static void pcc_rule_set__init(pcc_auxil_t auxil, pcc_rule_set_t *set) {
    set->len = 0;
    set->max = 0;
    set->buf = NULL;
}

static size_t pcc_rule_set__index(pcc_auxil_t auxil, const pcc_rule_set_t *set, pcc_rule_t rule) {
    size_t i;
    for (i = 0; i < set->len; i++) {
        if (set->buf[i] == rule) return i;
    }
    return PCC_VOID_VALUE;
}

static pcc_bool_t pcc_rule_set__add(pcc_auxil_t auxil, pcc_rule_set_t *set, pcc_rule_t rule) {
    const size_t i = pcc_rule_set__index(auxil, set, rule);
    if (i != PCC_VOID_VALUE) return PCC_FALSE;
    if (set->max <= set->len) {
        const size_t n = set->len + 1;
        size_t m = set->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        set->buf = (pcc_rule_t *)PCC_REALLOC(auxil, set->buf, sizeof(pcc_rule_t) * m);
        set->max = m;
    }
    set->buf[set->len++] = rule;
    return PCC_TRUE;
}

static pcc_bool_t pcc_rule_set__remove(pcc_auxil_t auxil, pcc_rule_set_t *set, pcc_rule_t rule) {
    const size_t i = pcc_rule_set__index(auxil, set, rule);
    if (i == PCC_VOID_VALUE) return PCC_FALSE;
    memmove(set->buf + i, set->buf + (i + 1), sizeof(pcc_rule_t) * (set->len - (i + 1)));
    return PCC_TRUE;
}

static void pcc_rule_set__clear(pcc_auxil_t auxil, pcc_rule_set_t *set) {
    set->len = 0;
}

static void pcc_rule_set__copy(pcc_auxil_t auxil, pcc_rule_set_t *set, const pcc_rule_set_t *src) {
    size_t i;
    if (set == src) return;
    pcc_rule_set__clear(auxil, set);
    for (i = 0; i < src->len; i++) {
        pcc_rule_set__add(auxil, set, src->buf[i]);
    }
}

static void pcc_rule_set__term(pcc_auxil_t auxil, pcc_rule_set_t *set) {
    PCC_FREE(auxil, set->buf);
}

static pcc_lr_head_t *pcc_lr_head__create(pcc_context_t *ctx, pcc_rule_t rule) {
    pcc_lr_head_t *const head = (pcc_lr_head_t *)pcc_memory_recycler__supply(ctx->auxil, &ctx->lr_head_recycler);
    head->rule = rule;
    pcc_rule_set__init(ctx->auxil, &head->invol);
    pcc_rule_set__init(ctx->auxil, &head->eval);
    head->hold = NULL;
    return head;
}

static void pcc_lr_head__destroy(pcc_context_t *ctx, pcc_lr_head_t *head) {
    if (head == NULL) return;
    pcc_lr_head__destroy(ctx, head->hold);
    pcc_rule_set__term(ctx->auxil, &head->eval);
    pcc_rule_set__term(ctx->auxil, &head->invol);
    pcc_memory_recycler__recycle(ctx->auxil, &ctx->lr_head_recycler, head);
}

static void pcc_lr_entry__destroy(pcc_context_t *ctx, pcc_lr_entry_t *lr);

static pcc_lr_answer_t *pcc_lr_answer__create(pcc_context_t *ctx, pcc_lr_answer_type_t type, size_t pos) {
    pcc_lr_answer_t *answer = (pcc_lr_answer_t *)pcc_memory_recycler__supply(ctx->auxil, &ctx->lr_answer_recycler);
    answer->type = type;
    answer->pos = pos;
    answer->hold = NULL;
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        answer->data.lr = NULL;
        break;
    case PCC_LR_ANSWER_CHUNK:
        answer->data.chunk = NULL;
        break;
    default: /* unknown */
        pcc_memory_recycler__recycle(ctx->auxil, &ctx->lr_answer_recycler, answer);
        answer = NULL;
    }
    return answer;
}

static void pcc_lr_answer__set_chunk(pcc_context_t *ctx, pcc_lr_answer_t *answer, pcc_thunk_chunk_t *chunk) {
    pcc_lr_answer_t *const a = pcc_lr_answer__create(ctx, answer->type, answer->pos);
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        a->data.lr = answer->data.lr;
        break;
    case PCC_LR_ANSWER_CHUNK:
        a->data.chunk = answer->data.chunk;
        break;
    default: /* unknown */
        break;
    }
    a->hold = answer->hold;
    answer->hold = a;
    answer->type = PCC_LR_ANSWER_CHUNK;
    answer->data.chunk = chunk;
}

static void pcc_lr_answer__destroy(pcc_context_t *ctx, pcc_lr_answer_t *answer) {
    while (answer != NULL) {
        pcc_lr_answer_t *const a = answer->hold;
        switch (answer->type) {
        case PCC_LR_ANSWER_LR:
            pcc_lr_entry__destroy(ctx, answer->data.lr);
            break;
        case PCC_LR_ANSWER_CHUNK:
            pcc_thunk_chunk__destroy(ctx, answer->data.chunk);
            break;
        default: /* unknown */
            break;
        }
        pcc_memory_recycler__recycle(ctx->auxil, &ctx->lr_answer_recycler, answer);
        answer = a;
    }
}

static void pcc_lr_memo_map__init(pcc_context_t *ctx, pcc_lr_memo_map_t *map) {
    map->len = 0;
    map->max = 0;
    map->buf = NULL;
}

static size_t pcc_lr_memo_map__index(pcc_context_t *ctx, pcc_lr_memo_map_t *map, pcc_rule_t rule) {
    size_t i;
    for (i = 0; i < map->len; i++) {
        if (map->buf[i].rule == rule) return i;
    }
    return PCC_VOID_VALUE;
}

static void pcc_lr_memo_map__put(pcc_context_t *ctx, pcc_lr_memo_map_t *map, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    const size_t i = pcc_lr_memo_map__index(ctx, map, rule);
    if (i != PCC_VOID_VALUE) {
        pcc_lr_answer__destroy(ctx, map->buf[i].answer);
        map->buf[i].answer = answer;
    }
    else {
        if (map->max <= map->len) {
            const size_t n = map->len + 1;
            size_t m = map->max;
            if (m == 0) m = PCC_ARRAY_MIN_SIZE;
            while (m < n && m != 0) m <<= 1;
            if (m == 0) m = n;
            map->buf = (pcc_lr_memo_t *)PCC_REALLOC(ctx->auxil, map->buf, sizeof(pcc_lr_memo_t) * m);
            map->max = m;
        }
        map->buf[map->len].rule = rule;
        map->buf[map->len].answer = answer;
        map->len++;
    }
}

static pcc_lr_answer_t *pcc_lr_memo_map__get(pcc_context_t *ctx, pcc_lr_memo_map_t *map, pcc_rule_t rule) {
    const size_t i = pcc_lr_memo_map__index(ctx, map, rule);
    return (i != PCC_VOID_VALUE) ? map->buf[i].answer : NULL;
}

static void pcc_lr_memo_map__term(pcc_context_t *ctx, pcc_lr_memo_map_t *map) {
    while (map->len > 0) {
        map->len--;
        pcc_lr_answer__destroy(ctx, map->buf[map->len].answer);
    }
    PCC_FREE(ctx->auxil, map->buf);
}

static pcc_lr_table_entry_t *pcc_lr_table_entry__create(pcc_context_t *ctx) {
    pcc_lr_table_entry_t *const entry = (pcc_lr_table_entry_t *)pcc_memory_recycler__supply(ctx->auxil, &ctx->lr_table_entry_recycler);
    entry->head = NULL;
    pcc_lr_memo_map__init(ctx, &entry->memos);
    entry->hold_a = NULL;
    entry->hold_h = NULL;
    return entry;
}

static void pcc_lr_table_entry__destroy(pcc_context_t *ctx, pcc_lr_table_entry_t *entry) {
    if (entry == NULL) return;
    pcc_lr_head__destroy(ctx, entry->hold_h);
    pcc_lr_answer__destroy(ctx, entry->hold_a);
    pcc_lr_memo_map__term(ctx, &entry->memos);
    pcc_memory_recycler__recycle(ctx->auxil, &ctx->lr_table_entry_recycler, entry);
}

static void pcc_lr_table__init(pcc_context_t *ctx, pcc_lr_table_t *table) {
    table->ofs = 0;
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void pcc_lr_table__resize(pcc_context_t *ctx, pcc_lr_table_t *table, size_t len) {
    size_t i;
    for (i = len; i < table->len; i++) pcc_lr_table_entry__destroy(ctx, table->buf[i]);
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_lr_table_entry_t **)PCC_REALLOC(ctx->auxil, table->buf, sizeof(pcc_lr_table_entry_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_lr_table__set_head(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_lr_head_t *head) {
    index += table->ofs;
    if (index >= table->len) pcc_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(ctx);
    table->buf[index]->head = head;
}

static void pcc_lr_table__hold_head(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_lr_head_t *head) {
    index += table->ofs;
    if (index >= table->len) pcc_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(ctx);
    head->hold = table->buf[index]->hold_h;
    table->buf[index]->hold_h = head;
}

static void pcc_lr_table__set_answer(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    index += table->ofs;
    if (index >= table->len) pcc_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(ctx);
    pcc_lr_memo_map__put(ctx, &table->buf[index]->memos, rule, answer);
}

static void pcc_lr_table__hold_answer(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_lr_answer_t *answer) {
    index += table->ofs;
    if (index >= table->len) pcc_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(ctx);
    answer->hold = table->buf[index]->hold_a;
    table->buf[index]->hold_a = answer;
}

static pcc_lr_head_t *pcc_lr_table__get_head(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index) {
    index += table->ofs;
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return table->buf[index]->head;
}

static pcc_lr_answer_t *pcc_lr_table__get_answer(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_rule_t rule) {
    index += table->ofs;
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return pcc_lr_memo_map__get(ctx, &table->buf[index]->memos, rule);
}

static void pcc_lr_table__shift(pcc_context_t *ctx, pcc_lr_table_t *table, size_t count) {
    size_t i;
    if (count > table->len - table->ofs) count = table->len - table->ofs;
    for (i = 0; i < count; i++) pcc_lr_table_entry__destroy(ctx, table->buf[table->ofs++]);
    if (table->ofs > (table->max >> 1)) {
        memmove(table->buf, table->buf + table->ofs, sizeof(pcc_lr_table_entry_t *) * (table->len - table->ofs));
        table->len -= table->ofs;
        table->ofs = 0;
    }
}

static void pcc_lr_table__term(pcc_context_t *ctx, pcc_lr_table_t *table) {
    while (table->len > table->ofs) {
        table->len--;
        pcc_lr_table_entry__destroy(ctx, table->buf[table->len]);
    }
    PCC_FREE(ctx->auxil, table->buf);
}

static pcc_lr_entry_t *pcc_lr_entry__create(pcc_context_t *ctx, pcc_rule_t rule) {
    pcc_lr_entry_t *const lr = (pcc_lr_entry_t *)pcc_memory_recycler__supply(ctx->auxil, &ctx->lr_entry_recycler);
    lr->rule = rule;
    lr->seed = NULL;
    lr->head = NULL;
    return lr;
}

static void pcc_lr_entry__destroy(pcc_context_t *ctx, pcc_lr_entry_t *lr) {
    pcc_memory_recycler__recycle(ctx->auxil, &ctx->lr_entry_recycler, lr);
}

static void pcc_lr_stack__init(pcc_auxil_t auxil, pcc_lr_stack_t *stack) {
    stack->len = 0;
    stack->max = 0;
    stack->buf = NULL;
}

static void pcc_lr_stack__push(pcc_auxil_t auxil, pcc_lr_stack_t *stack, pcc_lr_entry_t *lr) {
    if (stack->max <= stack->len) {
        const size_t n = stack->len + 1;
        size_t m = stack->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        stack->buf = (pcc_lr_entry_t **)PCC_REALLOC(auxil, stack->buf, sizeof(pcc_lr_entry_t *) * m);
        stack->max = m;
    }
    stack->buf[stack->len++] = lr;
}

static pcc_lr_entry_t *pcc_lr_stack__pop(pcc_auxil_t auxil, pcc_lr_stack_t *stack) {
    return stack->buf[--stack->len];
}

static void pcc_lr_stack__term(pcc_auxil_t auxil, pcc_lr_stack_t *stack) {
    PCC_FREE(auxil, stack->buf);
}

static pcc_context_t *pcc_context__create(pcc_auxil_t auxil) {
    pcc_context_t *const ctx = (pcc_context_t *)PCC_MALLOC(auxil, sizeof(pcc_context_t));
    ctx->pos = 0;
    ctx->cur = 0;
    ctx->level = 0;
    pcc_char_array__init(auxil, &ctx->buffer);
    pcc_lr_table__init(ctx, &ctx->lrtable);
    pcc_lr_stack__init(auxil, &ctx->lrstack);
    pcc_thunk_array__init(ctx, &ctx->thunks);
    pcc_memory_recycler__init(auxil, &ctx->thunk_recycler, sizeof(pcc_thunk_t));
    pcc_memory_recycler__init(auxil, &ctx->thunk_chunk_recycler, sizeof(pcc_thunk_chunk_t));
    pcc_memory_recycler__init(auxil, &ctx->lr_head_recycler, sizeof(pcc_lr_head_t));
    pcc_memory_recycler__init(auxil, &ctx->lr_answer_recycler, sizeof(pcc_lr_answer_t));
    pcc_memory_recycler__init(auxil, &ctx->lr_table_entry_recycler, sizeof(pcc_lr_table_entry_t));
    pcc_memory_recycler__init(auxil, &ctx->lr_entry_recycler, sizeof(pcc_lr_entry_t));
    ctx->auxil = auxil;
    return ctx;
}

static void pcc_context__destroy(pcc_context_t *ctx) {
    if (ctx == NULL) return;
    pcc_thunk_array__term(ctx, &ctx->thunks);
    pcc_lr_stack__term(ctx->auxil, &ctx->lrstack);
    pcc_lr_table__term(ctx, &ctx->lrtable);
    pcc_char_array__term(ctx->auxil, &ctx->buffer);
    pcc_memory_recycler__term(ctx->auxil, &ctx->thunk_recycler);
    pcc_memory_recycler__term(ctx->auxil, &ctx->thunk_chunk_recycler);
    pcc_memory_recycler__term(ctx->auxil, &ctx->lr_head_recycler);
    pcc_memory_recycler__term(ctx->auxil, &ctx->lr_answer_recycler);
    pcc_memory_recycler__term(ctx->auxil, &ctx->lr_table_entry_recycler);
    pcc_memory_recycler__term(ctx->auxil, &ctx->lr_entry_recycler);
    PCC_FREE(ctx->auxil, ctx);
}

static size_t pcc_refill_buffer(pcc_context_t *ctx, size_t num) {
    if (ctx->buffer.len >= ctx->cur + num) return ctx->buffer.len - ctx->cur;
    while (ctx->buffer.len < ctx->cur + num) {
        const int c = PCC_GETCHAR(ctx->auxil);
        if (c < 0) break;
        pcc_char_array__add(ctx->auxil, &ctx->buffer, (char)c);
    }
    return ctx->buffer.len - ctx->cur;
}

MARK_FUNC_AS_USED
static void pcc_commit_buffer(pcc_context_t *ctx) {
    memmove(ctx->buffer.buf, ctx->buffer.buf + ctx->cur, ctx->buffer.len - ctx->cur);
    ctx->buffer.len -= ctx->cur;
    ctx->pos += ctx->cur;
    pcc_lr_table__shift(ctx, &ctx->lrtable, ctx->cur);
    ctx->cur = 0;
}

MARK_FUNC_AS_USED
static const char *pcc_get_capture_string(pcc_context_t *ctx, const pcc_capture_t *capt) {
    if (capt->string.len == 0) {
        const size_t n = capt->range.end - capt->range.start;
        pcc_capture_t *const p = (pcc_capture_t *)capt;
        pcc_char_array__resize(ctx->auxil, &p->string, n + 1);
        if (n > 0) memcpy(p->string.buf, ctx->buffer.buf + capt->range.start, n);
        p->string.buf[n] = '\0';
    }
    return capt->string.buf;
}

static size_t pcc_get_char_as_utf32(pcc_context_t *ctx, int *out) { /* with checking UTF-8 validity */
    int c, u;
    size_t n, i;
    if (pcc_refill_buffer(ctx, 1) < 1) return 0;
    c = (int)(unsigned char)ctx->buffer.buf[ctx->cur];
    n = (c < 0x80) ? 1 :
        ((c & 0xe0) == 0xc0) ? 2 :
        ((c & 0xf0) == 0xe0) ? 3 :
        ((c & 0xf8) == 0xf0) ? 4 :
        ((c & 0xfc) == 0xf8) ? 5 :
        ((c & 0xfe) == 0xfc) ? 6 : 0;
    if (n < 1) return 0;
    if (pcc_refill_buffer(ctx, n) < n) return 0;
    u = (n <= 1) ? c : (c & ((1 << (7 - n)) - 1));
    for (i = 1; i < n; i++) {
        const int d = (int)(unsigned char)ctx->buffer.buf[ctx->cur + i];
        if ((d & 0xc0) != 0x80) return 0; /* not a continuation byte */
        u = (u << 6) | (d & 0x3f);
    }
    if (
        (n == 2 && u < 0x00000080) ||
        (n == 3 && u < 0x00000800) ||
        (n == 4 && u < 0x00010000) ||
        (n == 5 && u < 0x00200000) ||
        (n == 6 && u < 0x04000000)
    ) return 0; /* invalidly encoded */
    if (out) *out = u;
    return n;
}

MARK_FUNC_AS_USED
static pcc_bool_t pcc_apply_rule(pcc_context_t *ctx, pcc_rule_t rule, pcc_thunk_array_t *thunks, pcc_value_t *value) {
    static pcc_value_t null;
    pcc_thunk_chunk_t *c = NULL;
    const size_t p = ctx->pos + ctx->cur;
    pcc_bool_t b = PCC_TRUE;
    pcc_lr_answer_t *a = pcc_lr_table__get_answer(ctx, &ctx->lrtable, p, rule);
    pcc_lr_head_t *h = pcc_lr_table__get_head(ctx, &ctx->lrtable, p);
    if (h != NULL) {
        if (a == NULL && rule != h->rule && pcc_rule_set__index(ctx->auxil, &h->invol, rule) == PCC_VOID_VALUE) {
            b = PCC_FALSE;
            c = NULL;
        }
        else if (pcc_rule_set__remove(ctx->auxil, &h->eval, rule)) {
            b = PCC_FALSE;
            c = rule(ctx);
            a = pcc_lr_answer__create(ctx, PCC_LR_ANSWER_CHUNK, ctx->pos + ctx->cur);
            a->data.chunk = c;
            pcc_lr_table__hold_answer(ctx, &ctx->lrtable, p, a);
        }
    }
    if (b) {
        if (a != NULL) {
            ctx->cur = a->pos - ctx->pos;
            switch (a->type) {
            case PCC_LR_ANSWER_LR:
                if (a->data.lr->head == NULL) {
                    a->data.lr->head = pcc_lr_head__create(ctx, rule);
                    pcc_lr_table__hold_head(ctx, &ctx->lrtable, p, a->data.lr->head);
                }
                {
                    size_t i = ctx->lrstack.len;
                    while (i > 0) {
                        i--;
                        if (ctx->lrstack.buf[i]->head == a->data.lr->head) break;
                        ctx->lrstack.buf[i]->head = a->data.lr->head;
                        pcc_rule_set__add(ctx->auxil, &a->data.lr->head->invol, ctx->lrstack.buf[i]->rule);
                    }
                }
                c = a->data.lr->seed;
                break;
            case PCC_LR_ANSWER_CHUNK:
                c = a->data.chunk;
                break;
            default: /* unknown */
                break;
            }
        }
        else {
            pcc_lr_entry_t *const e = pcc_lr_entry__create(ctx, rule);
            pcc_lr_stack__push(ctx->auxil, &ctx->lrstack, e);
            a = pcc_lr_answer__create(ctx, PCC_LR_ANSWER_LR, p);
            a->data.lr = e;
            pcc_lr_table__set_answer(ctx, &ctx->lrtable, p, rule, a);
            c = rule(ctx);
            pcc_lr_stack__pop(ctx->auxil, &ctx->lrstack);
            a->pos = ctx->pos + ctx->cur;
            if (e->head == NULL) {
                pcc_lr_answer__set_chunk(ctx, a, c);
            }
            else {
                e->seed = c;
                h = a->data.lr->head;
                if (h->rule != rule) {
                    c = a->data.lr->seed;
                    a = pcc_lr_answer__create(ctx, PCC_LR_ANSWER_CHUNK, ctx->pos + ctx->cur);
                    a->data.chunk = c;
                    pcc_lr_table__hold_answer(ctx, &ctx->lrtable, p, a);
                }
                else {
                    pcc_lr_answer__set_chunk(ctx, a, a->data.lr->seed);
                    if (a->data.chunk == NULL) {
                        c = NULL;
                    }
                    else {
                        pcc_lr_table__set_head(ctx, &ctx->lrtable, p, h);
                        for (;;) {
                            ctx->cur = p - ctx->pos;
                            pcc_rule_set__copy(ctx->auxil, &h->eval, &h->invol);
                            c = rule(ctx);
                            if (c == NULL || ctx->pos + ctx->cur <= a->pos) break;
                            pcc_lr_answer__set_chunk(ctx, a, c);
                            a->pos = ctx->pos + ctx->cur;
                        }
                        pcc_thunk_chunk__destroy(ctx, c);
                        pcc_lr_table__set_head(ctx, &ctx->lrtable, p, NULL);
                        ctx->cur = a->pos - ctx->pos;
                        c = a->data.chunk;
                    }
                }
            }
        }
    }
    if (c == NULL) return PCC_FALSE;
    if (value == NULL) value = &null;
    memset(value, 0, sizeof(pcc_value_t)); /* in case */
    pcc_thunk_array__add(ctx, thunks, pcc_thunk__create_node(ctx, &c->thunks, value));
    return PCC_TRUE;
}

MARK_FUNC_AS_USED
static void pcc_do_action(pcc_context_t *ctx, const pcc_thunk_array_t *thunks, pcc_value_t *value) {
    size_t i;
    for (i = 0; i < thunks->len; i++) {
        pcc_thunk_t *const thunk = thunks->buf[i];
        switch (thunk->type) {
        case PCC_THUNK_LEAF:
            thunk->data.leaf.action(ctx, thunk, value);
            break;
        case PCC_THUNK_NODE:
            pcc_do_action(ctx, thunk->data.node.thunks, thunk->data.node.value);
            break;
        default: /* unknown */
            break;
        }
    }
}

static void pcc_action_LineCommentCapture_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_capture_line_comment(auxil, _0s, _0e);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_DocBlockCommentCapture_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_capture_block_comment(auxil, _0s, _0e);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_BlankLineCapture_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_capture_blank_lines(auxil, _0s, _0e);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_VisibilityIndicator_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
    sysml2_capture_visibility_public(auxil);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_VisibilityIndicator_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
    sysml2_capture_visibility_private(auxil);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_VisibilityIndicator_2(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
    sysml2_capture_visibility_protected(auxil);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Package_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_PACKAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Package_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_LibraryPackage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_LIBRARY_PACKAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_LibraryPackage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Import_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_import(auxil, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Alias_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
#define _2 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.end))
    if (auxil->build_ctx) sysml2_build_alias(auxil->build_ctx, _1, _1e - _1s, _2, _2e - _2s);
#undef _2e
#undef _2s
#undef _2
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_NamespaceDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_NAMESPACE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_NamespaceDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_TypeDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_TYPE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_TypeDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ClassifierDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CLASSIFIER, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ClassifierDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ClassDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CLASS, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ClassDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_StructureDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_STRUCTURE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_StructureDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_MetaclassDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_METACLASS, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_MetaclassDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AssociationDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ASSOCIATION, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AssociationDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AssociationStructureDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ASSOC_STRUCT, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AssociationStructureDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_InteractionDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_INTERACTION, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_InteractionDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_BehaviorDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_BEHAVIOR, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_BehaviorDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_FunctionDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_FUNCTION, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_FunctionDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PredicateDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_PREDICATE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PredicateDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_MultiplicityDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_MULTIPLICITY_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_MultiplicityDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ImplicitFeatureDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_FEATURE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ImplicitFeatureDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_KerMLEndFeature_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_FEATURE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_KerMLEndFeature_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_FeatureDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_FEATURE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_FeatureDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_StepDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_STEP, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_StepDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ExpressionDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_EXPRESSION, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ExpressionDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_BooleanExpressionDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_BOOL_EXPRESSION, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_BooleanExpressionDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_InvariantDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_INVARIANT, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_InvariantDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConnectorDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CONNECTOR, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConnectorDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_BindingConnectorDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_BINDING_CONNECTOR, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_BindingConnectorDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_SuccessionFeatureDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_SUCCESSION, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_SuccessionFeatureDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_KerMLFlowDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_KERML_FLOW, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_KerMLFlowDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_SuccessionFlowDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_SUCCESSION_FLOW, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_SuccessionFlowDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PrefixMetadata_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_capture_prefix_metadata(auxil, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_MetadataUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_capture_start_metadata(auxil, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_MetadataUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_capture_end_metadata(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_MetadataBodyFeature_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
#define _2 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[1])
#define _2s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.start))
#define _2e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[1]->range.end))
    sysml2_capture_metadata_feature(auxil, _1, _1e - _1s, _2, _2e - _2s);
#undef _2e
#undef _2s
#undef _2
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Documentation_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_capture_documentation(auxil, _1s, _1e);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AbstractModifier_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
    if (auxil->build_ctx) sysml2_capture_abstract(auxil->build_ctx);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_VariationModifier_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
    if (auxil->build_ctx) sysml2_capture_variation(auxil->build_ctx);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AttributeDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ATTRIBUTE_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AttributeDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_EnumerationDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ENUMERATION_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_EnumerationDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_DatatypeDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_DATATYPE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_DatatypeDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_EnumeratedValueVariant_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ENUMERATION_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_EnumeratedValueVariant_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_OccurrenceDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_OCCURRENCE_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_OccurrenceDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ItemDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ITEM_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ItemDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PartDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_PART_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PartDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConnectionDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CONNECTION_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConnectionDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_FlowDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_FLOW_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_FlowDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_InterfaceDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_INTERFACE_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_InterfaceDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PortDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_PORT_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PortDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AllocationDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ALLOCATION_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AllocationDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ActionDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ACTION_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ActionDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_StateDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_STATE_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_StateDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConstraintDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CONSTRAINT_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConstraintDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_RequirementDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_REQUIREMENT_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_RequirementDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConcernDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CONCERN_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConcernDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_CalcDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CALC_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_CalcDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_CaseDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CASE_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_CaseDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AnalysisDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ANALYSIS_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AnalysisDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_VerificationDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_VERIFICATION_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_VerificationDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_UseCaseDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_USE_CASE_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_UseCaseDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ViewDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_VIEW_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ViewDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ViewpointDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_VIEWPOINT_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ViewpointDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_RenderingDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_RENDERING_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_RenderingDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_MetadataDefinition_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_METADATA_DEF, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_MetadataDefinition_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AttributeUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ATTRIBUTE_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AttributeUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_EnumerationUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ENUMERATION_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_EnumerationUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_OccurrenceUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_OCCURRENCE_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_OccurrenceUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ItemUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ITEM_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ItemUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PartUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_PART_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PartUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PortUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_PORT_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_PortUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ActionUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ACTION_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ActionUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_StateUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_STATE_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_StateUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConstraintUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CONSTRAINT_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConstraintUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_RequirementUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_REQUIREMENT_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_RequirementUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConcernUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CONCERN_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ConcernUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_CalcUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CALC_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_CalcUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_CaseUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_CASE_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_CaseUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AnalysisUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_ANALYSIS_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_AnalysisUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_VerificationUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_VERIFICATION_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_VerificationUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_UseCaseUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_USE_CASE_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_UseCaseUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ViewUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_VIEW_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ViewUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ViewpointUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_VIEWPOINT_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_ViewpointUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_RenderingUsage_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_build_push(auxil, SYSML_KIND_RENDERING_USAGE, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_RenderingUsage_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    sysml2_pop(auxil);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Direction_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
    if (auxil->build_ctx) sysml2_capture_direction(auxil->build_ctx, SYSML_DIR_INOUT);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Direction_1(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
    if (auxil->build_ctx) sysml2_capture_direction(auxil->build_ctx, SYSML_DIR_OUT);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Direction_2(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
    if (auxil->build_ctx) sysml2_capture_direction(auxil->build_ctx, SYSML_DIR_IN);
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_FeatureValueWithDefault_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    if (auxil->build_ctx) sysml2_capture_default_value(auxil->build_ctx, _1, _1e - _1s, true);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_FeatureValueSimple_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    if (auxil->build_ctx) sysml2_capture_default_value(auxil->build_ctx, _1, _1e - _1s, false);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static void pcc_action_Multiplicity_0(sysml2_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capt0.range.end))
#define _1 pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[0])
#define _1s ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.start))
#define _1e ((const size_t)(__pcc_ctx->pos + __pcc_in->data.leaf.capts.buf[0]->range.end))
    if (auxil->build_ctx) sysml2_capture_multiplicity(auxil->build_ctx, _1, _1e - _1s);
#undef _1e
#undef _1s
#undef _1
#undef _0e
#undef _0s
#undef _0
#undef __
#undef auxil
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_File(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule__(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule__NoDocBlock(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TriviaCapture(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LineCommentCapture(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DocBlockCommentCapture(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BlankLineCapture(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_WS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RegularComment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DocOrRegularComment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EOF(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NAME(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BasicName(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UnrestrictedName(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UnrestrictedNameChar(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EscapeSequence(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StringChar(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IdentCont(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DECIMAL_VALUE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_REAL_VALUE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_STRING_VALUE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_QualifiedName(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NameSegment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ABOUT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ABSTRACT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ACCEPT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ACTION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ACTOR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_AFTER(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ALIAS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ALL(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ALLOCATE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ALLOCATION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ANALYSIS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_AND(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_AS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ASSERT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ASSIGN(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ASSUME(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_AT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ATTRIBUTE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BIND(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BINDING(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BY(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CALC(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CASE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_COMMENT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONCERN(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONNECT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONNECTION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DATATYPE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONSTRAINT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONSTANT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CROSSES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DECIDE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DEF(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DEFAULT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DEFINED(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DEPENDENCY(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DERIVED(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DO(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DOC(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ELSE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_END(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ENTRY(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ENUM(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EVENT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EXHIBIT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EXIT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EXPOSE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FALSE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FILTER(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FIRST(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FLOW(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FOR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FORK(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FRAME(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FROM(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_HASTYPE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_IF(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_IMPLIES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_IMPORT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_IN(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INCLUDE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INDIVIDUAL(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INOUT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INTERFACE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ISTYPE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ITEM(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_JOIN(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_LANGUAGE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_LIBRARY(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_LOCALE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_LOOP(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_MEMBER(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_MERGE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_MESSAGE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_META(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_METADATA(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NEW(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NONUNIQUE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NOT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NULL(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OBJECTIVE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OCCURRENCE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OF(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ORDERED(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OUT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PACKAGE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PARALLEL(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PART(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PERFORM(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PORT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PRIVATE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PROTECTED(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PUBLIC(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_READONLY(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REDEFINES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REF(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REFERENCES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_RENDER(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_RENDERING(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REP(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REQUIRE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REQUIREMENT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_RETURN(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SATISFY(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SEND(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SNAPSHOT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SPECIALIZES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STAKEHOLDER(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STANDARD(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STATE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBJECT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBSETS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUCCESSION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TERMINATE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_THEN(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TIMESLICE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TO(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TRANSITION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TRUE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_UNTIL(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_USE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VAR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VARIANT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VARIATION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VERIFICATION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VERIFY(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VIA(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VIEW(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VIEWPOINT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_WHEN(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_WHILE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_XOR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ASSOC(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BEHAVIOR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BOOL(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CHAINS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CLASS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CLASSIFIER(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_COMPOSITE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONJUGATE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONJUGATES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONJUGATION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONNECTOR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DISJOINT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DISJOINING(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EXPR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FEATURE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FEATURED(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FEATURING(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FUNCTION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INTERACTION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INV(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INVERSE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INVERTING(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_METACLASS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_MULTIPLICITY(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NAMESPACE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PORTION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PREDICATE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REDEFINITION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SPECIALIZATION(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STEP(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STRUCT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBCLASSIFIER(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBSET(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBTYPE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TYPE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TYPING(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_UNIONS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INTERSECTS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DIFFERENCES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SEMICOLON(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_COMMA(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LBRACE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RBRACE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LPAREN(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RPAREN(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LBRACKET(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RBRACKET(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LANGLE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RANGLE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DOT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DOTDOT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DOTQ(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_HASH(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_COLON(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONCOLON(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONCOLON_STAR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONCOLON_STARSTAR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONGT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONGTGT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONCOLONGT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONEQ(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EQ(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EQEQ(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EQEQEQ(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BANGEQ(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BANGEQEQ(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BANG(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PLUS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MINUS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_STAR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_STARSTAR(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SLASH(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PERCENT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CARET(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_GT(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_GE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AMP(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PIPE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TILDE(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_QMARK(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_QMARKQMARK(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ARROW(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SPECIALIZES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SUBSETS(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_REDEFINES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_REFERENCES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TYPED_BY(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Identification(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IdentificationName(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SpecializationKeyword(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ShortName(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_VisibilityIndicator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MemberPrefix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RelationshipBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PackageBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FilterPackageMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Package(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LibraryPackage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PackageBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Import(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ImportDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MembershipImport(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NamespaceImport(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ImportFilter(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Alias(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Dependency(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLDefinitionElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLTypePrefix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NamespaceDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NamespaceBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NamespaceBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeDeclarationPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLSpecializationPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLConjugationPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeRelationshipPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DisjoiningPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UnioningPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IntersectingPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DifferencingPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLTypeBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLTypeBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ShorthandNamedFeature(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CONJUGATES(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassifierDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassifierDeclarationPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StructureDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetaclassDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AssociationDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AssociationStructureDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InteractionDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BehaviorDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLBehaviorBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLBehaviorBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FunctionDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFunctionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFunctionBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnFeatureMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnNamedPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnTypePart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLParameterMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PredicateDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicityDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SpecializationRelationship(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConjugationRelationship(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SubclassificationRelationship(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DisjoiningRelationship(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureInvertingRelationship(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureTypingRelationship(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SubsettingRelationship(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RedefinitionRelationship(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeFeaturingRelationship(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeatureElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ImplicitFeatureDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLEndFeature(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EndCrossFeature(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeaturePrefix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeatureDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeatureSpecializationPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeatureSpecialization(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureRelationshipPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ChainingPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InvertingFeaturePart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeFeaturingPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StepDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExpressionDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BooleanExpressionDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InvariantDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectorDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLConnectorDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLBinaryConnectorPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BindingConnectorDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLBindingConnectorDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionFeatureDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLSuccessionDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionConnectorEnd(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFlowDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFlowDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionFlowDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PrefixMetadata(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataUsageTail(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataBodyFeature(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AnnotatingElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Comment(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Documentation(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TextualRepresentation(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionPrefix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AbstractModifier(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_VariationModifier(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BasicDefinitionPrefix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LifeclassPrefix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UsagePrefix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BasicUsagePrefix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RefPrefix(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AttributeDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumerationDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DatatypeDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumerationBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumeratedValue(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumeratedValueVariant(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceDefinitionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ThenMessageUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceDefinitionMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceDefinitionElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ItemDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PartDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectionDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PortDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PortDefinitionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PortDefinitionMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConjugatedPortDefinitionMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConjugatedPortDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PortUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AllocationDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionBodyItem(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StateDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StateBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StateBodyItem(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StateBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StateUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptTransition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EntryAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExitAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DoAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PerformActionUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EntryTransition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementBodyItem(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_VariantUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConcernDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcBodyItem(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseBodyItem(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AnalysisDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_VerificationDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UseCaseDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewBodyElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewpointDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RenderingDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataDefinition(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionBodyItem(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionSpecializations(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionSpecialization(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PortionUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PortionKind(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PortionUsageKind(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionFirstPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionUsageBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DecisionBranches(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DecisionBranch(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RefBehavioralKeyword(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ReferenceUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StructureUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BehaviorUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IncludeUseCaseUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewUsageElement(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExposeUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AttributeUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumerationUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EventOccurrenceUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EventUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceUsageBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceUsageMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ItemUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PartUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectionUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectionPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BinaryConnectorPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NaryConnectorPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectorEndMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowConnectionPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowEndMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PortUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AllocationUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AllocationPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionParameterList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionParameter(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionUsageBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionAssignBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptActionTail(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SendActionTail(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionWhileBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionForBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ForVariableSpec(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StateUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExhibitStateUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExhibitStateBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConcernUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AnalysisUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_VerificationUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UseCaseUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewpointUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RenderingUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ParameterKind(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ParameterUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Direction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SubjectUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActorUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_StakeholderUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ObjectiveUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FrameUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementReference(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementConstraintKind(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_VerifyRequirementUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnUsageKind(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RenderUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SendAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptParameterPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PayloadParameter(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PayloadFeatureSpec(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TriggerPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TriggerKind(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AssignmentAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IfAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IfThenPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IfElsePart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionBodyParameter(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_WhileLoop(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ForLoop(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ControlNode(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MergeNode(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_DecisionNode(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_JoinNode(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ForkNode(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_GuardedSuccession(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ThenTarget(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionInlineAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptActionUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionName(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionSourceTarget(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionTarget(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionActionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_GuardAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TriggerAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TriggerActionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptPayload(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EffectAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EffectSendAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionEndAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageDeclaration(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageSpecializations(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageSpecialization(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedBy(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Subsets(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Redefines(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_References(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Crosses(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureSpecialization(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureValue(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureValueWithDefault(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureValueSimple(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Multiplicity(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicityBounds(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OrderedNonunique(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageBodyItem(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ShorthandFeatureMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ImplicitInvocation(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageKeyword(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ImplicitShorthand(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BindUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AssertConstraintUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AssertConstraintBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SatisfyUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AssertSatisfyUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AssumeConstraint(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RequireConstraint(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EndMember(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MessageUsage(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MessageFlowPart(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_TerminateAction(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ResultExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OwnedExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConditionalExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ImplicationExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NullCoalescingExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OrExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OrOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_XorExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_XorOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AndExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AndOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EqualityExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EqualityOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassificationExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassificationOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RelationalExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RelationalOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RangeExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AdditiveExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AdditiveOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicativeExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicativeOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExponentiationExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UnaryExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UnaryOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExtentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SequenceExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SequenceTail(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BracketExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_IndexExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectionOperator(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FunctionReferenceArg(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectionBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectionBodyParameter(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectionParameterBody(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_PrimaryExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataReferenceExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetaExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_BodyExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NewExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NullExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataAccessExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_InvocationExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ArgumentList(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ArgumentListItems(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_Argument(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ConditionalArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NullCoalescingArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_OrArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_XorArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AndArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_EqualityArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassificationArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RelationalArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_RangeArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_AdditiveArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicativeArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExponentiationArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_UnaryArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_ExtentArgumentExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_NameExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureChain(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralExpression(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralBoolean(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralString(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralReal(pcc_context_t *ctx);
static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralInteger(pcc_context_t *ctx);

static pcc_thunk_chunk_t *pcc_evaluate_rule_File(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "File", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Package, &chunk->thunks, NULL)) goto L0003;
                goto L0002;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LibraryPackage, &chunk->thunks, NULL)) goto L0004;
                goto L0002;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PackageBodyElement, &chunk->thunks, NULL)) goto L0005;
                goto L0002;
            L0005:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                goto L0001;
            L0002:;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EOF, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "File", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "File", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule__(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "_", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TriviaCapture, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "_", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule__NoDocBlock(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "_NoDocBlock", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LineCommentCapture, &chunk->thunks, NULL)) goto L0003;
                goto L0002;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlankLineCapture, &chunk->thunks, NULL)) goto L0004;
                goto L0002;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_WS, &chunk->thunks, NULL)) goto L0005;
                goto L0002;
            L0005:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                goto L0001;
            L0002:;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "_NoDocBlock", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TriviaCapture(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TriviaCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LineCommentCapture, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DocBlockCommentCapture, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BlankLineCapture, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_WS, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TriviaCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TriviaCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LineCommentCapture(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LineCommentCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '/' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '/'
        ) goto L0000;
        ctx->cur += 2;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0002;
                        if (!(
                            u == 0x00000a ||
                            u == 0x00000d
                        )) goto L0002;
                        ctx->cur += n;
                    }
                    ctx->cur = p;
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_LineCommentCapture_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LineCommentCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LineCommentCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DocBlockCommentCapture(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DocBlockCommentCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '/' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '*' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != '*'
        ) goto L0000;
        ctx->cur += 3;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '*' ||
                        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '/'
                    ) goto L0002;
                    ctx->cur += 2;
                    ctx->cur = p;
                    goto L0001;
                L0002:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '*' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '/'
        ) goto L0000;
        ctx->cur += 2;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_DocBlockCommentCapture_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DocBlockCommentCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DocBlockCommentCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BlankLineCapture(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BlankLineCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0000;
            if (!(
                u == 0x00000a ||
                u == 0x00000d
            )) goto L0000;
            ctx->cur += n;
        }
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0001;
                    if (!(
                        u == 0x00000a ||
                        u == 0x00000d
                    )) goto L0001;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0001:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
                goto L0000;
            }
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_BlankLineCapture_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BlankLineCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BlankLineCapture", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_WS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "WS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    u == 0x000020 ||
                    u == 0x000009 ||
                    u == 0x00000a ||
                    u == 0x00000d ||
                    u == 0x00000c
                )) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
            goto L0000;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "WS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "WS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RegularComment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RegularComment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '/' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '*'
    ) goto L0000;
    ctx->cur += 2;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                const size_t p = ctx->cur;
                if (
                    pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '*' ||
                    pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '/'
                ) goto L0002;
                ctx->cur += 2;
                ctx->cur = p;
                goto L0001;
            L0002:;
                ctx->cur = p;
            }
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '*' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '/'
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RegularComment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RegularComment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DocOrRegularComment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DocOrRegularComment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '/' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '*' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != '*'
        ) goto L0002;
        ctx->cur += 3;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    const size_t p = ctx->cur;
                    if (
                        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '*' ||
                        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '/'
                    ) goto L0004;
                    ctx->cur += 2;
                    ctx->cur = p;
                    goto L0003;
                L0004:;
                    ctx->cur = p;
                }
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0003;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '*' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '/'
        ) goto L0002;
        ctx->cur += 2;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RegularComment, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DocOrRegularComment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DocOrRegularComment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EOF(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EOF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EOF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EOF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NAME(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NAME", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BasicName, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnrestrictedName, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NAME", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NAME", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BasicName(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BasicName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        int u;
        const size_t n = pcc_get_char_as_utf32(ctx, &u);
        if (n == 0) goto L0000;
        if (!(
            (u >= 0x000061 && u <= 0x00007a) ||
            (u >= 0x000041 && u <= 0x00005a) ||
            u == 0x00005f
        )) goto L0000;
        ctx->cur += n;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    (u >= 0x000061 && u <= 0x00007a) ||
                    (u >= 0x000041 && u <= 0x00005a) ||
                    (u >= 0x000030 && u <= 0x000039) ||
                    u == 0x00005f
                )) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BasicName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BasicName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UnrestrictedName(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UnrestrictedName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '\''
    ) goto L0000;
    ctx->cur++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnrestrictedNameChar, &chunk->thunks, NULL)) goto L0003;
                goto L0002;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EscapeSequence, &chunk->thunks, NULL)) goto L0004;
                goto L0002;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                goto L0001;
            L0002:;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '\''
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UnrestrictedName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UnrestrictedName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UnrestrictedNameChar(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UnrestrictedNameChar", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        int u;
        const size_t n = pcc_get_char_as_utf32(ctx, &u);
        if (n == 0) goto L0000;
        if (
            u == 0x000027 ||
            u == 0x00005c
        ) goto L0000;
        ctx->cur += n;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UnrestrictedNameChar", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UnrestrictedNameChar", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EscapeSequence(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EscapeSequence", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '\\'
    ) goto L0000;
    ctx->cur++;
    {
        int u;
        const size_t n = pcc_get_char_as_utf32(ctx, &u);
        if (n == 0) goto L0000;
        if (!(
            u == 0x000066 ||
            u == 0x00006e ||
            u == 0x000072 ||
            u == 0x000074 ||
            u == 0x000076 ||
            u == 0x000027 ||
            u == 0x00005c
        )) goto L0000;
        ctx->cur += n;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EscapeSequence", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EscapeSequence", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StringChar(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StringChar", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        int u;
        const size_t n = pcc_get_char_as_utf32(ctx, &u);
        if (n == 0) goto L0000;
        if (
            u == 0x000022 ||
            u == 0x00005c
        ) goto L0000;
        ctx->cur += n;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StringChar", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StringChar", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IdentCont(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "IdentCont", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        int u;
        const size_t n = pcc_get_char_as_utf32(ctx, &u);
        if (n == 0) goto L0000;
        if (!(
            (u >= 0x000061 && u <= 0x00007a) ||
            (u >= 0x000041 && u <= 0x00005a) ||
            (u >= 0x000030 && u <= 0x000039) ||
            u == 0x00005f
        )) goto L0000;
        ctx->cur += n;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "IdentCont", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "IdentCont", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DECIMAL_VALUE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DECIMAL_VALUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0001;
                if (!(
                    (u >= 0x000030 && u <= 0x000039)
                )) goto L0001;
                ctx->cur += n;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
            goto L0000;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DECIMAL_VALUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DECIMAL_VALUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_REAL_VALUE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "REAL_VALUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0003;
                    if (!(
                        (u >= 0x000030 && u <= 0x000039)
                    )) goto L0003;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
                goto L0002;
            }
        }
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '.'
        ) goto L0002;
        ctx->cur++;
        {
            const size_t p = ctx->cur;
            if (
                pcc_refill_buffer(ctx, 1) < 1 ||
                ctx->buffer.buf[ctx->cur] != '.'
            ) goto L0004;
            ctx->cur++;
            ctx->cur = p;
            goto L0002;
        L0004:;
            ctx->cur = p;
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0005;
                    if (!(
                        (u >= 0x000030 && u <= 0x000039)
                    )) goto L0005;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0005:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0006;
                if (!(
                    u == 0x000065 ||
                    u == 0x000045
                )) goto L0006;
                ctx->cur += n;
            }
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0007;
                    if (!(
                        u == 0x00002b ||
                        u == 0x00002d
                    )) goto L0007;
                    ctx->cur += n;
                }
                goto L0008;
            L0007:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0008:;
            }
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0009;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0009;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0009:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
                    goto L0006;
                }
            }
            goto L0010;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0010:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '.'
        ) goto L0011;
        ctx->cur++;
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0012;
                    if (!(
                        (u >= 0x000030 && u <= 0x000039)
                    )) goto L0012;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0012:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
                goto L0011;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0013;
                if (!(
                    u == 0x000065 ||
                    u == 0x000045
                )) goto L0013;
                ctx->cur += n;
            }
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0014;
                    if (!(
                        u == 0x00002b ||
                        u == 0x00002d
                    )) goto L0014;
                    ctx->cur += n;
                }
                goto L0015;
            L0014:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0015:;
            }
            {
                const size_t p0 = ctx->cur;
                const size_t n0 = chunk->thunks.len;
                int i;
                for (i = 0;; i++) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    {
                        int u;
                        const size_t n = pcc_get_char_as_utf32(ctx, &u);
                        if (n == 0) goto L0016;
                        if (!(
                            (u >= 0x000030 && u <= 0x000039)
                        )) goto L0016;
                        ctx->cur += n;
                    }
                    if (ctx->cur == p) break;
                    continue;
                L0016:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                    break;
                }
                if (i < 1) {
                    ctx->cur = p0;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
                    goto L0013;
                }
            }
            goto L0017;
        L0013:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0017:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0019;
                    if (!(
                        (u >= 0x000030 && u <= 0x000039)
                    )) goto L0019;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0019:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
                goto L0018;
            }
        }
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0018;
            if (!(
                u == 0x000065 ||
                u == 0x000045
            )) goto L0018;
            ctx->cur += n;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            {
                int u;
                const size_t n = pcc_get_char_as_utf32(ctx, &u);
                if (n == 0) goto L0020;
                if (!(
                    u == 0x00002b ||
                    u == 0x00002d
                )) goto L0020;
                ctx->cur += n;
            }
            goto L0021;
        L0020:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0021:;
        }
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    int u;
                    const size_t n = pcc_get_char_as_utf32(ctx, &u);
                    if (n == 0) goto L0022;
                    if (!(
                        (u >= 0x000030 && u <= 0x000039)
                    )) goto L0022;
                    ctx->cur += n;
                }
                if (ctx->cur == p) break;
                continue;
            L0022:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
                goto L0018;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0018;
        goto L0001;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "REAL_VALUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "REAL_VALUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_STRING_VALUE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "STRING_VALUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '\"'
    ) goto L0000;
    ctx->cur++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StringChar, &chunk->thunks, NULL)) goto L0003;
                goto L0002;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EscapeSequence, &chunk->thunks, NULL)) goto L0004;
                goto L0002;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                goto L0001;
            L0002:;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '\"'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "STRING_VALUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "STRING_VALUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_QualifiedName(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "QualifiedName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != ':' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != ':'
        ) goto L0001;
        ctx->cur += 2;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NameSegment, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (
                pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != ':' ||
                pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != ':'
            ) goto L0003;
            ctx->cur += 2;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NameSegment, &chunk->thunks, NULL)) goto L0003;
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "QualifiedName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "QualifiedName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NameSegment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NameSegment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnrestrictedName, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NameSegment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NameSegment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ABOUT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ABOUT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'b' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'o' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'u' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 't'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ABOUT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ABOUT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ABSTRACT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ABSTRACT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'b' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'c' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ABSTRACT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ABSTRACT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ACCEPT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ACCEPT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'c' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'p' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ACCEPT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ACCEPT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ACTION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ACTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'c' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'o' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'n'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ACTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ACTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ACTOR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ACTOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'c' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'o' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ACTOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ACTOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_AFTER(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_AFTER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'f' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_AFTER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_AFTER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ALIAS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ALIAS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'l' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'i' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'a' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ALIAS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ALIAS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ALL(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ALL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'l' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'l'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ALL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ALL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ALLOCATE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ALLOCATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'l' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'l' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'o' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'c' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'e'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ALLOCATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ALLOCATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ALLOCATION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ALLOCATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'l' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'l' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'o' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'c' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'o' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'n'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ALLOCATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ALLOCATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ANALYSIS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ANALYSIS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'l' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'y' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 's' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'i' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 's'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ANALYSIS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ANALYSIS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_AND(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_AND", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'd'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_AND", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_AND", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_AS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_AS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 's'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_AS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_AS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ASSERT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ASSERT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 's' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ASSERT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ASSERT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ASSIGN(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ASSIGN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 's' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'g' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'n'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ASSIGN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ASSIGN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ASSUME(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ASSUME", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 's' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'u' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'm' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ASSUME", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ASSUME", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_AT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_AT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 't'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_AT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_AT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ATTRIBUTE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ATTRIBUTE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 't' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'r' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'b' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'u' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ATTRIBUTE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ATTRIBUTE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BIND(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_BIND", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'b' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'd'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_BIND", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_BIND", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BINDING(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_BINDING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'b' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'd' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'n' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'g'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_BINDING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_BINDING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BY(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_BY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'b' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'y'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_BY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_BY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CALC(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CALC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'l' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'c'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CALC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CALC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CASE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CASE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CASE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CASE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_COMMENT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_COMMENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'm' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'm' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'n' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_COMMENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_COMMENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONCERN(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CONCERN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'c' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CONCERN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CONCERN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONNECT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CONNECT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'c' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CONNECT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CONNECT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONNECTION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CONNECTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'c' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'o' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'n'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CONNECTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CONNECTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DATATYPE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DATATYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'a' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 't' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'y' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'p' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'e'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DATATYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DATATYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONSTRAINT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CONSTRAINT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 't' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'a' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'n' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 't'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CONSTRAINT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CONSTRAINT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONSTANT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CONSTANT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 't' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CONSTANT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CONSTANT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CROSSES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CROSSES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'o' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 's'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CROSSES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CROSSES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DECIDE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DECIDE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'd' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DECIDE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DECIDE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DEF(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DEF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'f'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DEF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DEF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DEFAULT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DEFAULT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'f' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'a' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'l' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DEFAULT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DEFAULT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DEFINED(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DEFINED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'f' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'n' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'd'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DEFINED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DEFINED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DEPENDENCY(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DEPENDENCY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'p' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'n' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'd' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'n' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'c' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'y'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DEPENDENCY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DEPENDENCY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DERIVED(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DERIVED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'v' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'd'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DERIVED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DERIVED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DO(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DO", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DO", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DO", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DOC(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DOC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__NoDocBlock, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DOC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DOC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ELSE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ELSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'l' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ELSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ELSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_END(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_END", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'd'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_END", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_END", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ENTRY(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ENTRY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'r' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'y'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ENTRY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ENTRY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ENUM(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ENUM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'u' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'm'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ENUM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ENUM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EVENT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_EVENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'v' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 't'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_EVENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_EVENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EXHIBIT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_EXHIBIT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'x' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'h' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'b' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_EXHIBIT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_EXHIBIT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EXIT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_EXIT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'x' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'i' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_EXIT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_EXIT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EXPOSE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_EXPOSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'x' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'p' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'o' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_EXPOSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_EXPOSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FALSE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FALSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'l' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FALSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FALSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FILTER(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FILTER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'l' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FILTER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FILTER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FIRST(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FIRST", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 't'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FIRST", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FIRST", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FLOW(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FLOW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'l' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'o' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'w'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FLOW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FLOW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FOR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FORK(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FORK", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'k'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FORK", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FORK", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FRAME(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FRAME", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'm' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FRAME", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FRAME", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FROM(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FROM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'o' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'm'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FROM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FROM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_HASTYPE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_HASTYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'h' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'y' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'p' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_HASTYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_HASTYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_IF(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_IF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'f'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_IF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_IF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_IMPLIES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_IMPLIES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'm' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'p' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'l' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 's'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_IMPLIES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_IMPLIES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_IMPORT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_IMPORT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'm' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'p' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'o' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_IMPORT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_IMPORT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_IN(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_IN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_IN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_IN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INCLUDE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_INCLUDE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'l' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'd' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_INCLUDE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_INCLUDE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INDIVIDUAL(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_INDIVIDUAL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'd' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'v' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'd' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'u' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'a' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'l'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_INDIVIDUAL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_INDIVIDUAL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INOUT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_INOUT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'o' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'u' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 't'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_INOUT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_INOUT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INTERFACE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_INTERFACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'f' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'a' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'c' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_INTERFACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_INTERFACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ISTYPE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ISTYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 's' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'y' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'p' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ISTYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ISTYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ITEM(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ITEM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 't' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'm'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ITEM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ITEM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_JOIN(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_JOIN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'j' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'i' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_JOIN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_JOIN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_LANGUAGE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_LANGUAGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'l' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'g' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'g' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'e'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_LANGUAGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_LANGUAGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_LIBRARY(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_LIBRARY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'l' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'r' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'a' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'y'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_LIBRARY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_LIBRARY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_LOCALE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_LOCALE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'l' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'a' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'l' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_LOCALE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_LOCALE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_LOOP(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_LOOP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'l' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'o' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'p'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_LOOP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_LOOP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_MEMBER(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_MEMBER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'm' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'm' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'b' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_MEMBER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_MEMBER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_MERGE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_MERGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'm' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'g' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_MERGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_MERGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_MESSAGE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_MESSAGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'm' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'a' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'g' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_MESSAGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_MESSAGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_META(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_META", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'm' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'a'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_META", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_META", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_METADATA(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_METADATA", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'm' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'a' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'd' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'a'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_METADATA", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_METADATA", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NEW(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_NEW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'n' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'w'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_NEW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_NEW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NONUNIQUE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_NONUNIQUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'n' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'u' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'n' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'q' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'u' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_NONUNIQUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_NONUNIQUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NOT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_NOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'n' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_NOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_NOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NULL(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_NULL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'n' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'l' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'l'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_NULL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_NULL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OBJECTIVE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_OBJECTIVE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'o' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'b' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'j' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'c' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'i' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'v' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_OBJECTIVE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_OBJECTIVE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OCCURRENCE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_OCCURRENCE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'o' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'c' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'u' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'n' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'c' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'e'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_OCCURRENCE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_OCCURRENCE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OF(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_OF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'o' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'f'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_OF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_OF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_OR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'o' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_OR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_OR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ORDERED(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ORDERED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'o' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'd' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'd'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ORDERED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ORDERED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_OUT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_OUT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'o' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_OUT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_OUT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PACKAGE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PACKAGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'k' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'a' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'g' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PACKAGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PACKAGE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PARALLEL(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PARALLEL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'a' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'l' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'l' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'l'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PARALLEL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PARALLEL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PART(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PART", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PART", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PART", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PERFORM(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PERFORM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'f' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'o' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'm'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PERFORM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PERFORM", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PORT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PORT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PORT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PORT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PRIVATE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PRIVATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'i' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'v' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'a' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PRIVATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PRIVATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PROTECTED(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PROTECTED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'o' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'c' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'e' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'd'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PROTECTED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PROTECTED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PUBLIC(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PUBLIC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'l' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'c'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PUBLIC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PUBLIC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_READONLY(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_READONLY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'd' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'o' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'n' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'l' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'y'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_READONLY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_READONLY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REDEFINES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_REDEFINES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'd' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'f' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'e' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 's'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_REDEFINES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_REDEFINES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REF(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_REF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'f'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_REF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_REF", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REFERENCES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_REFERENCES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'f' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'c' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 's'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_REFERENCES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_REFERENCES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_RENDER(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_RENDER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'd' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_RENDER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_RENDER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_RENDERING(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_RENDERING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'd' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'i' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'n' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'g'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_RENDERING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_RENDERING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REP(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_REP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'p'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_REP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_REP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REQUIRE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_REQUIRE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'q' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'u' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_REQUIRE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_REQUIRE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REQUIREMENT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_REQUIREMENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'q' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'u' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'm' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'n' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 't'
    ) goto L0000;
    ctx->cur += 11;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_REQUIREMENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_REQUIREMENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_RETURN(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_RETURN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'u' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'n'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_RETURN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_RETURN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SATISFY(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SATISFY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'f' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'y'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SATISFY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SATISFY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SEND(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SEND", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'd'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SEND", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SEND", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SNAPSHOT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SNAPSHOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'p' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'h' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'o' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SNAPSHOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SNAPSHOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SPECIALIZES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SPECIALIZES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'p' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'c' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'l' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'z' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'e' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 's'
    ) goto L0000;
    ctx->cur += 11;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SPECIALIZES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SPECIALIZES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STAKEHOLDER(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_STAKEHOLDER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 't' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'k' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'h' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'o' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'l' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'd' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'e' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 'r'
    ) goto L0000;
    ctx->cur += 11;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_STAKEHOLDER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_STAKEHOLDER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STANDARD(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_STANDARD", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 't' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'd' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'r' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'd'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_STANDARD", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_STANDARD", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STATE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_STATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 't' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_STATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_STATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBJECT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SUBJECT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'j' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'c' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SUBJECT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SUBJECT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBSETS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SUBSETS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 's'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SUBSETS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SUBSETS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUCCESSION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SUCCESSION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'c' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 's' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 's' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'o' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'n'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SUCCESSION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SUCCESSION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TERMINATE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_TERMINATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 't' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'm' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'n' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'a' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_TERMINATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_TERMINATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_THEN(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_THEN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 't' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'h' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_THEN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_THEN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TIMESLICE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_TIMESLICE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 't' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'm' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'l' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'i' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'c' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_TIMESLICE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_TIMESLICE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TO(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_TO", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 't' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_TO", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_TO", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TRANSITION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_TRANSITION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 't' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'o' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'n'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_TRANSITION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_TRANSITION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TRUE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_TRUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 't' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'u' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_TRUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_TRUE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_UNTIL(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_UNTIL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'u' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'l'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_UNTIL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_UNTIL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_USE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_USE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'u' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 's' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_USE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_USE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VAR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_VAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'v' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_VAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_VAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VARIANT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_VARIANT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'v' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'a' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'n' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_VARIANT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_VARIANT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VARIATION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_VARIATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'v' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'a' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'i' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'o' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'n'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_VARIATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_VARIATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VERIFICATION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_VERIFICATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'v' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'f' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'c' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'a' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 't' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'i' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 'o' ||
        pcc_refill_buffer(ctx, 12) < 12 || (ctx->buffer.buf + ctx->cur)[11] != 'n'
    ) goto L0000;
    ctx->cur += 12;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_VERIFICATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_VERIFICATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VERIFY(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_VERIFY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'v' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'f' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'y'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_VERIFY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_VERIFY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VIA(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_VIA", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'v' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_VIA", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_VIA", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VIEW(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_VIEW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'v' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'w'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_VIEW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_VIEW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_VIEWPOINT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_VIEWPOINT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'v' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'w' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'p' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'o' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'i' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'n' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 't'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_VIEWPOINT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_VIEWPOINT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_WHEN(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_WHEN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'w' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'h' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_WHEN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_WHEN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_WHILE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_WHILE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'w' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'h' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'i' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'l' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_WHILE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_WHILE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_XOR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_XOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'x' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_XOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_XOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_ASSOC(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_ASSOC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 's' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'o' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'c'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_ASSOC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_ASSOC", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BEHAVIOR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_BEHAVIOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'b' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'h' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'a' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'v' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'o' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'r'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_BEHAVIOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_BEHAVIOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_BOOL(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_BOOL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'b' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'o' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'l'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_BOOL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_BOOL", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CHAINS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CHAINS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'h' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'n' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 's'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CHAINS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CHAINS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CLASS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CLASS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'l' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's'
    ) goto L0000;
    ctx->cur += 5;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CLASS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CLASS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CLASSIFIER(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CLASSIFIER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'l' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'f' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'r'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CLASSIFIER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CLASSIFIER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_COMPOSITE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_COMPOSITE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'm' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'p' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'o' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 's' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'i' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_COMPOSITE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_COMPOSITE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONJUGATE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CONJUGATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'j' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'g' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'a' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CONJUGATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CONJUGATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONJUGATES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CONJUGATES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'j' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'g' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'a' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 's'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CONJUGATES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CONJUGATES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONJUGATION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CONJUGATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'j' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'g' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'a' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'i' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'o' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 'n'
    ) goto L0000;
    ctx->cur += 11;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CONJUGATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CONJUGATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_CONNECTOR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_CONNECTOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'c' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'o' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'r'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_CONNECTOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_CONNECTOR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DISJOINT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DISJOINT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'j' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'o' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DISJOINT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DISJOINT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DISJOINING(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DISJOINING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 's' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'j' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'o' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'n' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'g'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DISJOINING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DISJOINING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_EXPR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_EXPR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'x' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'p' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'r'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_EXPR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_EXPR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FEATURE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FEATURE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FEATURE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FEATURE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FEATURED(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FEATURED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'd'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FEATURED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FEATURED", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FEATURING(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FEATURING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'a' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'i' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'n' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'g'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FEATURING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FEATURING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_FUNCTION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_FUNCTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'f' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'c' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 't' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'o' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'n'
    ) goto L0000;
    ctx->cur += 8;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_FUNCTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_FUNCTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INTERACTION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_INTERACTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'c' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'i' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'o' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 'n'
    ) goto L0000;
    ctx->cur += 11;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_INTERACTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_INTERACTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INV(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_INV", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'v'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_INV", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_INV", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INVERSE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_INVERSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'v' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 's' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_INVERSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_INVERSE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INVERTING(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_INVERTING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'v' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'i' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'n' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'g'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_INVERTING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_INVERTING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_METACLASS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_METACLASS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'm' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'a' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'c' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'l' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'a' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 's' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 's'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_METACLASS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_METACLASS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_MULTIPLICITY(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_MULTIPLICITY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'm' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'l' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'p' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'l' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'c' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'i' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 't' ||
        pcc_refill_buffer(ctx, 12) < 12 || (ctx->buffer.buf + ctx->cur)[11] != 'y'
    ) goto L0000;
    ctx->cur += 12;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_MULTIPLICITY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_MULTIPLICITY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_NAMESPACE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_NAMESPACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'n' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'a' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'm' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 's' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'p' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'a' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'c' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_NAMESPACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_NAMESPACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PORTION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PORTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'o' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PORTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PORTION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_PREDICATE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_PREDICATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'r' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'd' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'c' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'a' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 't' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e'
    ) goto L0000;
    ctx->cur += 9;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_PREDICATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_PREDICATE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_REDEFINITION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_REDEFINITION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'd' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'f' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 't' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'i' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 'o' ||
        pcc_refill_buffer(ctx, 12) < 12 || (ctx->buffer.buf + ctx->cur)[11] != 'n'
    ) goto L0000;
    ctx->cur += 12;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_REDEFINITION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_REDEFINITION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SPECIALIZATION(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SPECIALIZATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'p' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'c' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'l' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'z' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'a' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 't' ||
        pcc_refill_buffer(ctx, 12) < 12 || (ctx->buffer.buf + ctx->cur)[11] != 'i' ||
        pcc_refill_buffer(ctx, 13) < 13 || (ctx->buffer.buf + ctx->cur)[12] != 'o' ||
        pcc_refill_buffer(ctx, 14) < 14 || (ctx->buffer.buf + ctx->cur)[13] != 'n'
    ) goto L0000;
    ctx->cur += 14;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SPECIALIZATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SPECIALIZATION", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STEP(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_STEP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 't' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'p'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_STEP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_STEP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_STRUCT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_STRUCT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 't' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'u' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'c' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_STRUCT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_STRUCT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBCLASSIFIER(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SUBCLASSIFIER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'c' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'l' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 's' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 's' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'i' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'f' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 'i' ||
        pcc_refill_buffer(ctx, 12) < 12 || (ctx->buffer.buf + ctx->cur)[11] != 'e' ||
        pcc_refill_buffer(ctx, 13) < 13 || (ctx->buffer.buf + ctx->cur)[12] != 'r'
    ) goto L0000;
    ctx->cur += 13;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SUBCLASSIFIER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SUBCLASSIFIER", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBSET(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SUBSET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SUBSET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SUBSET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_SUBTYPE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_SUBTYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'b' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 't' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'y' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'p' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
    ) goto L0000;
    ctx->cur += 7;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_SUBTYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_SUBTYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TYPE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_TYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 't' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'y' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'p' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e'
    ) goto L0000;
    ctx->cur += 4;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_TYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_TYPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_TYPING(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_TYPING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 't' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'y' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'p' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'n' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'g'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_TYPING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_TYPING", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_UNIONS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_UNIONS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'u' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'i' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'o' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'n' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 's'
    ) goto L0000;
    ctx->cur += 6;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_UNIONS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_UNIONS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_INTERSECTS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_INTERSECTS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 't' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 's' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'c' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 't' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 's'
    ) goto L0000;
    ctx->cur += 10;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_INTERSECTS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_INTERSECTS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KW_DIFFERENCES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KW_DIFFERENCES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'i' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'f' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'f' ||
        pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
        pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
        pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e' ||
        pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'n' ||
        pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'c' ||
        pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'e' ||
        pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 's'
    ) goto L0000;
    ctx->cur += 11;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KW_DIFFERENCES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KW_DIFFERENCES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SEMICOLON(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SEMICOLON", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != ';'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SEMICOLON", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SEMICOLON", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_COMMA(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "COMMA", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != ','
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "COMMA", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "COMMA", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LBRACE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LBRACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '{'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LBRACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LBRACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RBRACE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RBRACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '}'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RBRACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RBRACE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LPAREN(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LPAREN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '('
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LPAREN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LPAREN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RPAREN(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RPAREN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != ')'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RPAREN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RPAREN", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LBRACKET(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LBRACKET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '['
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LBRACKET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LBRACKET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RBRACKET(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RBRACKET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != ']'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RBRACKET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RBRACKET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LANGLE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LANGLE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '<'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003d
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LANGLE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LANGLE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RANGLE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RANGLE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '>'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003d
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RANGLE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RANGLE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DOT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '.'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00002e ||
                u == 0x00003f
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DOTDOT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DOTDOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '.' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '.'
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DOTDOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DOTDOT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DOTQ(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DOTQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '.' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '?'
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DOTQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DOTQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_HASH(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "HASH", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '#'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "HASH", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "HASH", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '@'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_COLON(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "COLON", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != ':'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003e ||
                u == 0x00003a ||
                u == 0x00003d
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "COLON", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "COLON", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONCOLON(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "COLONCOLON", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != ':' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != ':'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003e ||
                u == 0x00002a
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "COLONCOLON", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "COLONCOLON", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONCOLON_STAR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "COLONCOLON_STAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != ':' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != ':' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != '*'
    ) goto L0000;
    ctx->cur += 3;
    {
        const size_t p = ctx->cur;
        if (
            pcc_refill_buffer(ctx, 1) < 1 ||
            ctx->buffer.buf[ctx->cur] != '*'
        ) goto L0001;
        ctx->cur++;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "COLONCOLON_STAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "COLONCOLON_STAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONCOLON_STARSTAR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "COLONCOLON_STARSTAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != ':' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != ':' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != '*' ||
        pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != '*'
    ) goto L0000;
    ctx->cur += 4;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "COLONCOLON_STARSTAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "COLONCOLON_STARSTAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONGT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "COLONGT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != ':' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '>'
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003e
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "COLONGT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "COLONGT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONGTGT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "COLONGTGT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != ':' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '>' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != '>'
    ) goto L0000;
    ctx->cur += 3;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "COLONGTGT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "COLONGTGT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONCOLONGT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "COLONCOLONGT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != ':' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != ':' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != '>'
    ) goto L0000;
    ctx->cur += 3;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "COLONCOLONGT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "COLONCOLONGT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_COLONEQ(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "COLONEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != ':' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '='
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "COLONEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "COLONEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EQ(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '='
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003d
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EQEQ(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EQEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '=' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '='
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003d
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EQEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EQEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EQEQEQ(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EQEQEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '=' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '=' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != '='
    ) goto L0000;
    ctx->cur += 3;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EQEQEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EQEQEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BANGEQ(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BANGEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '!' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '='
    ) goto L0000;
    ctx->cur += 2;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003d
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BANGEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BANGEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BANGEQEQ(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BANGEQEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '!' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '=' ||
        pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != '='
    ) goto L0000;
    ctx->cur += 3;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BANGEQEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BANGEQEQ", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BANG(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BANG", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '!'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003d
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BANG", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BANG", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PLUS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PLUS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '+'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PLUS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PLUS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MINUS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MINUS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '-'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003e
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MINUS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MINUS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_STAR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "STAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '*'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00002a
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "STAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "STAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_STARSTAR(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "STARSTAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '*' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '*'
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "STARSTAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "STARSTAR", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SLASH(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SLASH", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '/'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SLASH", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SLASH", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PERCENT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PERCENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '%'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PERCENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PERCENT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CARET(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CARET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '^'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CARET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CARET", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '<'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003d
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_GT(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "GT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '>'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003d
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "GT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "GT", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '<' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '='
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_GE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "GE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '>' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '='
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "GE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "GE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AMP(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AMP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '&'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AMP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AMP", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PIPE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PIPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '|'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PIPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PIPE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TILDE(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TILDE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '~'
    ) goto L0000;
    ctx->cur++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TILDE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TILDE", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_QMARK(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "QMARK", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 ||
        ctx->buffer.buf[ctx->cur] != '?'
    ) goto L0000;
    ctx->cur++;
    {
        const size_t p = ctx->cur;
        {
            int u;
            const size_t n = pcc_get_char_as_utf32(ctx, &u);
            if (n == 0) goto L0001;
            if (!(
                u == 0x00003f
            )) goto L0001;
            ctx->cur += n;
        }
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "QMARK", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "QMARK", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_QMARKQMARK(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "QMARKQMARK", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '?' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '?'
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "QMARKQMARK", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "QMARKQMARK", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ARROW(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ARROW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (
        pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != '-' ||
        pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != '>'
    ) goto L0000;
    ctx->cur += 2;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ARROW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ARROW", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SPECIALIZES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SPECIALIZES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONGT, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SPECIALIZES, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SPECIALIZES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SPECIALIZES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SUBSETS(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SUBSETS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONGT, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUBSETS, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SUBSETS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SUBSETS", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_REDEFINES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "REDEFINES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONGTGT, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REDEFINES, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "REDEFINES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "REDEFINES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_REFERENCES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "REFERENCES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONCOLONGT, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REFERENCES, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "REFERENCES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "REFERENCES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TYPED_BY(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TYPED_BY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEFINED, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BY, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TYPED_BY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TYPED_BY", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Identification(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Identification", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShortName, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentificationName, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Identification", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IdentificationName(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "IdentificationName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SpecializationKeyword, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ABOUT, &chunk->thunks, NULL)) goto L0002;
        ctx->cur = p;
        goto L0000;
    L0002:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_LOCALE, &chunk->thunks, NULL)) goto L0003;
        ctx->cur = p;
        goto L0000;
    L0003:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FROM, &chunk->thunks, NULL)) goto L0004;
        ctx->cur = p;
        goto L0000;
    L0004:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0005;
        ctx->cur = p;
        goto L0000;
    L0005:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0006;
        ctx->cur = p;
        goto L0000;
    L0006:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIA, &chunk->thunks, NULL)) goto L0007;
        ctx->cur = p;
        goto L0000;
    L0007:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "IdentificationName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "IdentificationName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SpecializationKeyword(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SpecializationKeyword", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'd' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'f' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n' ||
            pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'e' ||
            pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 's'
        ) goto L0002;
        ctx->cur += 9;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'u' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'b' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 's' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 's'
        ) goto L0003;
        ctx->cur += 7;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'r' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'f' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'r' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'n' ||
            pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'c' ||
            pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'e' ||
            pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 's'
        ) goto L0004;
        ctx->cur += 10;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'p' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'e' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'c' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'i' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'l' ||
            pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'i' ||
            pcc_refill_buffer(ctx, 9) < 9 || (ctx->buffer.buf + ctx->cur)[8] != 'z' ||
            pcc_refill_buffer(ctx, 10) < 10 || (ctx->buffer.buf + ctx->cur)[9] != 'e' ||
            pcc_refill_buffer(ctx, 11) < 11 || (ctx->buffer.buf + ctx->cur)[10] != 's'
        ) goto L0005;
        ctx->cur += 11;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'd' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'f' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'n' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'e' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'd'
        ) goto L0006;
        ctx->cur += 7;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0007;
        ctx->cur = p;
        goto L0000;
    L0007:;
        ctx->cur = p;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SpecializationKeyword", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SpecializationKeyword", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ShortName(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ShortName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LANGLE, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STRING_VALUE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RANGLE, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ShortName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ShortName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_VisibilityIndicator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "VisibilityIndicator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PUBLIC, &chunk->thunks, NULL)) goto L0002;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_VisibilityIndicator_0, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PRIVATE, &chunk->thunks, NULL)) goto L0003;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_VisibilityIndicator_1, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PROTECTED, &chunk->thunks, NULL)) goto L0004;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_VisibilityIndicator_2, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "VisibilityIndicator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "VisibilityIndicator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MemberPrefix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MemberPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VisibilityIndicator, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MemberPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RelationshipBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RelationshipBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RelationshipBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RelationshipBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PackageBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PackageBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertConstraintUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BindUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandFeatureMember, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageElement, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FilterPackageMember, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PackageBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PackageBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FilterPackageMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FilterPackageMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FILTER, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FilterPackageMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FilterPackageMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Package(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Package", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PACKAGE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Package_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PackageBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Package_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Package", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Package", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LibraryPackage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LibraryPackage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STANDARD, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_LIBRARY, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0003;
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PACKAGE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_LibraryPackage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PackageBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_LibraryPackage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LibraryPackage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LibraryPackage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PackageBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PackageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PackageBodyElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PackageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PackageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Import(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Import", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IMPORT, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImportDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Import_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImportFilter, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Import", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Import", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ImportDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ImportDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamespaceImport, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MembershipImport, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ImportDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ImportDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MembershipImport(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MembershipImport", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONCOLON, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STARSTAR, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MembershipImport", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MembershipImport", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NamespaceImport(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NamespaceImport", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONCOLON_STAR, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONCOLON_STARSTAR, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONCOLON_STARSTAR, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NamespaceImport", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NamespaceImport", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ImportFilter(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ImportFilter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACKET, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACKET, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ImportFilter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ImportFilter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Alias(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Alias", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 2);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALIAS, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShortName, &chunk->thunks, NULL)) goto L0002;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0002;
            goto L0001;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShortName, &chunk->thunks, NULL)) goto L0003;
            goto L0001;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0004;
            goto L0001;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0000;
        L0001:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FOR, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[1].range.start = p;
        chunk->capts.buf[1].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[1].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Alias_0, 0, 2);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Alias", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Alias", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Dependency(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Dependency", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEPENDENCY, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FROM, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0004;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0004;
            if (ctx->cur == p) break;
            continue;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0005;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0005;
            if (ctx->cur == p) break;
            continue;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Dependency", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Dependency", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLDefinitionElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLDefinitionElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamespaceDefinition, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeDefinition, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDefinition, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassDefinition, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StructureDefinition, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetaclassDefinition, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssociationDefinition, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssociationStructureDefinition, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InteractionDefinition, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BehaviorDefinition, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FunctionDefinition, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PredicateDefinition, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MultiplicityDefinition, &chunk->thunks, NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SpecializationRelationship, &chunk->thunks, NULL)) goto L0015;
        goto L0001;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConjugationRelationship, &chunk->thunks, NULL)) goto L0016;
        goto L0001;
    L0016:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SubclassificationRelationship, &chunk->thunks, NULL)) goto L0017;
        goto L0001;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DisjoiningRelationship, &chunk->thunks, NULL)) goto L0018;
        goto L0001;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureInvertingRelationship, &chunk->thunks, NULL)) goto L0019;
        goto L0001;
    L0019:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureTypingRelationship, &chunk->thunks, NULL)) goto L0020;
        goto L0001;
    L0020:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SubsettingRelationship, &chunk->thunks, NULL)) goto L0021;
        goto L0001;
    L0021:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RedefinitionRelationship, &chunk->thunks, NULL)) goto L0022;
        goto L0001;
    L0022:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeFeaturingRelationship, &chunk->thunks, NULL)) goto L0023;
        goto L0001;
    L0023:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLDefinitionElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLDefinitionElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLTypePrefix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLTypePrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AbstractModifier, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0003;
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLTypePrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NamespaceDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NamespaceDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NAMESPACE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_NamespaceDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamespaceBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_NamespaceDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NamespaceDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NamespaceDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NamespaceBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NamespaceBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NamespaceBodyElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NamespaceBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NamespaceBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NamespaceBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NamespaceBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLDefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NamespaceBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NamespaceBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TypeDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TYPE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeDeclarationPart, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_TypeDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_TypeDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TypeDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TypeDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeDeclarationPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TypeDeclarationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLSpecializationPart, &chunk->thunks, NULL)) goto L0005;
            goto L0004;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLConjugationPart, &chunk->thunks, NULL)) goto L0006;
            goto L0004;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0003;
        L0004:;
        }
        goto L0007;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0007:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeRelationshipPart, &chunk->thunks, NULL)) goto L0008;
            if (ctx->cur == p) break;
            continue;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TypeDeclarationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLSpecializationPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLSpecializationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SPECIALIZES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLSpecializationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLSpecializationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLConjugationPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLConjugationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CONJUGATES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLConjugationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLConjugationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeRelationshipPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TypeRelationshipPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DisjoiningPart, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnioningPart, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IntersectingPart, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DifferencingPart, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TypeRelationshipPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TypeRelationshipPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DisjoiningPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DisjoiningPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DISJOINT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FROM, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0004;
                goto L0005;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0005:;
            }
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DisjoiningPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DisjoiningPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UnioningPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UnioningPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_UNIONS, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UnioningPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UnioningPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IntersectingPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "IntersectingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INTERSECTS, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "IntersectingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "IntersectingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DifferencingPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DifferencingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DIFFERENCES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DifferencingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DifferencingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLTypeBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLTypeBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBodyElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLTypeBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLTypeBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLTypeBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLTypeBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLDefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLParameterMember, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandNamedFeature, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLTypeBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLTypeBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ShorthandNamedFeature(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ShorthandNamedFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureSpecializationPart, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureRelationshipPart, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ShorthandNamedFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ShorthandNamedFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CONJUGATES(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CONJUGATES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TILDE, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONJUGATES, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CONJUGATES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CONJUGATES", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassifierDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ClassifierDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CLASSIFIER, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ClassifierDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ClassifierDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ClassifierDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ClassifierDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassifierDeclarationPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ClassifierDeclarationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLSpecializationPart, &chunk->thunks, NULL)) goto L0005;
            goto L0004;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLConjugationPart, &chunk->thunks, NULL)) goto L0006;
            goto L0004;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0003;
        L0004:;
        }
        goto L0007;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0007:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeRelationshipPart, &chunk->thunks, NULL)) goto L0008;
            if (ctx->cur == p) break;
            continue;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ClassifierDeclarationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ClassDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CLASS, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ClassDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ClassDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ClassDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ClassDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StructureDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StructureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STRUCT, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_StructureDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_StructureDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StructureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StructureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetaclassDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetaclassDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_METACLASS, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MetaclassDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MetaclassDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetaclassDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetaclassDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AssociationDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AssociationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ASSOC, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STRUCT, &chunk->thunks, NULL)) goto L0003;
        ctx->cur = p;
        goto L0000;
    L0003:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AssociationDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AssociationDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AssociationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AssociationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AssociationStructureDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AssociationStructureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ASSOC, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STRUCT, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AssociationStructureDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AssociationStructureDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AssociationStructureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AssociationStructureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InteractionDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InteractionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INTERACTION, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_InteractionDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_InteractionDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InteractionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InteractionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BehaviorDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BehaviorDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BEHAVIOR, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_BehaviorDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLBehaviorBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_BehaviorDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BehaviorDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BehaviorDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLBehaviorBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLBehaviorBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLBehaviorBodyElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLBehaviorBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLBehaviorBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLBehaviorBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLBehaviorBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLParameterMember, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLDefinitionElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLBehaviorBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLBehaviorBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FunctionDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FunctionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FUNCTION, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_FunctionDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFunctionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_FunctionDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FunctionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FunctionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFunctionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLFunctionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFunctionBodyElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ResultExpression, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLFunctionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLFunctionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFunctionBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLFunctionBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReturnFeatureMember, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLParameterMember, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLDefinitionElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureElement, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLFunctionBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLFunctionBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnFeatureMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ReturnFeatureMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_RETURN, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureDefinition, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLParameterMember, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReturnNamedPart, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReturnTypePart, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ReturnFeatureMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ReturnFeatureMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnNamedPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ReturnNamedPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureSpecializationPart, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ReturnNamedPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ReturnNamedPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnTypePart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ReturnTypePart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ReturnTypePart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ReturnTypePart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLParameterMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLParameterMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Direction, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AbstractModifier, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FEATURE, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageSpecializations, &chunk->thunks, NULL)) goto L0007;
            goto L0008;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0008:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0009;
        goto L0010;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0010:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLParameterMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLParameterMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PredicateDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PredicateDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PREDICATE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassifierDeclarationPart, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PredicateDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFunctionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PredicateDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PredicateDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PredicateDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicityDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MultiplicityDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_MULTIPLICITY, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUBSETS, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MultiplicityDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MultiplicityDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MultiplicityDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MultiplicityDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SpecializationRelationship(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SpecializationRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SPECIALIZATION, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUBTYPE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SPECIALIZES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SpecializationRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SpecializationRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConjugationRelationship(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConjugationRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONJUGATION, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONJUGATE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CONJUGATES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConjugationRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConjugationRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SubclassificationRelationship(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SubclassificationRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SPECIALIZATION, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUBCLASSIFIER, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SPECIALIZES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SubclassificationRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SubclassificationRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DisjoiningRelationship(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DisjoiningRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DISJOINING, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DISJOINT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FROM, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0007;
        goto L0008;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DisjoiningRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DisjoiningRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureInvertingRelationship(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FeatureInvertingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INVERTING, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INVERSE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FeatureInvertingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FeatureInvertingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureTypingRelationship(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FeatureTypingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SPECIALIZATION, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TYPING, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TYPED_BY, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FeatureTypingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FeatureTypingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SubsettingRelationship(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SubsettingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SPECIALIZATION, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUBSET, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SUBSETS, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0007;
        goto L0008;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SubsettingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SubsettingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RedefinitionRelationship(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RedefinitionRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SPECIALIZATION, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REDEFINITION, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_REDEFINES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RedefinitionRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RedefinitionRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeFeaturingRelationship(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TypeFeaturingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FEATURING, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BY, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TypeFeaturingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TypeFeaturingRelationship", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeatureElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLFeatureElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLEndFeature, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImplicitFeatureDefinition, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureDefinition, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StepDefinition, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExpressionDefinition, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BooleanExpressionDefinition, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InvariantDefinition, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorDefinition, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BindingConnectorDefinition, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionFeatureDefinition, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFlowDefinition, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionFlowDefinition, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLFeatureElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLFeatureElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ImplicitFeatureDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ImplicitFeatureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_COMPOSITE, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PORTION, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ImplicitFeatureDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ImplicitFeatureDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ImplicitFeatureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ImplicitFeatureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLEndFeature(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLEndFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_END, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EndCrossFeature, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FEATURE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_KerMLEndFeature_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_KerMLEndFeature_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLEndFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLEndFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EndCrossFeature(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EndCrossFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureSpecializationPart, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EndCrossFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EndCrossFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeaturePrefix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLFeaturePrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Direction, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DERIVED, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AbstractModifier, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_COMPOSITE, &chunk->thunks, NULL)) goto L0009;
            goto L0008;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PORTION, &chunk->thunks, NULL)) goto L0010;
            goto L0008;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0007;
        L0008:;
        }
        goto L0011;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0011:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VAR, &chunk->thunks, NULL)) goto L0014;
            goto L0013;
        L0014:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_READONLY, &chunk->thunks, NULL)) goto L0015;
            goto L0013;
        L0015:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTANT, &chunk->thunks, NULL)) goto L0016;
            goto L0013;
        L0016:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0012;
        L0013:;
        }
        goto L0017;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0017:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_END, &chunk->thunks, NULL)) goto L0018;
        goto L0019;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0019:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0020;
            if (ctx->cur == p) break;
            continue;
        L0020:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLFeaturePrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FeatureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_MEMBER, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FEATURE, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_FeatureDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0007;
        goto L0008;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_FeatureDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FeatureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FeatureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeatureDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLFeatureDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureSpecializationPart, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureRelationshipPart, &chunk->thunks, NULL)) goto L0005;
            if (ctx->cur == p) break;
            continue;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLFeatureDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeatureSpecializationPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLFeatureSpecializationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureSpecialization, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
            goto L0000;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLFeatureSpecializationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLFeatureSpecializationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFeatureSpecialization(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLFeatureSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Subsets, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_References, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Redefines, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Crosses, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLFeatureSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLFeatureSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureRelationshipPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FeatureRelationshipPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeRelationshipPart, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ChainingPart, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InvertingFeaturePart, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeFeaturingPart, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FeatureRelationshipPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FeatureRelationshipPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ChainingPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ChainingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CHAINS, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ChainingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ChainingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InvertingFeaturePart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InvertingFeaturePart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INVERSE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InvertingFeaturePart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InvertingFeaturePart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypeFeaturingPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TypeFeaturingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FEATURED, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BY, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TypeFeaturingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TypeFeaturingPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StepDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StepDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STEP, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_StepDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_StepDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StepDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StepDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExpressionDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExpressionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EXPR, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ExpressionDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFunctionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ExpressionDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExpressionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExpressionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BooleanExpressionDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BooleanExpressionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BOOL, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_BooleanExpressionDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFunctionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_BooleanExpressionDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BooleanExpressionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BooleanExpressionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InvariantDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InvariantDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INV, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TRUE, &chunk->thunks, NULL)) goto L0003;
            goto L0002;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FALSE, &chunk->thunks, NULL)) goto L0004;
            goto L0002;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0001;
        L0002:;
        }
        goto L0005;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_InvariantDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0008;
        goto L0009;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0009:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFunctionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_InvariantDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InvariantDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InvariantDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectorDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConnectorDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONNECTOR, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLConnectorDeclaration, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConnectorDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConnectorDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConnectorDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConnectorDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLConnectorDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLConnectorDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLBinaryConnectorPart, &chunk->thunks, NULL)) goto L0005;
            goto L0004;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NaryConnectorPart, &chunk->thunks, NULL)) goto L0006;
            goto L0004;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0003;
        L0004:;
        }
        goto L0007;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0007:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLConnectorDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLBinaryConnectorPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLBinaryConnectorPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FROM, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLBinaryConnectorPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLBinaryConnectorPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BindingConnectorDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BindingConnectorDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BINDING, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLBindingConnectorDeclaration, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_BindingConnectorDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_BindingConnectorDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BindingConnectorDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BindingConnectorDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLBindingConnectorDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLBindingConnectorDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQ, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQ, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLBindingConnectorDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLBindingConnectorDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionFeatureDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SuccessionFeatureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUCCESSION, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FLOW, &chunk->thunks, NULL)) goto L0003;
        ctx->cur = p;
        goto L0000;
    L0003:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLSuccessionDeclaration, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_SuccessionFeatureDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_SuccessionFeatureDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SuccessionFeatureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SuccessionFeatureDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLSuccessionDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLSuccessionDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FIRST, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionConnectorEnd, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionConnectorEnd, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionConnectorEnd, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionConnectorEnd, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLSuccessionDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLSuccessionDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionConnectorEnd(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SuccessionConnectorEnd", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SuccessionConnectorEnd", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SuccessionConnectorEnd", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFlowDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLFlowDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FLOW, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFlowDeclaration, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_KerMLFlowDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_KerMLFlowDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLFlowDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "KerMLFlowDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_KerMLFlowDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "KerMLFlowDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureDeclaration, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FROM, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "KerMLFlowDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionFlowDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SuccessionFlowDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeaturePrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUCCESSION, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FLOW, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFlowDeclaration, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_SuccessionFlowDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLTypeBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_SuccessionFlowDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SuccessionFlowDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SuccessionFlowDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PrefixMetadata(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PrefixMetadata", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_HASH, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PrefixMetadata_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PrefixMetadata", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PrefixMetadata", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetadataUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AT, &chunk->thunks, NULL)) goto L0002;
        {
            const size_t p = ctx->cur;
            size_t q;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
            q = ctx->cur;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MetadataUsage_0, 0, 1);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataUsageTail, &chunk->thunks, NULL)) goto L0002;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MetadataUsage_1, 0, 1);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AT, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_METADATA, &chunk->thunks, NULL)) goto L0003;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLON, &chunk->thunks, NULL)) goto L0008;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ABOUT, &chunk->thunks, NULL)) goto L0010;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0010;
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0011;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0011;
                    if (ctx->cur == p) break;
                    continue;
                L0011:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                    break;
                }
            }
            goto L0012;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0012:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataBody, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetadataUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetadataUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataUsageTail(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetadataUsageTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ABOUT, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0002;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
                if (ctx->cur == p) break;
                continue;
            L0002:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        goto L0003;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataBody, &chunk->thunks, NULL)) goto L0005;
        goto L0004;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0006;
        goto L0004;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0004:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetadataUsageTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetadataUsageTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetadataBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataBodyElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetadataBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetadataBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetadataBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataBodyFeature, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandFeatureMember, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetadataBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetadataBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataBodyFeature(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetadataBodyFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 2);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REF, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        q = ctx->cur;
        chunk->capts.buf[1].range.start = p;
        chunk->capts.buf[1].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[1].string, 0);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0006;
        goto L0005;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataBody, &chunk->thunks, NULL)) goto L0007;
        goto L0005;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0005:;
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MetadataBodyFeature_0, 0, 2);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capts.buf[1] = &(chunk->capts.buf[1]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetadataBodyFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetadataBodyFeature", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AnnotatingElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AnnotatingElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Comment, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Documentation, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TextualRepresentation, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AnnotatingElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AnnotatingElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Comment(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Comment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_COMMENT, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ABOUT, &chunk->thunks, NULL)) goto L0002;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
            {
                for (;;) {
                    const size_t p = ctx->cur;
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0003;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
                    if (ctx->cur == p) break;
                    continue;
                L0003:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                    break;
                }
            }
            goto L0004;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        goto L0005;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_LOCALE, &chunk->thunks, NULL)) goto L0006;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STRING_VALUE, &chunk->thunks, NULL)) goto L0006;
        goto L0007;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0007:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DocOrRegularComment, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Comment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Comment", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Documentation(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Documentation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DOC, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_LOCALE, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STRING_VALUE, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DocOrRegularComment, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Documentation_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Documentation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Documentation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TextualRepresentation(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TextualRepresentation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REP, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_LANGUAGE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STRING_VALUE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DocOrRegularComment, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TextualRepresentation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TextualRepresentation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DefinitionElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLDefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DatatypeDefinition, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AttributeDefinition, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EnumerationDefinition, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ItemDefinition, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PartDefinition, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectionDefinition, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowDefinition, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InterfaceDefinition, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortDefinition, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AllocationDefinition, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionDefinition, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateDefinition, &chunk->thunks, NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintDefinition, &chunk->thunks, NULL)) goto L0015;
        goto L0001;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementDefinition, &chunk->thunks, NULL)) goto L0016;
        goto L0001;
    L0016:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConcernDefinition, &chunk->thunks, NULL)) goto L0017;
        goto L0001;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcDefinition, &chunk->thunks, NULL)) goto L0018;
        goto L0001;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseDefinition, &chunk->thunks, NULL)) goto L0019;
        goto L0001;
    L0019:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnalysisDefinition, &chunk->thunks, NULL)) goto L0020;
        goto L0001;
    L0020:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VerificationDefinition, &chunk->thunks, NULL)) goto L0021;
        goto L0001;
    L0021:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UseCaseDefinition, &chunk->thunks, NULL)) goto L0022;
        goto L0001;
    L0022:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewDefinition, &chunk->thunks, NULL)) goto L0023;
        goto L0001;
    L0023:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewpointDefinition, &chunk->thunks, NULL)) goto L0024;
        goto L0001;
    L0024:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RenderingDefinition, &chunk->thunks, NULL)) goto L0025;
        goto L0001;
    L0025:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataDefinition, &chunk->thunks, NULL)) goto L0026;
        goto L0001;
    L0026:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceDefinition, &chunk->thunks, NULL)) goto L0027;
        goto L0001;
    L0027:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Package, &chunk->thunks, NULL)) goto L0028;
        goto L0001;
    L0028:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LibraryPackage, &chunk->thunks, NULL)) goto L0029;
        goto L0001;
    L0029:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Dependency, &chunk->thunks, NULL)) goto L0030;
        goto L0001;
    L0030:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DefinitionElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DefinitionElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionPrefix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DefinitionPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AbstractModifier, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VariationModifier, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BasicDefinitionPrefix, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DefinitionPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DefinitionPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AbstractModifier(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AbstractModifier", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ABSTRACT, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AbstractModifier_0, 0, 0);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AbstractModifier", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AbstractModifier", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_VariationModifier(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "VariationModifier", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VARIATION, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_VariationModifier_0, 0, 0);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "VariationModifier", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "VariationModifier", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BasicDefinitionPrefix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BasicDefinitionPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INDIVIDUAL, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LifeclassPrefix, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BasicDefinitionPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BasicDefinitionPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LifeclassPrefix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LifeclassPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SNAPSHOT, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TIMESLICE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LifeclassPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LifeclassPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UsagePrefix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UsagePrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AbstractModifier, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VariationModifier, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VARIANT, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BasicUsagePrefix, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UsagePrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UsagePrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BasicUsagePrefix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BasicUsagePrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Direction, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RefPrefix, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INDIVIDUAL, &chunk->thunks, NULL)) goto L0007;
            goto L0008;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0008:;
        }
        /* unreachable codes omitted */
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BasicUsagePrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RefPrefix(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RefPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REF, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_READONLY, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DERIVED, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTANT, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_END, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RefPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RefPrefix", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AttributeDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AttributeDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ATTRIBUTE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AttributeDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AttributeDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AttributeDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AttributeDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumerationDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EnumerationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ENUM, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_EnumerationDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EnumerationBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_EnumerationDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EnumerationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EnumerationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DatatypeDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DatatypeDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DATATYPE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_DatatypeDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_DatatypeDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DatatypeDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DatatypeDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumerationBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EnumerationBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EnumeratedValue, &chunk->thunks, NULL)) goto L0006;
                    goto L0005;
                L0006:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0007;
                    goto L0005;
                L0007:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                    goto L0004;
                L0005:;
                }
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EnumerationBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EnumerationBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumeratedValue(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EnumeratedValue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EnumeratedValueVariant, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EnumeratedValue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EnumeratedValue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumeratedValueVariant(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EnumeratedValueVariant", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ENUM, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        {
            const size_t p = ctx->cur;
            size_t q;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
            q = ctx->cur;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_EnumeratedValueVariant_0, 0, 1);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_EnumeratedValueVariant_1, 0, 1);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VARIANT, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageElement, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EnumeratedValueVariant", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EnumeratedValueVariant", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OccurrenceDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OCCURRENCE, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0002;
        {
            const size_t p = ctx->cur;
            size_t q;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0002;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0004;
                goto L0005;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0005:;
            }
            q = ctx->cur;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_OccurrenceDefinition_0, 0, 1);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceDefinitionBody, &chunk->thunks, NULL)) goto L0002;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_OccurrenceDefinition_1, 0, 1);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0007;
                if (ctx->cur == p) break;
                continue;
            L0007:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0006;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0006;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceDefinitionBody, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OccurrenceDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OccurrenceDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceDefinitionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OccurrenceDefinitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceDefinitionMember, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OccurrenceDefinitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OccurrenceDefinitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ThenMessageUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ThenMessageUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MessageUsage, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ThenMessageUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ThenMessageUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceDefinitionMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OccurrenceDefinitionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceDefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortionUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ThenMessageUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MessageUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BindUsage, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EventOccurrenceUsage, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EventUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandFeatureMember, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionMember, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StructureUsageElement, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceUsage, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0015;
        goto L0001;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OccurrenceDefinitionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OccurrenceDefinitionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceDefinitionElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OccurrenceDefinitionElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BehaviorUsageElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OccurrenceDefinitionElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OccurrenceDefinitionElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ItemDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ItemDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ITEM, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ItemDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ItemDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ItemDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ItemDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PartDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PartDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PART, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PartDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PartDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PartDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PartDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectionDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConnectionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONNECTION, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConnectionDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConnectionDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConnectionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConnectionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FlowDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FLOW, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_FlowDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_FlowDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FlowDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FlowDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InterfaceDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INTERFACE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_InterfaceDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InterfaceBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_InterfaceDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InterfaceDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InterfaceDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InterfaceBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InterfaceBodyElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InterfaceBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InterfaceBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InterfaceBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EndMember, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InterfaceUsageElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InterfaceBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InterfaceBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InterfaceUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageElement, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InterfaceUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InterfaceUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PortDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PortDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PORT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PortDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortDefinitionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PortDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PortDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PortDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PortDefinitionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PortDefinitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortDefinitionMember, &chunk->thunks, NULL)) goto L0006;
                    goto L0005;
                L0006:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConjugatedPortDefinitionMember, &chunk->thunks, NULL)) goto L0007;
                    goto L0005;
                L0007:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                    goto L0004;
                L0005:;
                }
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PortDefinitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PortDefinitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PortDefinitionMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PortDefinitionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortUsageElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PortDefinitionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PortDefinitionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConjugatedPortDefinitionMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConjugatedPortDefinitionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PORT, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TILDE, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConjugatedPortDeclaration, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConjugatedPortDefinitionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConjugatedPortDefinitionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConjugatedPortDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConjugatedPortDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TILDE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConjugatedPortDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConjugatedPortDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PortUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PortUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ParameterUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PortUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PortUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AllocationDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AllocationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALLOCATION, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AllocationDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AllocationDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AllocationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AllocationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ActionDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ActionDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyItem, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionBodyItem(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyElement, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BindUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TerminateAction, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateUsage, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcUsage, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandFeatureMember, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertConstraintUsage, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VariantUsage, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionUsageElement, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StructureUsageElement, &chunk->thunks, NULL)) goto L0015;
        goto L0001;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StateDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StateDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STATE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_StateDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_StateDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StateDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StateDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StateBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StateBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateBodyItem, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StateBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StateBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StateBodyItem(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StateBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateBodyElement, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StateBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StateBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StateBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StateBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertConstraintUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateUsageElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StateBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StateBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StateUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StateUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EntryAction, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExitAction, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DoAction, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EntryTransition, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AcceptTransition, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateUsage, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExhibitStateUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionUsage, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionUsage, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionMember, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintUsage, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionUsageElement, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StateUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StateUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptTransition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AcceptTransition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACCEPT, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TriggerActionBody, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EffectAction, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionEndAction, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AcceptTransition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AcceptTransition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EntryAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EntryAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ENTRY, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssignmentAction, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SendAction, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PerformActionUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0009;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0010;
            goto L0011;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0011:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EntryAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EntryAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExitAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExitAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EXIT, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssignmentAction, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SendAction, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PerformActionUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0009;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0010;
            goto L0011;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0011:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExitAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExitAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DoAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DoAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DO, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssignmentAction, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SendAction, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PerformActionUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0006;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0007;
            goto L0008;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0008:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0010;
            goto L0009;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0011;
            goto L0009;
        L0011:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0006;
        L0009:;
        }
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DoAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DoAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PerformActionUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PerformActionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VARIATION, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PERFORM, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0004;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0004;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0004;
        goto L0003;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0005;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureSpecialization, &chunk->thunks, NULL)) goto L0008;
                if (ctx->cur == p) break;
                continue;
            L0008:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0005;
        goto L0003;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0003:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PerformActionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PerformActionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EntryTransition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EntryTransition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ENTRY, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EntryTransition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EntryTransition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConstraintDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTRAINT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConstraintDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConstraintDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConstraintDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConstraintDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConstraintBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintBodyElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ResultExpression, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConstraintBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConstraintBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConstraintBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintUsageElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConstraintBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConstraintBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RequirementDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIREMENT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_RequirementDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_RequirementDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RequirementDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RequirementDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RequirementBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBodyItem, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RequirementBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RequirementBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementBodyItem(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RequirementBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBodyElement, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RequirementBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RequirementBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RequirementBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VariantUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReturnUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReferenceUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementUsageElement, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandFeatureMember, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionMember, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RequirementBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RequirementBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_VariantUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "VariantUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VARIANT, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PERFORM, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VARIANT, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VARIANT, &chunk->thunks, NULL)) goto L0006;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0006;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "VariantUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "VariantUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConcernDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConcernDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONCERN, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConcernDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConcernDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConcernDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConcernDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CalcDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CALC, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_CalcDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_CalcDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CalcDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CalcDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CalcBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcBodyItem, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ResultExpression, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CalcBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CalcBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcBodyItem(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CalcBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcBodyElement, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CalcBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CalcBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CalcBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertConstraintUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcUsageElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StructureUsageElement, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CalcBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CalcBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CaseDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CASE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_CaseDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_CaseDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CaseDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CaseDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CaseBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseBodyItem, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ResultExpression, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CaseBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CaseBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseBodyItem(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CaseBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseBodyElement, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CaseBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CaseBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CaseBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseUsageElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StructureUsageElement, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CaseBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CaseBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AnalysisDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AnalysisDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ANALYSIS, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AnalysisDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AnalysisDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AnalysisDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AnalysisDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_VerificationDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "VerificationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VERIFICATION, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_VerificationDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_VerificationDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "VerificationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "VerificationDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UseCaseDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UseCaseDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_USE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CASE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_UseCaseDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_UseCaseDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UseCaseDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UseCaseDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ViewDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIEW, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ViewDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ViewDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ViewDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ViewDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ViewBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewBodyElement, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ViewBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ViewBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewBodyElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ViewBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewUsageElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FilterPackageMember, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ViewBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ViewBodyElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewpointDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ViewpointDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIEWPOINT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ViewpointDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ViewpointDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ViewpointDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ViewpointDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RenderingDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RenderingDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_RENDERING, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_RenderingDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_RenderingDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RenderingDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RenderingDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataDefinition(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetadataDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionPrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_METADATA, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEF, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0000;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecializations, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MetadataDefinition_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_MetadataDefinition_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetadataDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetadataDefinition", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DefinitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionBodyItem, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DefinitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DefinitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionBodyItem(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DefinitionBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EndMember, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KerMLFeatureElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertConstraintUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BindUsage, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandFeatureMember, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionMember, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageElement, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DefinitionBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DefinitionBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionSpecializations(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DefinitionSpecializations", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionSpecialization, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
            goto L0000;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DefinitionSpecializations", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DefinitionSpecializations", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DefinitionSpecialization(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DefinitionSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SPECIALIZES, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0003;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypeRelationshipPart, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DefinitionSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DefinitionSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertSatisfyUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SatisfyUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExhibitStateUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PerformActionUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MessageUsage, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReferenceUsage, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AttributeUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EnumerationUsage, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ItemUsage, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PartUsage, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectionUsage, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowUsage, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InterfaceUsage, &chunk->thunks, NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortUsage, &chunk->thunks, NULL)) goto L0015;
        goto L0001;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AllocationUsage, &chunk->thunks, NULL)) goto L0016;
        goto L0001;
    L0016:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionUsage, &chunk->thunks, NULL)) goto L0017;
        goto L0001;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateUsage, &chunk->thunks, NULL)) goto L0018;
        goto L0001;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintUsage, &chunk->thunks, NULL)) goto L0019;
        goto L0001;
    L0019:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementUsage, &chunk->thunks, NULL)) goto L0020;
        goto L0001;
    L0020:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConcernUsage, &chunk->thunks, NULL)) goto L0021;
        goto L0001;
    L0021:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcUsage, &chunk->thunks, NULL)) goto L0022;
        goto L0001;
    L0022:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseUsage, &chunk->thunks, NULL)) goto L0023;
        goto L0001;
    L0023:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnalysisUsage, &chunk->thunks, NULL)) goto L0024;
        goto L0001;
    L0024:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VerificationUsage, &chunk->thunks, NULL)) goto L0025;
        goto L0001;
    L0025:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UseCaseUsage, &chunk->thunks, NULL)) goto L0026;
        goto L0001;
    L0026:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewUsage, &chunk->thunks, NULL)) goto L0027;
        goto L0001;
    L0027:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewpointUsage, &chunk->thunks, NULL)) goto L0028;
        goto L0001;
    L0028:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RenderingUsage, &chunk->thunks, NULL)) goto L0029;
        goto L0001;
    L0029:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionUsage, &chunk->thunks, NULL)) goto L0030;
        goto L0001;
    L0030:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortionUsage, &chunk->thunks, NULL)) goto L0031;
        goto L0001;
    L0031:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SubjectUsage, &chunk->thunks, NULL)) goto L0032;
        goto L0001;
    L0032:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActorUsage, &chunk->thunks, NULL)) goto L0033;
        goto L0001;
    L0033:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StakeholderUsage, &chunk->thunks, NULL)) goto L0034;
        goto L0001;
    L0034:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IncludeUseCaseUsage, &chunk->thunks, NULL)) goto L0035;
        goto L0001;
    L0035:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EventOccurrenceUsage, &chunk->thunks, NULL)) goto L0036;
        goto L0001;
    L0036:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EventUsage, &chunk->thunks, NULL)) goto L0037;
        goto L0001;
    L0037:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceUsage, &chunk->thunks, NULL)) goto L0038;
        goto L0001;
    L0038:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PortionUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PortionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BasicUsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INDIVIDUAL, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortionKind, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortionUsageKind, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PortionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PortionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PortionKind(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PortionKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SNAPSHOT, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TIMESLICE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PortionKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PortionKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PortionUsageKind(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PortionUsageKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ITEM, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PART, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OCCURRENCE, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ATTRIBUTE, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PortionUsageKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PortionUsageKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SuccessionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUCCESSION, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            const size_t p = ctx->cur;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FIRST, &chunk->thunks, NULL)) goto L0003;
            ctx->cur = p;
            goto L0002;
        L0003:;
            ctx->cur = p;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        goto L0004;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionFirstPart, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionUsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SuccessionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SuccessionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionFirstPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SuccessionFirstPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FIRST, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SuccessionFirstPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SuccessionFirstPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionUsageBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SuccessionUsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DecisionBranches, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SuccessionUsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SuccessionUsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DecisionBranches(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DecisionBranches", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DecisionBranch, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
            goto L0000;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DecisionBranches", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DecisionBranches", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DecisionBranch(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DecisionBranch", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IF, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ELSE, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DecisionBranch", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DecisionBranch", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RefBehavioralKeyword(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RefBehavioralKeyword", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STATE, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OCCURRENCE, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CASE, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIREMENT, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_MESSAGE, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CALC, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTRAINT, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIEWPOINT, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONCERN, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIEW, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_RENDERING, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RefBehavioralKeyword", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RefBehavioralKeyword", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ReferenceUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ReferenceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Direction, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REF, &chunk->thunks, NULL)) goto L0002;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0005;
                if (ctx->cur == p) break;
                continue;
            L0005:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RefBehavioralKeyword, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Direction, &chunk->thunks, NULL)) goto L0009;
            goto L0010;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0010:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RefPrefix, &chunk->thunks, NULL)) goto L0008;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0011;
                if (ctx->cur == p) break;
                continue;
            L0011:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ReferenceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ReferenceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StructureUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StructureUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AttributeUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ItemUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PartUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectionUsage, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowUsage, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InterfaceUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StructureUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StructureUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BehaviorUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BehaviorUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BehaviorUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BehaviorUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ParameterUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PerformActionUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SendAction, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AcceptAction, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssignmentAction, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IfAction, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_WhileLoop, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ForLoop, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ControlNode, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionMember, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConstraintUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ParameterUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReturnUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConstraintUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConstraintUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RequirementUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SubjectUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActorUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StakeholderUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssumeConstraint, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequireConstraint, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertSatisfyUsage, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SatisfyUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementUsage, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConcernUsage, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintUsage, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ObjectiveUsage, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FrameUsage, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VerifyRequirementUsage, &chunk->thunks, NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementReference, &chunk->thunks, NULL)) goto L0015;
        goto L0001;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VerificationUsage, &chunk->thunks, NULL)) goto L0016;
        goto L0001;
    L0016:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcUsage, &chunk->thunks, NULL)) goto L0017;
        goto L0001;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionUsage, &chunk->thunks, NULL)) goto L0018;
        goto L0001;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AllocationUsage, &chunk->thunks, NULL)) goto L0019;
        goto L0001;
    L0019:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ParameterUsage, &chunk->thunks, NULL)) goto L0020;
        goto L0001;
    L0020:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StructureUsageElement, &chunk->thunks, NULL)) goto L0021;
        goto L0001;
    L0021:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RequirementUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RequirementUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CalcUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReturnUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionUsageElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StructureUsageElement, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CalcUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CalcUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CaseUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SubjectUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActorUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StakeholderUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ObjectiveUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IncludeUseCaseUsage, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UseCaseUsage, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnalysisUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VerificationUsage, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertConstraintUsage, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcUsageElement, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CaseUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CaseUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IncludeUseCaseUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "IncludeUseCaseUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INCLUDE, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_USE, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CASE, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "IncludeUseCaseUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "IncludeUseCaseUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewUsageElement(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ViewUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RenderUsage, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewpointUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RenderingUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExposeUsage, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequireConstraint, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SatisfyUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StructureUsageElement, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ViewUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ViewUsageElement", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExposeUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExposeUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EXPOSE, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONCOLON_STAR, &chunk->thunks, NULL)) goto L0004;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONCOLON_STARSTAR, &chunk->thunks, NULL)) goto L0005;
                goto L0006;
            L0005:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0006:;
            }
            goto L0003;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONCOLON_STARSTAR, &chunk->thunks, NULL)) goto L0007;
            goto L0003;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0002;
        L0003:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0008;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0009;
            goto L0010;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0010:;
        }
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImportFilter, &chunk->thunks, NULL)) goto L0011;
        goto L0012;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0012:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExposeUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExposeUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AttributeUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AttributeUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ATTRIBUTE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AttributeUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AttributeUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AttributeUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AttributeUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EnumerationUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EnumerationUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ENUM, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_EnumerationUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_EnumerationUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EnumerationUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EnumerationUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OccurrenceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OCCURRENCE, &chunk->thunks, NULL)) goto L0002;
        {
            const size_t p = ctx->cur;
            size_t q;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
            q = ctx->cur;
            chunk->capts.buf[0].range.start = p;
            chunk->capts.buf[0].range.end = q;
            pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
        }
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_OccurrenceUsage_0, 0, 1);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceUsageBody, &chunk->thunks, NULL)) goto L0002;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_OccurrenceUsage_1, 0, 1);
            thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            const size_t p0 = ctx->cur;
            const size_t n0 = chunk->thunks.len;
            int i;
            for (i = 0;; i++) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0005;
                if (ctx->cur == p) break;
                continue;
            L0005:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
            if (i < 1) {
                ctx->cur = p0;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
                goto L0004;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0004;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceUsageBody, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OccurrenceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OccurrenceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EventOccurrenceUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EventOccurrenceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EVENT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OCCURRENCE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceUsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EventOccurrenceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EventOccurrenceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EventUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EventUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EVENT, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_REDEFINES, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0009;
                if (ctx->cur == p) break;
                continue;
            L0009:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EVENT, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0008;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0010;
            goto L0011;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0011:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0013;
                if (ctx->cur == p) break;
                continue;
            L0013:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EVENT, &chunk->thunks, NULL)) goto L0012;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0012;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0012;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0015;
                if (ctx->cur == p) break;
                continue;
            L0015:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EVENT, &chunk->thunks, NULL)) goto L0014;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0014;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0017;
                if (ctx->cur == p) break;
                continue;
            L0017:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EVENT, &chunk->thunks, NULL)) goto L0016;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0016;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0016;
        goto L0001;
    L0016:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EventUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EventUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceUsageBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OccurrenceUsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceUsageMember, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OccurrenceUsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OccurrenceUsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OccurrenceUsageMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OccurrenceUsageMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceDefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertConstraintUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortionUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EventOccurrenceUsage, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EventUsage, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceUsage, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MessageUsage, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BindUsage, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandFeatureMember, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionMember, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StructureUsageElement, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OccurrenceUsageMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OccurrenceUsageMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ItemUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ItemUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ITEM, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ItemUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ItemUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ItemUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ItemUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PartUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PartUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PART, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PartUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PartUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PartUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PartUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectionUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConnectionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONNECTION, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONNECT, &chunk->thunks, NULL)) goto L0006;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectionPart, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0009;
                if (ctx->cur == p) break;
                continue;
            L0009:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONNECT, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectionPart, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConnectionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConnectionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectionPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConnectionPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BinaryConnectorPart, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NaryConnectorPart, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConnectionPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConnectionPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BinaryConnectorPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BinaryConnectorPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BinaryConnectorPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BinaryConnectorPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NaryConnectorPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NaryConnectorPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LPAREN, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
            goto L0000;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RPAREN, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NaryConnectorPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NaryConnectorPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConnectorEndMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConnectorEndMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_REFERENCES, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_REFERENCES, &chunk->thunks, NULL)) goto L0007;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0007;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
        goto L0010;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0010:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConnectorEndMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConnectorEndMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FlowUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUCCESSION, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FLOW, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FlowUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FlowUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FlowBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONGTGT, &chunk->thunks, NULL)) goto L0004;
            goto L0003;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONGT, &chunk->thunks, NULL)) goto L0005;
            goto L0003;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0002;
        L0003:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowConnectionPart, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowConnectionPart, &chunk->thunks, NULL)) goto L0006;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0007;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0010;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0010;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLON, &chunk->thunks, NULL)) goto L0010;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0010;
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0011;
                    goto L0012;
                L0011:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                L0012:;
                }
                goto L0009;
            L0010:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0013;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0013;
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0014;
                    goto L0015;
                L0014:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                L0015:;
                }
                goto L0009;
            L0013:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                goto L0008;
            L0009:;
            }
            goto L0016;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0016:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowConnectionPart, &chunk->thunks, NULL)) goto L0018;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0018;
            goto L0017;
        L0018:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0019;
            goto L0017;
        L0019:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0007;
        L0017:;
        }
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FlowBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FlowBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowConnectionPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FlowConnectionPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FROM, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowEndMember, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowEndMember, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowEndMember, &chunk->thunks, NULL)) goto L0003;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0005;
            goto L0004;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FROM, &chunk->thunks, NULL)) goto L0006;
            goto L0004;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0003;
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowEndMember, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FlowConnectionPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FlowConnectionPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FlowEndMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FlowEndMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FlowEndMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FlowEndMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InterfaceUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InterfaceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INTERFACE, &chunk->thunks, NULL)) goto L0002;
        {
            const size_t p = ctx->cur;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectorEndMember, &chunk->thunks, NULL)) goto L0004;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0004;
            ctx->cur = p;
            goto L0005;
        L0004:;
            ctx->cur = p;
            goto L0002;
        L0005:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectionPart, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InterfaceBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0007;
                if (ctx->cur == p) break;
                continue;
            L0007:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INTERFACE, &chunk->thunks, NULL)) goto L0006;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONNECT, &chunk->thunks, NULL)) goto L0010;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConnectionPart, &chunk->thunks, NULL)) goto L0010;
            goto L0011;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0011:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InterfaceBody, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InterfaceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InterfaceUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PortUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PortUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PORT, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PortUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_PortUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PortUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PortUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AllocationUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AllocationUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALLOCATION, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AllocationPart, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0009;
                if (ctx->cur == p) break;
                continue;
            L0009:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALLOCATE, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AllocationPart, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AllocationUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AllocationUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AllocationPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AllocationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALLOCATE, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BinaryConnectorPart, &chunk->thunks, NULL)) goto L0004;
        goto L0003;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NaryConnectorPart, &chunk->thunks, NULL)) goto L0005;
        goto L0003;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0003:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AllocationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AllocationPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ActionUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionUsageBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ActionUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionParameterList, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageSpecializations, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0007;
        goto L0008;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionParameterList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionParameterList", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LPAREN, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionParameter, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionParameter, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RPAREN, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionParameterList", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionParameterList", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionParameter(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Direction, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REF, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ITEM, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0009;
            goto L0008;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Subsets, &chunk->thunks, NULL)) goto L0010;
            goto L0008;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0007;
        L0008:;
        }
        goto L0011;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0011:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQ, &chunk->thunks, NULL)) goto L0012;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0012;
        goto L0013;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0013:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionUsageBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionUsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TERMINATE, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SEND, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SendActionTail, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACCEPT, &chunk->thunks, NULL)) goto L0004;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AcceptActionTail, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionAssignBody, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionWhileBody, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionForBody, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionUsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionUsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionAssignBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionAssignBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ASSIGN, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONEQ, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionAssignBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionAssignBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptActionTail(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AcceptActionTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLON, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIA, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        goto L0006;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0008;
        goto L0007;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0009;
        goto L0007;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0007:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AcceptActionTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AcceptActionTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SendActionTail(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SendActionTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            const size_t p = ctx->cur;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIA, &chunk->thunks, NULL)) goto L0002;
            ctx->cur = p;
            goto L0001;
        L0002:;
            ctx->cur = p;
        }
        {
            const size_t p = ctx->cur;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0003;
            ctx->cur = p;
            goto L0001;
        L0003:;
            ctx->cur = p;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIA, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0005;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        goto L0008;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0009;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0009;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0010;
            goto L0011;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0011:;
        }
        goto L0012;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0012:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0014;
        goto L0013;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0015;
        goto L0013;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0013:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SendActionTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SendActionTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionWhileBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionWhileBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_WHILE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyParameter, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_UNTIL, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionWhileBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionWhileBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionForBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionForBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FOR, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ForVariableSpec, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyParameter, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionForBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionForBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ForVariableSpec(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ForVariableSpec", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLON, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IN, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IN, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ForVariableSpec", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ForVariableSpec", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StateUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StateUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PARALLEL, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STATE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_StateUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PARALLEL, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_StateUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StateUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StateUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExhibitStateUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExhibitStateUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EXHIBIT, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STATE, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PARALLEL, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExhibitStateBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EXHIBIT, &chunk->thunks, NULL)) goto L0007;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STATE, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0007;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PARALLEL, &chunk->thunks, NULL)) goto L0010;
            goto L0011;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0011:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExhibitStateBody, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExhibitStateUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExhibitStateUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExhibitStateBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExhibitStateBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateBody, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExhibitStateBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExhibitStateBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConstraintUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConstraintUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTRAINT, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConstraintUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConstraintUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConstraintUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConstraintUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RequirementUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIREMENT, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_RequirementUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_RequirementUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RequirementUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RequirementUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConcernUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConcernUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONCERN, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConcernUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ConcernUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConcernUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConcernUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CalcUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CalcUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CALC, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_CalcUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CalcBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_CalcUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CalcUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CalcUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CaseUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CaseUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CASE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_CaseUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_CaseUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CaseUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CaseUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AnalysisUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AnalysisUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ANALYSIS, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AnalysisUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_AnalysisUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AnalysisUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AnalysisUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_VerificationUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "VerificationUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VERIFICATION, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_VerificationUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_VerificationUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "VerificationUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "VerificationUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UseCaseUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UseCaseUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_USE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CASE, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_UseCaseUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CaseBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_UseCaseUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UseCaseUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UseCaseUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ViewUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIEW, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ViewUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ViewUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ViewUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ViewUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ViewpointUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ViewpointUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIEWPOINT, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ViewpointUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_ViewpointUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ViewpointUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ViewpointUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RenderingUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RenderingUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_RENDERING, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_RenderingUsage_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ViewBody, &chunk->thunks, NULL)) goto L0000;
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_RenderingUsage_1, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RenderingUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RenderingUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ParameterKind(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ParameterKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ATTRIBUTE, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ITEM, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PART, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIREMENT, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OCCURRENCE, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_EVENT, &chunk->thunks, NULL)) goto L0007;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OCCURRENCE, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STATE, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CASE, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_MESSAGE, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTRAINT, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CALC, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ParameterKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ParameterKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ParameterUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ParameterUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Direction, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0003;
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ParameterKind, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ParameterUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ParameterUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Direction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Direction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_INOUT, &chunk->thunks, NULL)) goto L0002;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Direction_0, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OUT, &chunk->thunks, NULL)) goto L0003;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Direction_1, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IN, &chunk->thunks, NULL)) goto L0004;
        {
            pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Direction_2, 0, 0);
            thunk->data.leaf.capt0.range.start = chunk->pos;
            thunk->data.leaf.capt0.range.end = ctx->cur;
            pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
            pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
        }
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Direction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Direction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SubjectUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SubjectUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SUBJECT, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SubjectUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SubjectUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActorUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActorUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTOR, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActorUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActorUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_StakeholderUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "StakeholderUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_STAKEHOLDER, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "StakeholderUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "StakeholderUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ObjectiveUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ObjectiveUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OBJECTIVE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ObjectiveUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ObjectiveUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FrameUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FrameUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FRAME, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONCERN, &chunk->thunks, NULL)) goto L0003;
            goto L0002;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIREMENT, &chunk->thunks, NULL)) goto L0004;
            goto L0002;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0001;
        L0002:;
        }
        goto L0005;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FrameUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FrameUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementReference(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RequirementReference", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequirementConstraintKind, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RequirementReference", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RequirementReference", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequirementConstraintKind(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RequirementConstraintKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ASSUME, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTRAINT, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIRE, &chunk->thunks, NULL)) goto L0005;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTRAINT, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RequirementConstraintKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RequirementConstraintKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_VerifyRequirementUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "VerifyRequirementUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VERIFY, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIREMENT, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VERIFY, &chunk->thunks, NULL)) goto L0007;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0007;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0007;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "VerifyRequirementUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "VerifyRequirementUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ReturnUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_RETURN, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ReturnUsageKind, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ReturnUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ReturnUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ReturnUsageKind(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ReturnUsageKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ATTRIBUTE, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PART, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ITEM, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REF, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ReturnUsageKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ReturnUsageKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RenderUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RenderUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_RENDER, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_RENDERING, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RenderUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RenderUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SendAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SendAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SEND, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIA, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0005;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        goto L0008;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SendAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SendAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AcceptAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACCEPT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AcceptParameterPart, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AcceptAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AcceptAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptParameterPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AcceptParameterPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PayloadParameter, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIA, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AcceptParameterPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AcceptParameterPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PayloadParameter(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PayloadParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TriggerPart, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PayloadFeatureSpec, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TriggerPart, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PayloadParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PayloadFeatureSpec(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PayloadFeatureSpec", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PayloadFeatureSpec", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PayloadFeatureSpec", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TriggerPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TriggerPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TriggerKind, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TriggerPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TriggerPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TriggerKind(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TriggerKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_AT, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_AFTER, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_WHEN, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TriggerKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TriggerKind", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AssignmentAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AssignmentAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ASSIGN, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONEQ, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AssignmentAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AssignmentAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IfAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "IfAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IF, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IfThenPart, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IfElsePart, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "IfAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "IfAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IfThenPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "IfThenPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyParameter, &chunk->thunks, NULL)) goto L0004;
        goto L0003;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyElement, &chunk->thunks, NULL)) goto L0005;
        goto L0003;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0003:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "IfThenPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "IfThenPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IfElsePart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "IfElsePart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ELSE, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IfAction, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyParameter, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyElement, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "IfElsePart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "IfElsePart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ActionBodyParameter(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ActionBodyParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyItem, &chunk->thunks, NULL)) goto L0005;
            if (ctx->cur == p) break;
            continue;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ActionBodyParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ActionBodyParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_WhileLoop(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "WhileLoop", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_WHILE, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_UNTIL, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyParameter, &chunk->thunks, NULL)) goto L0006;
            goto L0005;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0007;
            goto L0005;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0002;
        L0005:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_LOOP, &chunk->thunks, NULL)) goto L0008;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyParameter, &chunk->thunks, NULL)) goto L0010;
            goto L0009;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0011;
            goto L0009;
        L0011:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0008;
        L0009:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_UNTIL, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_LOOP, &chunk->thunks, NULL)) goto L0012;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyParameter, &chunk->thunks, NULL)) goto L0014;
            goto L0013;
        L0014:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0015;
            goto L0013;
        L0015:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0012;
        L0013:;
        }
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "WhileLoop", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "WhileLoop", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ForLoop(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ForLoop", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FOR, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ForVariableSpec, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBodyParameter, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ForLoop", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ForLoop", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ControlNode(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ControlNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MergeNode, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DecisionNode, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_JoinNode, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ForkNode, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ControlNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ControlNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MergeNode(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MergeNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_MERGE, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MergeNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MergeNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_DecisionNode(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "DecisionNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DECIDE, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "DecisionNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "DecisionNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_JoinNode(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "JoinNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_JOIN, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "JoinNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "JoinNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ForkNode(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ForkNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FORK, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ForkNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ForkNode", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_GuardedSuccession(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "GuardedSuccession", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IF, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "GuardedSuccession", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "GuardedSuccession", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SuccessionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FIRST, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_GuardedSuccession, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FIRST, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionBody, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0006;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ThenTarget, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0007;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0007;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionBody, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SuccessionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SuccessionMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ThenTarget(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ThenTarget", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionInlineAction, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0004;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ThenTarget", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ThenTarget", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionInlineAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SuccessionInlineAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VisibilityIndicator, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AcceptActionUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0003;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AcceptAction, &chunk->thunks, NULL)) goto L0005;
        goto L0003;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SendAction, &chunk->thunks, NULL)) goto L0006;
        goto L0003;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssignmentAction, &chunk->thunks, NULL)) goto L0007;
        goto L0003;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IfAction, &chunk->thunks, NULL)) goto L0008;
        goto L0003;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_WhileLoop, &chunk->thunks, NULL)) goto L0009;
        goto L0003;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ForLoop, &chunk->thunks, NULL)) goto L0010;
        goto L0003;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ControlNode, &chunk->thunks, NULL)) goto L0011;
        goto L0003;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IncludeUseCaseUsage, &chunk->thunks, NULL)) goto L0012;
        goto L0003;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UseCaseUsage, &chunk->thunks, NULL)) goto L0013;
        goto L0003;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PortionUsage, &chunk->thunks, NULL)) goto L0014;
        goto L0003;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_StateUsage, &chunk->thunks, NULL)) goto L0015;
        goto L0003;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EventOccurrenceUsage, &chunk->thunks, NULL)) goto L0016;
        goto L0003;
    L0016:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EventUsage, &chunk->thunks, NULL)) goto L0017;
        goto L0003;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OccurrenceUsage, &chunk->thunks, NULL)) goto L0018;
        goto L0003;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PerformActionUsage, &chunk->thunks, NULL)) goto L0019;
        goto L0003;
    L0019:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionUsage, &chunk->thunks, NULL)) goto L0020;
        goto L0003;
    L0020:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0003:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SuccessionInlineAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SuccessionInlineAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptActionUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AcceptActionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACCEPT, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACCEPT, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AcceptActionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AcceptActionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SuccessionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SuccessionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0007;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0010;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0010;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0011;
                goto L0012;
            L0011:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0012:;
            }
            goto L0013;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0013:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0015;
            goto L0016;
        L0015:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0016:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SuccessionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SuccessionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TransitionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TRANSITION, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionDeclaration, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TransitionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TransitionUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TransitionDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FIRST, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionName, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLON, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionSourceTarget, &chunk->thunks, NULL)) goto L0007;
        goto L0008;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TransitionDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionName(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TransitionName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACCEPT, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FIRST, &chunk->thunks, NULL)) goto L0002;
        ctx->cur = p;
        goto L0000;
    L0002:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0003;
        ctx->cur = p;
        goto L0000;
    L0003:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DO, &chunk->thunks, NULL)) goto L0004;
        ctx->cur = p;
        goto L0000;
    L0004:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TransitionName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TransitionName", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionSourceTarget(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TransitionSourceTarget", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FIRST, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionTarget, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionTarget, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TransitionSourceTarget", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TransitionSourceTarget", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionTarget(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TransitionTarget", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACCEPT, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0002;
        ctx->cur = p;
        goto L0000;
    L0002:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DO, &chunk->thunks, NULL)) goto L0003;
        ctx->cur = p;
        goto L0000;
    L0003:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TransitionTarget", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TransitionTarget", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TransitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionActionBody, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TransitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TransitionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionActionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TransitionActionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TriggerAction, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_GuardAction, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EffectAction, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TransitionEndAction, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TransitionActionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TransitionActionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_GuardAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "GuardAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IF, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "GuardAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "GuardAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TriggerAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TriggerAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACCEPT, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FIRST, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TriggerActionBody, &chunk->thunks, NULL)) goto L0004;
        goto L0005;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TriggerAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TriggerAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TriggerActionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TriggerActionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AcceptPayload, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIA, &chunk->thunks, NULL)) goto L0002;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0003;
                goto L0004;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0004:;
            }
            goto L0005;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        goto L0006;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TriggerPart, &chunk->thunks, NULL)) goto L0007;
        goto L0008;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TriggerActionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AcceptPayload(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AcceptPayload", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TriggerKind, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLON, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AcceptPayload", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AcceptPayload", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EffectAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EffectAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DO, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EffectSendAction, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0003;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0004;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EffectAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EffectAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EffectSendAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EffectSendAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SEND, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_VIA, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0002;
            goto L0003;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0003:;
        }
        goto L0004;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0005;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        goto L0008;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EffectSendAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EffectSendAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TransitionEndAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TransitionEndAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_THEN, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0005;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ActionBody, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TransitionEndAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TransitionEndAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageDeclaration(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UsageDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageSpecializations, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UsageDeclaration", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageSpecializations(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UsageSpecializations", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageSpecialization, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
            goto L0000;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UsageSpecializations", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UsageSpecializations", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageSpecialization(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UsageSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Subsets, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Redefines, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_References, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Crosses, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UsageSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UsageSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TypedBy(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TypedBy", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TYPED_BY, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TILDE, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0005;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0005;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0006;
                goto L0007;
            L0006:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0007:;
            }
            if (ctx->cur == p) break;
            continue;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TypedBy", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TypedBy", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Subsets(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Subsets", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SUBSETS, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0004;
                goto L0005;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0005:;
            }
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Subsets", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Subsets", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Redefines(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Redefines", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_REDEFINES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0004;
                goto L0005;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0005:;
            }
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Redefines", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Redefines", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_References(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "References", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_REFERENCES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0004;
                goto L0005;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0005:;
            }
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "References", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "References", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Crosses(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Crosses", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CROSSES, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0003;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0004;
                goto L0005;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0005:;
            }
            if (ctx->cur == p) break;
            continue;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Crosses", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Crosses", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureSpecialization(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FeatureSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Subsets, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Redefines, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_References, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Crosses, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FeatureSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FeatureSpecialization", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureValue(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FeatureValue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValueWithDefault, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValueSimple, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FeatureValue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FeatureValue", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureValueWithDefault(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FeatureValueWithDefault", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_DEFAULT, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQ, &chunk->thunks, NULL)) goto L0003;
            goto L0002;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONEQ, &chunk->thunks, NULL)) goto L0004;
            goto L0002;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0001;
        L0002:;
        }
        goto L0005;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_FeatureValueWithDefault_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FeatureValueWithDefault", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FeatureValueWithDefault", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureValueSimple(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FeatureValueSimple", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQ, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONEQ, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    {
        const size_t p = ctx->cur;
        size_t q;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_FeatureValueSimple_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FeatureValueSimple", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FeatureValueSimple", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Multiplicity(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Multiplicity", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, 1);
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACKET, &chunk->thunks, NULL)) goto L0000;
    {
        const size_t p = ctx->cur;
        size_t q;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MultiplicityBounds, &chunk->thunks, NULL)) goto L0001;
            goto L0002;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0002:;
        }
        q = ctx->cur;
        chunk->capts.buf[0].range.start = p;
        chunk->capts.buf[0].range.end = q;
        pcc_char_array__resize(ctx->auxil, &chunk->capts.buf[0].string, 0);
    }
    {
        pcc_thunk_t *const thunk = pcc_thunk__create_leaf(ctx, pcc_action_Multiplicity_0, 0, 1);
        thunk->data.leaf.capts.buf[0] = &(chunk->capts.buf[0]);
        thunk->data.leaf.capt0.range.start = chunk->pos;
        thunk->data.leaf.capt0.range.end = ctx->cur;
        pcc_char_array__resize(ctx->auxil, &thunk->data.leaf.capt0.string, 0);
        pcc_thunk_array__add(ctx, &chunk->thunks, thunk);
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACKET, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OrderedNonunique, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Multiplicity", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Multiplicity", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicityBounds(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MultiplicityBounds", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DOTDOT, &chunk->thunks, NULL)) goto L0003;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0005;
                goto L0004;
            L0005:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STAR, &chunk->thunks, NULL)) goto L0006;
                goto L0004;
            L0006:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                goto L0003;
            L0004:;
            }
            goto L0007;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STAR, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MultiplicityBounds", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MultiplicityBounds", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OrderedNonunique(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OrderedNonunique", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ORDERED, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NONUNIQUE, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NONUNIQUE, &chunk->thunks, NULL)) goto L0005;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ORDERED, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OrderedNonunique", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OrderedNonunique", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0003;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBodyItem, &chunk->thunks, NULL)) goto L0004;
                if (ctx->cur == p) break;
                continue;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UsageBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageBodyItem(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UsageBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MemberPrefix, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DefinitionElement, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertConstraintUsage, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BindUsage, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandFeatureMember, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SuccessionMember, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VariantUsage, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RequireConstraint, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssumeConstraint, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageElement, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Import, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Alias, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UsageBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UsageBodyItem", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ShorthandFeatureMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ShorthandFeatureMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONGTGT, &chunk->thunks, NULL)) goto L0004;
            goto L0003;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLONGT, &chunk->thunks, NULL)) goto L0005;
            goto L0003;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0002;
        L0003:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0006;
            goto L0007;
        L0006:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0007:;
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0008;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0008;
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0009;
                    goto L0010;
                L0009:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                L0010:;
                }
                if (ctx->cur == p) break;
                continue;
            L0008:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLON, &chunk->thunks, NULL)) goto L0011;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0011;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0012;
                goto L0013;
            L0012:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0013:;
            }
            goto L0014;
        L0011:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0014:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0015;
            goto L0016;
        L0015:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0016:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REDEFINES, &chunk->thunks, NULL)) goto L0017;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0017;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0018;
            goto L0019;
        L0018:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0019:;
        }
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0020;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0020;
                {
                    MARK_VAR_AS_USED
                    const size_t p = ctx->cur;
                    MARK_VAR_AS_USED
                    const size_t n = chunk->thunks.len;
                    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0021;
                    goto L0022;
                L0021:;
                    ctx->cur = p;
                    pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                L0022:;
                }
                if (ctx->cur == p) break;
                continue;
            L0020:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0023;
            goto L0024;
        L0023:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0024:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0017;
        goto L0001;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImplicitInvocation, &chunk->thunks, NULL)) goto L0025;
        goto L0001;
    L0025:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImplicitShorthand, &chunk->thunks, NULL)) goto L0026;
        goto L0001;
    L0026:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ShorthandFeatureMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ShorthandFeatureMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ImplicitInvocation(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ImplicitInvocation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SpecializationKeyword, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageKeyword, &chunk->thunks, NULL)) goto L0002;
        ctx->cur = p;
        goto L0000;
    L0002:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArgumentList, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ImplicitInvocation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ImplicitInvocation", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UsageKeyword(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UsageKeyword", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'c' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'o' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'n' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'e' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'c' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't'
        ) goto L0002;
        ctx->cur += 7;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'l' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'l' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'o' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'c' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'a' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't' ||
            pcc_refill_buffer(ctx, 8) < 8 || (ctx->buffer.buf + ctx->cur)[7] != 'e'
        ) goto L0003;
        ctx->cur += 8;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'i' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'n' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'l' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'u' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'd' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'e'
        ) goto L0004;
        ctx->cur += 7;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'p' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'r' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'f' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'o' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'r' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 'm'
        ) goto L0005;
        ctx->cur += 7;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'e' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'x' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'h' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'i' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'b' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 'i' ||
            pcc_refill_buffer(ctx, 7) < 7 || (ctx->buffer.buf + ctx->cur)[6] != 't'
        ) goto L0006;
        ctx->cur += 7;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 's' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'e' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'n' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'd'
        ) goto L0007;
        ctx->cur += 4;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (
            pcc_refill_buffer(ctx, 1) < 1 || (ctx->buffer.buf + ctx->cur)[0] != 'a' ||
            pcc_refill_buffer(ctx, 2) < 2 || (ctx->buffer.buf + ctx->cur)[1] != 'c' ||
            pcc_refill_buffer(ctx, 3) < 3 || (ctx->buffer.buf + ctx->cur)[2] != 'c' ||
            pcc_refill_buffer(ctx, 4) < 4 || (ctx->buffer.buf + ctx->cur)[3] != 'e' ||
            pcc_refill_buffer(ctx, 5) < 5 || (ctx->buffer.buf + ctx->cur)[4] != 'p' ||
            pcc_refill_buffer(ctx, 6) < 6 || (ctx->buffer.buf + ctx->cur)[5] != 't'
        ) goto L0008;
        ctx->cur += 6;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IdentCont, &chunk->thunks, NULL)) goto L0009;
        ctx->cur = p;
        goto L0000;
    L0009:;
        ctx->cur = p;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UsageKeyword", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UsageKeyword", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ImplicitShorthand(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ImplicitShorthand", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p = ctx->cur;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SpecializationKeyword, &chunk->thunks, NULL)) goto L0001;
        ctx->cur = p;
        goto L0000;
    L0001:;
        ctx->cur = p;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureSpecialization, &chunk->thunks, NULL)) goto L0004;
            if (ctx->cur == p) break;
            continue;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ImplicitShorthand", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ImplicitShorthand", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BindUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BindUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BINDING, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BIND, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0007;
            goto L0008;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0008:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQ, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0009;
            goto L0010;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0010:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0011;
            goto L0012;
        L0011:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0012:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BIND, &chunk->thunks, NULL)) goto L0013;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0014;
            goto L0015;
        L0014:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0015:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0013;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0016;
            goto L0017;
        L0016:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0017:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQ, &chunk->thunks, NULL)) goto L0013;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0018;
            goto L0019;
        L0018:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0019:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0013;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0020;
            goto L0021;
        L0020:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0021:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationshipBody, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BindUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BindUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AssertConstraintUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AssertConstraintUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ASSERT, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NOT, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AssertConstraintBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AssertConstraintUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AssertConstraintUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AssertConstraintBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AssertConstraintBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTRAINT, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintBody, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AssertConstraintBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AssertConstraintBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SatisfyUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SatisfyUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NOT, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SATISFY, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIREMENT, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BY, &chunk->thunks, NULL)) goto L0007;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0007;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0008;
                goto L0009;
            L0008:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0009:;
            }
            goto L0010;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0010:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NOT, &chunk->thunks, NULL)) goto L0012;
            goto L0013;
        L0012:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0013:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SATISFY, &chunk->thunks, NULL)) goto L0011;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0011;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0014;
            goto L0015;
        L0014:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0015:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BY, &chunk->thunks, NULL)) goto L0016;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0016;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0017;
                goto L0018;
            L0017:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0018:;
            }
            goto L0019;
        L0016:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0019:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SatisfyUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SatisfyUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AssertSatisfyUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AssertSatisfyUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ASSERT, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NOT, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SATISFY, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIREMENT, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BY, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0007;
            goto L0008;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0008:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ASSERT, &chunk->thunks, NULL)) goto L0009;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NOT, &chunk->thunks, NULL)) goto L0010;
            goto L0011;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0011:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_SATISFY, &chunk->thunks, NULL)) goto L0009;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0009;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0012;
            goto L0013;
        L0012:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0013:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_BY, &chunk->thunks, NULL)) goto L0009;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0009;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0014;
            goto L0015;
        L0014:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0015:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AssertSatisfyUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AssertSatisfyUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AssumeConstraint(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AssumeConstraint", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ASSUME, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTRAINT, &chunk->thunks, NULL)) goto L0002;
        goto L0003;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0003:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AssumeConstraint", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AssumeConstraint", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RequireConstraint(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RequireConstraint", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIRE, &chunk->thunks, NULL)) goto L0002;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0003;
                if (ctx->cur == p) break;
                continue;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_CONSTRAINT, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConstraintBody, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIRE, &chunk->thunks, NULL)) goto L0006;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0007;
                if (ctx->cur == p) break;
                continue;
            L0007:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0006;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0006;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REQUIRE, &chunk->thunks, NULL)) goto L0008;
        {
            for (;;) {
                const size_t p = ctx->cur;
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrefixMetadata, &chunk->thunks, NULL)) goto L0009;
                if (ctx->cur == p) break;
                continue;
            L0009:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                break;
            }
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0008;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RequireConstraint", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RequireConstraint", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EndMember(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EndMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_END, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REF, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PORT, &chunk->thunks, NULL)) goto L0009;
            goto L0008;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ITEM, &chunk->thunks, NULL)) goto L0010;
            goto L0008;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PART, &chunk->thunks, NULL)) goto L0011;
            goto L0008;
        L0011:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OCCURRENCE, &chunk->thunks, NULL)) goto L0012;
            goto L0008;
        L0012:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ACTION, &chunk->thunks, NULL)) goto L0013;
            goto L0008;
        L0013:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0007;
        L0008:;
        }
        goto L0014;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0014:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageDeclaration, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EndMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EndMember", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MessageUsage(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MessageUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsagePrefix, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_MESSAGE, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0003;
        goto L0002;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Identification, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageSpecializations, &chunk->thunks, NULL)) goto L0007;
            goto L0008;
        L0007:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0008:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OF, &chunk->thunks, NULL)) goto L0009;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0009;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COLON, &chunk->thunks, NULL)) goto L0010;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0010;
                goto L0011;
            L0010:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0011:;
            }
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Multiplicity, &chunk->thunks, NULL)) goto L0012;
                goto L0013;
            L0012:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            L0013:;
            }
            goto L0014;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0014:;
        }
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureValue, &chunk->thunks, NULL)) goto L0015;
            goto L0016;
        L0015:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0016:;
        }
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MessageFlowPart, &chunk->thunks, NULL)) goto L0017;
        goto L0018;
    L0017:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0018:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UsageBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MessageUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MessageUsage", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MessageFlowPart(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MessageFlowPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FROM, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowEndMember, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TO, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowEndMember, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FlowConnectionPart, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MessageFlowPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MessageFlowPart", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_TerminateAction(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "TerminateAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TERMINATE, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TERMINATE, &chunk->thunks, NULL)) goto L0005;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "TerminateAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "TerminateAction", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ResultExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ResultExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ResultExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ResultExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OwnedExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OwnedExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConditionalExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OwnedExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OwnedExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConditionalExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConditionalExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IF, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImplicationExpression, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QMARK, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImplicationExpression, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ELSE, &chunk->thunks, NULL)) goto L0005;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConditionalExpression, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImplicationExpression, &chunk->thunks, NULL)) goto L0007;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IF, &chunk->thunks, NULL)) goto L0008;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ImplicationExpression, &chunk->thunks, NULL)) goto L0008;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ELSE, &chunk->thunks, NULL)) goto L0008;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConditionalExpression, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConditionalExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConditionalExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ImplicationExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ImplicationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NullCoalescingExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IMPLIES, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NullCoalescingExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ImplicationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ImplicationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NullCoalescingExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NullCoalescingExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OrExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QMARKQMARK, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OrExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NullCoalescingExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NullCoalescingExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OrExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OrExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_XorExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OrOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_XorExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OrExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OrExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OrOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OrOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PIPE, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_OR, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OrOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OrOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_XorExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "XorExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AndExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_XorOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AndExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "XorExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "XorExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_XorOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "XorOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_XOR, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "XorOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "XorOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AndExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AndExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EqualityExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AndOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EqualityExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AndExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AndExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AndOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AndOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AMP, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_AND, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AndOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AndOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EqualityExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EqualityExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassificationExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EqualityOperator, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassificationExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EqualityExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EqualityExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EqualityOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EqualityOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQEQ, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BANGEQ, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQEQEQ, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BANGEQEQ, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EqualityOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EqualityOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassificationExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ClassificationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationalExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassificationOperator, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ClassificationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ClassificationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassificationOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ClassificationOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_HASTYPE, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ISTYPE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AT, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_AS, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ClassificationOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ClassificationOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RelationalExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RelationalExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RangeExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationalOperator, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RangeExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RelationalExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RelationalExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RelationalOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RelationalOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LT, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_GT, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LE, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_GE, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RelationalOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RelationalOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RangeExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RangeExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AdditiveExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DOTDOT, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AdditiveExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RangeExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RangeExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AdditiveExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AdditiveExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MultiplicativeExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AdditiveOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MultiplicativeExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AdditiveExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AdditiveExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AdditiveOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AdditiveOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PLUS, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MINUS, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AdditiveOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AdditiveOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicativeExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MultiplicativeExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExponentiationExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MultiplicativeOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExponentiationExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MultiplicativeExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MultiplicativeExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicativeOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MultiplicativeOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STAR, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SLASH, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PERCENT, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MultiplicativeOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MultiplicativeOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExponentiationExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExponentiationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnaryExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STARSTAR, &chunk->thunks, NULL)) goto L0003;
            goto L0002;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CARET, &chunk->thunks, NULL)) goto L0004;
            goto L0002;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0001;
        L0002:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnaryExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0005;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExponentiationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExponentiationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UnaryExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UnaryExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnaryOperator, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExtentExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UnaryExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UnaryExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UnaryOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UnaryOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PLUS, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MINUS, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BANG, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NOT, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TILDE, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UnaryOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UnaryOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExtentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExtentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExtentExpression, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SequenceExpression, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExtentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExtentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SequenceExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SequenceExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BracketExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SequenceTail, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SequenceExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SequenceExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SequenceTail(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SequenceTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnaryExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SequenceTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SequenceTail", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BracketExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BracketExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_PrimaryExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArgumentList, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QMARK, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SelectOperator, &chunk->thunks, NULL)) goto L0007;
        goto L0008;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0008:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IndexExpression, &chunk->thunks, NULL)) goto L0009;
        goto L0010;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0010:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACKET, &chunk->thunks, NULL)) goto L0011;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0012;
            goto L0013;
        L0012:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0013:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACKET, &chunk->thunks, NULL)) goto L0011;
        goto L0014;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0014:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0015;
        goto L0016;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0016:;
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CollectionOperator, &chunk->thunks, NULL)) goto L0017;
            if (ctx->cur == p) break;
            continue;
        L0017:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_IndexExpression, &chunk->thunks, NULL)) goto L0018;
        goto L0019;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0019:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BracketExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BracketExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SelectOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DOTQ, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CollectionBody, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SelectOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SelectOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_IndexExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "IndexExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_HASH, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LPAREN, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RPAREN, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "IndexExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "IndexExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectionOperator(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CollectionOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ARROW, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CollectionBody, &chunk->thunks, NULL)) goto L0003;
            goto L0002;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FunctionReferenceArg, &chunk->thunks, NULL)) goto L0004;
            goto L0002;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArgumentList, &chunk->thunks, NULL)) goto L0005;
            goto L0002;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0001;
        L0002:;
        }
        goto L0006;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CollectionOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CollectionOperator", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FunctionReferenceArg(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FunctionReferenceArg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STRING_VALUE, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FunctionReferenceArg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FunctionReferenceArg", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectionBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CollectionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CollectionBodyParameter, &chunk->thunks, NULL)) goto L0002;
            if (ctx->cur == p) break;
            continue;
        L0002:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CollectionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CollectionBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectionBodyParameter(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CollectionBodyParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_VisibilityIndicator, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IN, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_REF, &chunk->thunks, NULL)) goto L0005;
        goto L0006;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0006:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ATTRIBUTE, &chunk->thunks, NULL)) goto L0009;
            goto L0008;
        L0009:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_PART, &chunk->thunks, NULL)) goto L0010;
            goto L0008;
        L0010:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ITEM, &chunk->thunks, NULL)) goto L0011;
            goto L0008;
        L0011:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0007;
        L0008:;
        }
        goto L0012;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0012:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_TypedBy, &chunk->thunks, NULL)) goto L0015;
            goto L0014;
        L0015:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Subsets, &chunk->thunks, NULL)) goto L0016;
            goto L0014;
        L0016:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0013;
        L0014:;
        }
        goto L0017;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0017:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQ, &chunk->thunks, NULL)) goto L0018;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0018;
        goto L0019;
    L0018:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0019:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SEMICOLON, &chunk->thunks, NULL)) goto L0021;
        goto L0020;
    L0021:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CollectionParameterBody, &chunk->thunks, NULL)) goto L0022;
        goto L0020;
    L0022:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0020:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CollectionBodyParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CollectionBodyParameter", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectionParameterBody(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CollectionParameterBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            {
                MARK_VAR_AS_USED
                const size_t p = ctx->cur;
                MARK_VAR_AS_USED
                const size_t n = chunk->thunks.len;
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ShorthandFeatureMember, &chunk->thunks, NULL)) goto L0003;
                goto L0002;
            L0003:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AnnotatingElement, &chunk->thunks, NULL)) goto L0004;
                goto L0002;
            L0004:;
                ctx->cur = p;
                pcc_thunk_array__revert(ctx, &chunk->thunks, n);
                goto L0001;
            L0002:;
            }
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CollectionParameterBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CollectionParameterBody", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_PrimaryExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "PrimaryExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BodyExpression, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LPAREN, &chunk->thunks, NULL)) goto L0003;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0004;
            goto L0005;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0005:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RPAREN, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NewExpression, &chunk->thunks, NULL)) goto L0006;
        goto L0001;
    L0006:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SelectExpression, &chunk->thunks, NULL)) goto L0007;
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CollectExpression, &chunk->thunks, NULL)) goto L0008;
        goto L0001;
    L0008:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NullExpression, &chunk->thunks, NULL)) goto L0009;
        goto L0001;
    L0009:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataAccessExpression, &chunk->thunks, NULL)) goto L0010;
        goto L0001;
    L0010:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetadataReferenceExpression, &chunk->thunks, NULL)) goto L0011;
        goto L0001;
    L0011:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MetaExpression, &chunk->thunks, NULL)) goto L0012;
        goto L0001;
    L0012:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_InvocationExpression, &chunk->thunks, NULL)) goto L0013;
        goto L0001;
    L0013:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NameExpression, &chunk->thunks, NULL)) goto L0014;
        goto L0001;
    L0014:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LiteralExpression, &chunk->thunks, NULL)) goto L0015;
        goto L0001;
    L0015:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "PrimaryExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "PrimaryExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataReferenceExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetadataReferenceExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetadataReferenceExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetadataReferenceExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetaExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetaExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_META, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetaExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetaExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_BodyExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "BodyExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LBRACE, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OwnedExpression, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RBRACE, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "BodyExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "BodyExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NewExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NewExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NEW, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArgumentList, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0003;
        goto L0004;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0004:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NewExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NewExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_SelectExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "SelectExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DOT, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QMARK, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SequenceExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "SelectExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "SelectExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_CollectExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "CollectExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DOTQ, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_SequenceExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "CollectExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "CollectExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NullExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NullExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_NULL, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NullExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NullExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MetadataAccessExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MetadataAccessExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DOT, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_METADATA, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MetadataAccessExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MetadataAccessExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_InvocationExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "InvocationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArgumentList, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "InvocationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "InvocationExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ArgumentList(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ArgumentList", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LPAREN, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArgumentListItems, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RPAREN, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ArgumentList", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ArgumentList", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ArgumentListItems(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ArgumentListItems", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Argument, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_COMMA, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_Argument, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ArgumentListItems", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ArgumentListItems", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_Argument(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "Argument", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NAME, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EQ, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "Argument", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "Argument", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConditionalArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ConditionalArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ConditionalArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IF, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NullCoalescingArgumentExpression, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QMARK, &chunk->thunks, NULL)) goto L0003;
            goto L0004;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0004:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NullCoalescingArgumentExpression, &chunk->thunks, NULL)) goto L0002;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ELSE, &chunk->thunks, NULL)) goto L0005;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConditionalArgumentExpression, &chunk->thunks, NULL)) goto L0005;
            goto L0006;
        L0005:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0006:;
        }
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NullCoalescingArgumentExpression, &chunk->thunks, NULL)) goto L0007;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_IF, &chunk->thunks, NULL)) goto L0008;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_NullCoalescingArgumentExpression, &chunk->thunks, NULL)) goto L0008;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ELSE, &chunk->thunks, NULL)) goto L0008;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ConditionalArgumentExpression, &chunk->thunks, NULL)) goto L0008;
            goto L0009;
        L0008:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        L0009:;
        }
        goto L0001;
    L0007:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ConditionalArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ConditionalArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NullCoalescingArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NullCoalescingArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OrArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QMARKQMARK, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OrArgumentExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NullCoalescingArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NullCoalescingArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_OrArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "OrArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_XorArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_OrOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_XorArgumentExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "OrArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "OrArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_XorArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "XorArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AndArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_XorOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AndArgumentExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "XorArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "XorArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AndArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AndArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EqualityArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AndOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EqualityArgumentExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AndArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AndArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_EqualityArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "EqualityArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassificationArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_EqualityOperator, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassificationArgumentExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "EqualityArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "EqualityArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ClassificationArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ClassificationArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationalArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ClassificationOperator, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ClassificationArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ClassificationArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RelationalArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RelationalArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RangeArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RelationalOperator, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_RangeArgumentExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RelationalArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RelationalArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_RangeArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "RangeArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AdditiveArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DOTDOT, &chunk->thunks, NULL)) goto L0001;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AdditiveArgumentExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "RangeArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "RangeArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_AdditiveArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "AdditiveArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MultiplicativeArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_AdditiveOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MultiplicativeArgumentExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "AdditiveArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "AdditiveArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_MultiplicativeArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "MultiplicativeArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExponentiationArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        for (;;) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_MultiplicativeOperator, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExponentiationArgumentExpression, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "MultiplicativeArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "MultiplicativeArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExponentiationArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExponentiationArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnaryArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        {
            MARK_VAR_AS_USED
            const size_t p = ctx->cur;
            MARK_VAR_AS_USED
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STARSTAR, &chunk->thunks, NULL)) goto L0003;
            goto L0002;
        L0003:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_CARET, &chunk->thunks, NULL)) goto L0004;
            goto L0002;
        L0004:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            goto L0001;
        L0002:;
        }
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnaryArgumentExpression, &chunk->thunks, NULL)) goto L0001;
        goto L0005;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0005:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExponentiationArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExponentiationArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_UnaryArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "UnaryArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_UnaryOperator, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExtentArgumentExpression, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "UnaryArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "UnaryArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_ExtentArgumentExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "ExtentArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_ALL, &chunk->thunks, NULL)) goto L0002;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_ExtentArgumentExpression, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_BracketExpression, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "ExtentArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "ExtentArgumentExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_NameExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "NameExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0000;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_FeatureChain, &chunk->thunks, NULL)) goto L0001;
        goto L0002;
    L0001:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
    L0002:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "NameExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "NameExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_FeatureChain(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "FeatureChain", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        const size_t p0 = ctx->cur;
        const size_t n0 = chunk->thunks.len;
        int i;
        for (i = 0;; i++) {
            const size_t p = ctx->cur;
            const size_t n = chunk->thunks.len;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DOT, &chunk->thunks, NULL)) goto L0001;
            if (!pcc_apply_rule(ctx, pcc_evaluate_rule_QualifiedName, &chunk->thunks, NULL)) goto L0001;
            if (ctx->cur == p) break;
            continue;
        L0001:;
            ctx->cur = p;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n);
            break;
        }
        if (i < 1) {
            ctx->cur = p0;
            pcc_thunk_array__revert(ctx, &chunk->thunks, n0);
            goto L0000;
        }
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "FeatureChain", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "FeatureChain", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralExpression(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LiteralExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LiteralBoolean, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LiteralString, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LiteralReal, &chunk->thunks, NULL)) goto L0004;
        goto L0001;
    L0004:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_LiteralInteger, &chunk->thunks, NULL)) goto L0005;
        goto L0001;
    L0005:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LiteralExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LiteralExpression", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralBoolean(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LiteralBoolean", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    {
        MARK_VAR_AS_USED
        const size_t p = ctx->cur;
        MARK_VAR_AS_USED
        const size_t n = chunk->thunks.len;
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_TRUE, &chunk->thunks, NULL)) goto L0002;
        goto L0001;
    L0002:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        if (!pcc_apply_rule(ctx, pcc_evaluate_rule_KW_FALSE, &chunk->thunks, NULL)) goto L0003;
        goto L0001;
    L0003:;
        ctx->cur = p;
        pcc_thunk_array__revert(ctx, &chunk->thunks, n);
        goto L0000;
    L0001:;
    }
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LiteralBoolean", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LiteralBoolean", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralString(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LiteralString", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_STRING_VALUE, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LiteralString", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LiteralString", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralReal(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LiteralReal", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_REAL_VALUE, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LiteralReal", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LiteralReal", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

static pcc_thunk_chunk_t *pcc_evaluate_rule_LiteralInteger(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = ctx->cur;
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "LiteralInteger", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->buffer.len - chunk->pos));
    ctx->level++;
    if (!pcc_apply_rule(ctx, pcc_evaluate_rule_DECIMAL_VALUE, &chunk->thunks, NULL)) goto L0000;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "LiteralInteger", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    return chunk;
L0000:;
    ctx->level--;
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "LiteralInteger", ctx->level, chunk->pos, (ctx->buffer.buf + chunk->pos), (ctx->cur - chunk->pos));
    pcc_thunk_chunk__destroy(ctx, chunk);
    return NULL;
}

sysml2_context_t *sysml2_create(SysmlParserContext *auxil) {
    return pcc_context__create(auxil);
}

int sysml2_parse(sysml2_context_t *ctx, void **ret) {
    if (pcc_refill_buffer(ctx, 1) < 1) return 0;
    if (pcc_apply_rule(ctx, pcc_evaluate_rule_File, &ctx->thunks, ret))
        pcc_do_action(ctx, &ctx->thunks, ret);
    else
        PCC_ERROR(ctx->auxil);
    pcc_commit_buffer(ctx);
    pcc_thunk_array__revert(ctx, &ctx->thunks, 0);
    return 1;
}

void sysml2_destroy(sysml2_context_t *ctx) {
    pcc_context__destroy(ctx);
}

